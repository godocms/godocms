var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a9, b7) => {
  for (var prop in b7 || (b7 = {}))
    if (__hasOwnProp.call(b7, prop))
      __defNormalProp(a9, prop, b7[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b7)) {
      if (__propIsEnum.call(b7, prop))
        __defNormalProp(a9, prop, b7[prop]);
    }
  return a9;
};
var __spreadProps = (a9, b7) => __defProps(a9, __getOwnPropDescs(b7));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// ../../node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../../node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i8 = 0; i8 < 10; i8++) {
          test2["_" + String.fromCharCode(i8)] = i8;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n6) {
          return test2[n6];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s8 = 1; s8 < arguments.length; s8++) {
        from = Object(arguments[s8]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i8 = 0; i8 < symbols.length; i8++) {
            if (propIsEnumerable.call(from, symbols[i8])) {
              to[symbols[i8]] = from[symbols[i8]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../../node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "../../node_modules/react/cjs/react.production.min.js"(exports2) {
    "use strict";
    var l9 = require_object_assign();
    var n6 = 60103;
    var p7 = 60106;
    exports2.Fragment = 60107;
    exports2.StrictMode = 60108;
    exports2.Profiler = 60114;
    var q3 = 60109;
    var r13 = 60110;
    var t14 = 60112;
    exports2.Suspense = 60113;
    var u4 = 60115;
    var v6 = 60116;
    if (typeof Symbol === "function" && Symbol.for) {
      w6 = Symbol.for;
      n6 = w6("react.element");
      p7 = w6("react.portal");
      exports2.Fragment = w6("react.fragment");
      exports2.StrictMode = w6("react.strict_mode");
      exports2.Profiler = w6("react.profiler");
      q3 = w6("react.provider");
      r13 = w6("react.context");
      t14 = w6("react.forward_ref");
      exports2.Suspense = w6("react.suspense");
      u4 = w6("react.memo");
      v6 = w6("react.lazy");
    }
    var w6;
    var x5 = typeof Symbol === "function" && Symbol.iterator;
    function y4(a9) {
      if (a9 === null || typeof a9 !== "object")
        return null;
      a9 = x5 && a9[x5] || a9["@@iterator"];
      return typeof a9 === "function" ? a9 : null;
    }
    function z3(a9) {
      for (var b7 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a9, c7 = 1; c7 < arguments.length; c7++)
        b7 += "&args[]=" + encodeURIComponent(arguments[c7]);
      return "Minified React error #" + a9 + "; visit " + b7 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var A4 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    var B3 = {};
    function C6(a9, b7, c7) {
      this.props = a9;
      this.context = b7;
      this.refs = B3;
      this.updater = c7 || A4;
    }
    C6.prototype.isReactComponent = {};
    C6.prototype.setState = function(a9, b7) {
      if (typeof a9 !== "object" && typeof a9 !== "function" && a9 != null)
        throw Error(z3(85));
      this.updater.enqueueSetState(this, a9, b7, "setState");
    };
    C6.prototype.forceUpdate = function(a9) {
      this.updater.enqueueForceUpdate(this, a9, "forceUpdate");
    };
    function D7() {
    }
    D7.prototype = C6.prototype;
    function E6(a9, b7, c7) {
      this.props = a9;
      this.context = b7;
      this.refs = B3;
      this.updater = c7 || A4;
    }
    var F5 = E6.prototype = new D7();
    F5.constructor = E6;
    l9(F5, C6.prototype);
    F5.isPureReactComponent = true;
    var G4 = { current: null };
    var H3 = Object.prototype.hasOwnProperty;
    var I3 = { key: true, ref: true, __self: true, __source: true };
    function J3(a9, b7, c7) {
      var e12, d8 = {}, k3 = null, h3 = null;
      if (b7 != null)
        for (e12 in b7.ref !== void 0 && (h3 = b7.ref), b7.key !== void 0 && (k3 = "" + b7.key), b7)
          H3.call(b7, e12) && !I3.hasOwnProperty(e12) && (d8[e12] = b7[e12]);
      var g5 = arguments.length - 2;
      if (g5 === 1)
        d8.children = c7;
      else if (1 < g5) {
        for (var f11 = Array(g5), m7 = 0; m7 < g5; m7++)
          f11[m7] = arguments[m7 + 2];
        d8.children = f11;
      }
      if (a9 && a9.defaultProps)
        for (e12 in g5 = a9.defaultProps, g5)
          d8[e12] === void 0 && (d8[e12] = g5[e12]);
      return { $$typeof: n6, type: a9, key: k3, ref: h3, props: d8, _owner: G4.current };
    }
    function K2(a9, b7) {
      return { $$typeof: n6, type: a9.type, key: b7, ref: a9.ref, props: a9.props, _owner: a9._owner };
    }
    function L4(a9) {
      return typeof a9 === "object" && a9 !== null && a9.$$typeof === n6;
    }
    function escape(a9) {
      var b7 = { "=": "=0", ":": "=2" };
      return "$" + a9.replace(/[=:]/g, function(a10) {
        return b7[a10];
      });
    }
    var M4 = /\/+/g;
    function N2(a9, b7) {
      return typeof a9 === "object" && a9 !== null && a9.key != null ? escape("" + a9.key) : b7.toString(36);
    }
    function O5(a9, b7, c7, e12, d8) {
      var k3 = typeof a9;
      if (k3 === "undefined" || k3 === "boolean")
        a9 = null;
      var h3 = false;
      if (a9 === null)
        h3 = true;
      else
        switch (k3) {
          case "string":
          case "number":
            h3 = true;
            break;
          case "object":
            switch (a9.$$typeof) {
              case n6:
              case p7:
                h3 = true;
            }
        }
      if (h3)
        return h3 = a9, d8 = d8(h3), a9 = e12 === "" ? "." + N2(h3, 0) : e12, Array.isArray(d8) ? (c7 = "", a9 != null && (c7 = a9.replace(M4, "$&/") + "/"), O5(d8, b7, c7, "", function(a10) {
          return a10;
        })) : d8 != null && (L4(d8) && (d8 = K2(d8, c7 + (!d8.key || h3 && h3.key === d8.key ? "" : ("" + d8.key).replace(M4, "$&/") + "/") + a9)), b7.push(d8)), 1;
      h3 = 0;
      e12 = e12 === "" ? "." : e12 + ":";
      if (Array.isArray(a9))
        for (var g5 = 0; g5 < a9.length; g5++) {
          k3 = a9[g5];
          var f11 = e12 + N2(k3, g5);
          h3 += O5(k3, b7, c7, f11, d8);
        }
      else if (f11 = y4(a9), typeof f11 === "function")
        for (a9 = f11.call(a9), g5 = 0; !(k3 = a9.next()).done; )
          k3 = k3.value, f11 = e12 + N2(k3, g5++), h3 += O5(k3, b7, c7, f11, d8);
      else if (k3 === "object")
        throw b7 = "" + a9, Error(z3(31, b7 === "[object Object]" ? "object with keys {" + Object.keys(a9).join(", ") + "}" : b7));
      return h3;
    }
    function P3(a9, b7, c7) {
      if (a9 == null)
        return a9;
      var e12 = [], d8 = 0;
      O5(a9, e12, "", "", function(a10) {
        return b7.call(c7, a10, d8++);
      });
      return e12;
    }
    function Q(a9) {
      if (a9._status === -1) {
        var b7 = a9._result;
        b7 = b7();
        a9._status = 0;
        a9._result = b7;
        b7.then(function(b8) {
          a9._status === 0 && (b8 = b8.default, a9._status = 1, a9._result = b8);
        }, function(b8) {
          a9._status === 0 && (a9._status = 2, a9._result = b8);
        });
      }
      if (a9._status === 1)
        return a9._result;
      throw a9._result;
    }
    var R5 = { current: null };
    function S3() {
      var a9 = R5.current;
      if (a9 === null)
        throw Error(z3(321));
      return a9;
    }
    var T5 = { ReactCurrentDispatcher: R5, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G4, IsSomeRendererActing: { current: false }, assign: l9 };
    exports2.Children = { map: P3, forEach: function(a9, b7, c7) {
      P3(a9, function() {
        b7.apply(this, arguments);
      }, c7);
    }, count: function(a9) {
      var b7 = 0;
      P3(a9, function() {
        b7++;
      });
      return b7;
    }, toArray: function(a9) {
      return P3(a9, function(a10) {
        return a10;
      }) || [];
    }, only: function(a9) {
      if (!L4(a9))
        throw Error(z3(143));
      return a9;
    } };
    exports2.Component = C6;
    exports2.PureComponent = E6;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T5;
    exports2.cloneElement = function(a9, b7, c7) {
      if (a9 === null || a9 === void 0)
        throw Error(z3(267, a9));
      var e12 = l9({}, a9.props), d8 = a9.key, k3 = a9.ref, h3 = a9._owner;
      if (b7 != null) {
        b7.ref !== void 0 && (k3 = b7.ref, h3 = G4.current);
        b7.key !== void 0 && (d8 = "" + b7.key);
        if (a9.type && a9.type.defaultProps)
          var g5 = a9.type.defaultProps;
        for (f11 in b7)
          H3.call(b7, f11) && !I3.hasOwnProperty(f11) && (e12[f11] = b7[f11] === void 0 && g5 !== void 0 ? g5[f11] : b7[f11]);
      }
      var f11 = arguments.length - 2;
      if (f11 === 1)
        e12.children = c7;
      else if (1 < f11) {
        g5 = Array(f11);
        for (var m7 = 0; m7 < f11; m7++)
          g5[m7] = arguments[m7 + 2];
        e12.children = g5;
      }
      return {
        $$typeof: n6,
        type: a9.type,
        key: d8,
        ref: k3,
        props: e12,
        _owner: h3
      };
    };
    exports2.createContext = function(a9, b7) {
      b7 === void 0 && (b7 = null);
      a9 = { $$typeof: r13, _calculateChangedBits: b7, _currentValue: a9, _currentValue2: a9, _threadCount: 0, Provider: null, Consumer: null };
      a9.Provider = { $$typeof: q3, _context: a9 };
      return a9.Consumer = a9;
    };
    exports2.createElement = J3;
    exports2.createFactory = function(a9) {
      var b7 = J3.bind(null, a9);
      b7.type = a9;
      return b7;
    };
    exports2.createRef = function() {
      return { current: null };
    };
    exports2.forwardRef = function(a9) {
      return { $$typeof: t14, render: a9 };
    };
    exports2.isValidElement = L4;
    exports2.lazy = function(a9) {
      return { $$typeof: v6, _payload: { _status: -1, _result: a9 }, _init: Q };
    };
    exports2.memo = function(a9, b7) {
      return { $$typeof: u4, type: a9, compare: b7 === void 0 ? null : b7 };
    };
    exports2.useCallback = function(a9, b7) {
      return S3().useCallback(a9, b7);
    };
    exports2.useContext = function(a9, b7) {
      return S3().useContext(a9, b7);
    };
    exports2.useDebugValue = function() {
    };
    exports2.useEffect = function(a9, b7) {
      return S3().useEffect(a9, b7);
    };
    exports2.useImperativeHandle = function(a9, b7, c7) {
      return S3().useImperativeHandle(a9, b7, c7);
    };
    exports2.useLayoutEffect = function(a9, b7) {
      return S3().useLayoutEffect(a9, b7);
    };
    exports2.useMemo = function(a9, b7) {
      return S3().useMemo(a9, b7);
    };
    exports2.useReducer = function(a9, b7, c7) {
      return S3().useReducer(a9, b7, c7);
    };
    exports2.useRef = function(a9) {
      return S3().useRef(a9);
    };
    exports2.useState = function(a9) {
      return S3().useState(a9);
    };
    exports2.version = "17.0.2";
  }
});

// ../../node_modules/react/index.js
var require_react = __commonJS({
  "../../node_modules/react/index.js"(exports2, module2) {
    "use strict";
    if (true) {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
  "../../node_modules/scheduler/cjs/scheduler.production.min.js"(exports2) {
    "use strict";
    var f11;
    var g5;
    var h3;
    var k3;
    if (typeof performance === "object" && typeof performance.now === "function") {
      l9 = performance;
      exports2.unstable_now = function() {
        return l9.now();
      };
    } else {
      p7 = Date, q3 = p7.now();
      exports2.unstable_now = function() {
        return p7.now() - q3;
      };
    }
    var l9;
    var p7;
    var q3;
    if (typeof window === "undefined" || typeof MessageChannel !== "function") {
      t14 = null, u4 = null, w6 = function() {
        if (t14 !== null)
          try {
            var a9 = exports2.unstable_now();
            t14(true, a9);
            t14 = null;
          } catch (b7) {
            throw setTimeout(w6, 0), b7;
          }
      };
      f11 = function(a9) {
        t14 !== null ? setTimeout(f11, 0, a9) : (t14 = a9, setTimeout(w6, 0));
      };
      g5 = function(a9, b7) {
        u4 = setTimeout(a9, b7);
      };
      h3 = function() {
        clearTimeout(u4);
      };
      exports2.unstable_shouldYield = function() {
        return false;
      };
      k3 = exports2.unstable_forceFrameRate = function() {
      };
    } else {
      x5 = window.setTimeout, y4 = window.clearTimeout;
      if (typeof console !== "undefined") {
        z3 = window.cancelAnimationFrame;
        typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        typeof z3 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      }
      A4 = false, B3 = null, C6 = -1, D7 = 5, E6 = 0;
      exports2.unstable_shouldYield = function() {
        return exports2.unstable_now() >= E6;
      };
      k3 = function() {
      };
      exports2.unstable_forceFrameRate = function(a9) {
        0 > a9 || 125 < a9 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D7 = 0 < a9 ? Math.floor(1e3 / a9) : 5;
      };
      F5 = new MessageChannel(), G4 = F5.port2;
      F5.port1.onmessage = function() {
        if (B3 !== null) {
          var a9 = exports2.unstable_now();
          E6 = a9 + D7;
          try {
            B3(true, a9) ? G4.postMessage(null) : (A4 = false, B3 = null);
          } catch (b7) {
            throw G4.postMessage(null), b7;
          }
        } else
          A4 = false;
      };
      f11 = function(a9) {
        B3 = a9;
        A4 || (A4 = true, G4.postMessage(null));
      };
      g5 = function(a9, b7) {
        C6 = x5(function() {
          a9(exports2.unstable_now());
        }, b7);
      };
      h3 = function() {
        y4(C6);
        C6 = -1;
      };
    }
    var t14;
    var u4;
    var w6;
    var x5;
    var y4;
    var z3;
    var A4;
    var B3;
    var C6;
    var D7;
    var E6;
    var F5;
    var G4;
    function H3(a9, b7) {
      var c7 = a9.length;
      a9.push(b7);
      a:
        for (; ; ) {
          var d8 = c7 - 1 >>> 1, e12 = a9[d8];
          if (e12 !== void 0 && 0 < I3(e12, b7))
            a9[d8] = b7, a9[c7] = e12, c7 = d8;
          else
            break a;
        }
    }
    function J3(a9) {
      a9 = a9[0];
      return a9 === void 0 ? null : a9;
    }
    function K2(a9) {
      var b7 = a9[0];
      if (b7 !== void 0) {
        var c7 = a9.pop();
        if (c7 !== b7) {
          a9[0] = c7;
          a:
            for (var d8 = 0, e12 = a9.length; d8 < e12; ) {
              var m7 = 2 * (d8 + 1) - 1, n6 = a9[m7], v6 = m7 + 1, r13 = a9[v6];
              if (n6 !== void 0 && 0 > I3(n6, c7))
                r13 !== void 0 && 0 > I3(r13, n6) ? (a9[d8] = r13, a9[v6] = c7, d8 = v6) : (a9[d8] = n6, a9[m7] = c7, d8 = m7);
              else if (r13 !== void 0 && 0 > I3(r13, c7))
                a9[d8] = r13, a9[v6] = c7, d8 = v6;
              else
                break a;
            }
        }
        return b7;
      }
      return null;
    }
    function I3(a9, b7) {
      var c7 = a9.sortIndex - b7.sortIndex;
      return c7 !== 0 ? c7 : a9.id - b7.id;
    }
    var L4 = [];
    var M4 = [];
    var N2 = 1;
    var O5 = null;
    var P3 = 3;
    var Q = false;
    var R5 = false;
    var S3 = false;
    function T5(a9) {
      for (var b7 = J3(M4); b7 !== null; ) {
        if (b7.callback === null)
          K2(M4);
        else if (b7.startTime <= a9)
          K2(M4), b7.sortIndex = b7.expirationTime, H3(L4, b7);
        else
          break;
        b7 = J3(M4);
      }
    }
    function U3(a9) {
      S3 = false;
      T5(a9);
      if (!R5)
        if (J3(L4) !== null)
          R5 = true, f11(V5);
        else {
          var b7 = J3(M4);
          b7 !== null && g5(U3, b7.startTime - a9);
        }
    }
    function V5(a9, b7) {
      R5 = false;
      S3 && (S3 = false, h3());
      Q = true;
      var c7 = P3;
      try {
        T5(b7);
        for (O5 = J3(L4); O5 !== null && (!(O5.expirationTime > b7) || a9 && !exports2.unstable_shouldYield()); ) {
          var d8 = O5.callback;
          if (typeof d8 === "function") {
            O5.callback = null;
            P3 = O5.priorityLevel;
            var e12 = d8(O5.expirationTime <= b7);
            b7 = exports2.unstable_now();
            typeof e12 === "function" ? O5.callback = e12 : O5 === J3(L4) && K2(L4);
            T5(b7);
          } else
            K2(L4);
          O5 = J3(L4);
        }
        if (O5 !== null)
          var m7 = true;
        else {
          var n6 = J3(M4);
          n6 !== null && g5(U3, n6.startTime - b7);
          m7 = false;
        }
        return m7;
      } finally {
        O5 = null, P3 = c7, Q = false;
      }
    }
    var W4 = k3;
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(a9) {
      a9.callback = null;
    };
    exports2.unstable_continueExecution = function() {
      R5 || Q || (R5 = true, f11(V5));
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return P3;
    };
    exports2.unstable_getFirstCallbackNode = function() {
      return J3(L4);
    };
    exports2.unstable_next = function(a9) {
      switch (P3) {
        case 1:
        case 2:
        case 3:
          var b7 = 3;
          break;
        default:
          b7 = P3;
      }
      var c7 = P3;
      P3 = b7;
      try {
        return a9();
      } finally {
        P3 = c7;
      }
    };
    exports2.unstable_pauseExecution = function() {
    };
    exports2.unstable_requestPaint = W4;
    exports2.unstable_runWithPriority = function(a9, b7) {
      switch (a9) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a9 = 3;
      }
      var c7 = P3;
      P3 = a9;
      try {
        return b7();
      } finally {
        P3 = c7;
      }
    };
    exports2.unstable_scheduleCallback = function(a9, b7, c7) {
      var d8 = exports2.unstable_now();
      typeof c7 === "object" && c7 !== null ? (c7 = c7.delay, c7 = typeof c7 === "number" && 0 < c7 ? d8 + c7 : d8) : c7 = d8;
      switch (a9) {
        case 1:
          var e12 = -1;
          break;
        case 2:
          e12 = 250;
          break;
        case 5:
          e12 = 1073741823;
          break;
        case 4:
          e12 = 1e4;
          break;
        default:
          e12 = 5e3;
      }
      e12 = c7 + e12;
      a9 = { id: N2++, callback: b7, priorityLevel: a9, startTime: c7, expirationTime: e12, sortIndex: -1 };
      c7 > d8 ? (a9.sortIndex = c7, H3(M4, a9), J3(L4) === null && a9 === J3(M4) && (S3 ? h3() : S3 = true, g5(U3, c7 - d8))) : (a9.sortIndex = e12, H3(L4, a9), R5 || Q || (R5 = true, f11(V5)));
      return a9;
    };
    exports2.unstable_wrapCallback = function(a9) {
      var b7 = P3;
      return function() {
        var c7 = P3;
        P3 = b7;
        try {
          return a9.apply(this, arguments);
        } finally {
          P3 = c7;
        }
      };
    };
  }
});

// ../../node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "../../node_modules/scheduler/index.js"(exports2, module2) {
    "use strict";
    if (true) {
      module2.exports = require_scheduler_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
  "../../node_modules/react-dom/cjs/react-dom.production.min.js"(exports2) {
    "use strict";
    var aa = require_react();
    var m7 = require_object_assign();
    var r13 = require_scheduler();
    function y4(a9) {
      for (var b7 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a9, c7 = 1; c7 < arguments.length; c7++)
        b7 += "&args[]=" + encodeURIComponent(arguments[c7]);
      return "Minified React error #" + a9 + "; visit " + b7 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    if (!aa)
      throw Error(y4(227));
    var ba = new Set();
    var ca = {};
    function da(a9, b7) {
      ea(a9, b7);
      ea(a9 + "Capture", b7);
    }
    function ea(a9, b7) {
      ca[a9] = b7;
      for (a9 = 0; a9 < b7.length; a9++)
        ba.add(b7[a9]);
    }
    var fa = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined");
    var ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var ia = Object.prototype.hasOwnProperty;
    var ja = {};
    var ka = {};
    function la(a9) {
      if (ia.call(ka, a9))
        return true;
      if (ia.call(ja, a9))
        return false;
      if (ha.test(a9))
        return ka[a9] = true;
      ja[a9] = true;
      return false;
    }
    function ma(a9, b7, c7, d8) {
      if (c7 !== null && c7.type === 0)
        return false;
      switch (typeof b7) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d8)
            return false;
          if (c7 !== null)
            return !c7.acceptsBooleans;
          a9 = a9.toLowerCase().slice(0, 5);
          return a9 !== "data-" && a9 !== "aria-";
        default:
          return false;
      }
    }
    function na(a9, b7, c7, d8) {
      if (b7 === null || typeof b7 === "undefined" || ma(a9, b7, c7, d8))
        return true;
      if (d8)
        return false;
      if (c7 !== null)
        switch (c7.type) {
          case 3:
            return !b7;
          case 4:
            return b7 === false;
          case 5:
            return isNaN(b7);
          case 6:
            return isNaN(b7) || 1 > b7;
        }
      return false;
    }
    function B3(a9, b7, c7, d8, e12, f11, g5) {
      this.acceptsBooleans = b7 === 2 || b7 === 3 || b7 === 4;
      this.attributeName = d8;
      this.attributeNamespace = e12;
      this.mustUseProperty = c7;
      this.propertyName = a9;
      this.type = b7;
      this.sanitizeURL = f11;
      this.removeEmptyString = g5;
    }
    var D7 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a9) {
      D7[a9] = new B3(a9, 0, false, a9, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a9) {
      var b7 = a9[0];
      D7[b7] = new B3(b7, 1, false, a9[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a9) {
      D7[a9] = new B3(a9, 2, false, a9.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a9) {
      D7[a9] = new B3(a9, 2, false, a9, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a9) {
      D7[a9] = new B3(a9, 3, false, a9.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a9) {
      D7[a9] = new B3(a9, 3, true, a9, null, false, false);
    });
    ["capture", "download"].forEach(function(a9) {
      D7[a9] = new B3(a9, 4, false, a9, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a9) {
      D7[a9] = new B3(a9, 6, false, a9, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a9) {
      D7[a9] = new B3(a9, 5, false, a9.toLowerCase(), null, false, false);
    });
    var oa = /[\-:]([a-z])/g;
    function pa(a9) {
      return a9[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a9) {
      var b7 = a9.replace(oa, pa);
      D7[b7] = new B3(b7, 1, false, a9, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a9) {
      var b7 = a9.replace(oa, pa);
      D7[b7] = new B3(b7, 1, false, a9, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a9) {
      var b7 = a9.replace(oa, pa);
      D7[b7] = new B3(b7, 1, false, a9, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a9) {
      D7[a9] = new B3(a9, 1, false, a9.toLowerCase(), null, false, false);
    });
    D7.xlinkHref = new B3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a9) {
      D7[a9] = new B3(a9, 1, false, a9.toLowerCase(), null, true, true);
    });
    function qa(a9, b7, c7, d8) {
      var e12 = D7.hasOwnProperty(b7) ? D7[b7] : null;
      var f11 = e12 !== null ? e12.type === 0 : d8 ? false : !(2 < b7.length) || b7[0] !== "o" && b7[0] !== "O" || b7[1] !== "n" && b7[1] !== "N" ? false : true;
      f11 || (na(b7, c7, e12, d8) && (c7 = null), d8 || e12 === null ? la(b7) && (c7 === null ? a9.removeAttribute(b7) : a9.setAttribute(b7, "" + c7)) : e12.mustUseProperty ? a9[e12.propertyName] = c7 === null ? e12.type === 3 ? false : "" : c7 : (b7 = e12.attributeName, d8 = e12.attributeNamespace, c7 === null ? a9.removeAttribute(b7) : (e12 = e12.type, c7 = e12 === 3 || e12 === 4 && c7 === true ? "" : "" + c7, d8 ? a9.setAttributeNS(d8, b7, c7) : a9.setAttribute(b7, c7))));
    }
    var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var sa = 60103;
    var ta = 60106;
    var ua = 60107;
    var wa = 60108;
    var xa = 60114;
    var ya = 60109;
    var za = 60110;
    var Aa = 60112;
    var Ba = 60113;
    var Ca = 60120;
    var Da = 60115;
    var Ea = 60116;
    var Fa = 60121;
    var Ga = 60128;
    var Ha = 60129;
    var Ia = 60130;
    var Ja = 60131;
    if (typeof Symbol === "function" && Symbol.for) {
      E6 = Symbol.for;
      sa = E6("react.element");
      ta = E6("react.portal");
      ua = E6("react.fragment");
      wa = E6("react.strict_mode");
      xa = E6("react.profiler");
      ya = E6("react.provider");
      za = E6("react.context");
      Aa = E6("react.forward_ref");
      Ba = E6("react.suspense");
      Ca = E6("react.suspense_list");
      Da = E6("react.memo");
      Ea = E6("react.lazy");
      Fa = E6("react.block");
      E6("react.scope");
      Ga = E6("react.opaque.id");
      Ha = E6("react.debug_trace_mode");
      Ia = E6("react.offscreen");
      Ja = E6("react.legacy_hidden");
    }
    var E6;
    var Ka = typeof Symbol === "function" && Symbol.iterator;
    function La(a9) {
      if (a9 === null || typeof a9 !== "object")
        return null;
      a9 = Ka && a9[Ka] || a9["@@iterator"];
      return typeof a9 === "function" ? a9 : null;
    }
    var Ma;
    function Na(a9) {
      if (Ma === void 0)
        try {
          throw Error();
        } catch (c7) {
          var b7 = c7.stack.trim().match(/\n( *(at )?)/);
          Ma = b7 && b7[1] || "";
        }
      return "\n" + Ma + a9;
    }
    var Oa = false;
    function Pa(a9, b7) {
      if (!a9 || Oa)
        return "";
      Oa = true;
      var c7 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b7)
          if (b7 = function() {
            throw Error();
          }, Object.defineProperty(b7.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect === "object" && Reflect.construct) {
            try {
              Reflect.construct(b7, []);
            } catch (k3) {
              var d8 = k3;
            }
            Reflect.construct(a9, [], b7);
          } else {
            try {
              b7.call();
            } catch (k3) {
              d8 = k3;
            }
            a9.call(b7.prototype);
          }
        else {
          try {
            throw Error();
          } catch (k3) {
            d8 = k3;
          }
          a9();
        }
      } catch (k3) {
        if (k3 && d8 && typeof k3.stack === "string") {
          for (var e12 = k3.stack.split("\n"), f11 = d8.stack.split("\n"), g5 = e12.length - 1, h3 = f11.length - 1; 1 <= g5 && 0 <= h3 && e12[g5] !== f11[h3]; )
            h3--;
          for (; 1 <= g5 && 0 <= h3; g5--, h3--)
            if (e12[g5] !== f11[h3]) {
              if (g5 !== 1 || h3 !== 1) {
                do
                  if (g5--, h3--, 0 > h3 || e12[g5] !== f11[h3])
                    return "\n" + e12[g5].replace(" at new ", " at ");
                while (1 <= g5 && 0 <= h3);
              }
              break;
            }
        }
      } finally {
        Oa = false, Error.prepareStackTrace = c7;
      }
      return (a9 = a9 ? a9.displayName || a9.name : "") ? Na(a9) : "";
    }
    function Qa(a9) {
      switch (a9.tag) {
        case 5:
          return Na(a9.type);
        case 16:
          return Na("Lazy");
        case 13:
          return Na("Suspense");
        case 19:
          return Na("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a9 = Pa(a9.type, false), a9;
        case 11:
          return a9 = Pa(a9.type.render, false), a9;
        case 22:
          return a9 = Pa(a9.type._render, false), a9;
        case 1:
          return a9 = Pa(a9.type, true), a9;
        default:
          return "";
      }
    }
    function Ra(a9) {
      if (a9 == null)
        return null;
      if (typeof a9 === "function")
        return a9.displayName || a9.name || null;
      if (typeof a9 === "string")
        return a9;
      switch (a9) {
        case ua:
          return "Fragment";
        case ta:
          return "Portal";
        case xa:
          return "Profiler";
        case wa:
          return "StrictMode";
        case Ba:
          return "Suspense";
        case Ca:
          return "SuspenseList";
      }
      if (typeof a9 === "object")
        switch (a9.$$typeof) {
          case za:
            return (a9.displayName || "Context") + ".Consumer";
          case ya:
            return (a9._context.displayName || "Context") + ".Provider";
          case Aa:
            var b7 = a9.render;
            b7 = b7.displayName || b7.name || "";
            return a9.displayName || (b7 !== "" ? "ForwardRef(" + b7 + ")" : "ForwardRef");
          case Da:
            return Ra(a9.type);
          case Fa:
            return Ra(a9._render);
          case Ea:
            b7 = a9._payload;
            a9 = a9._init;
            try {
              return Ra(a9(b7));
            } catch (c7) {
            }
        }
      return null;
    }
    function Sa(a9) {
      switch (typeof a9) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
          return a9;
        default:
          return "";
      }
    }
    function Ta(a9) {
      var b7 = a9.type;
      return (a9 = a9.nodeName) && a9.toLowerCase() === "input" && (b7 === "checkbox" || b7 === "radio");
    }
    function Ua(a9) {
      var b7 = Ta(a9) ? "checked" : "value", c7 = Object.getOwnPropertyDescriptor(a9.constructor.prototype, b7), d8 = "" + a9[b7];
      if (!a9.hasOwnProperty(b7) && typeof c7 !== "undefined" && typeof c7.get === "function" && typeof c7.set === "function") {
        var e12 = c7.get, f11 = c7.set;
        Object.defineProperty(a9, b7, { configurable: true, get: function() {
          return e12.call(this);
        }, set: function(a10) {
          d8 = "" + a10;
          f11.call(this, a10);
        } });
        Object.defineProperty(a9, b7, { enumerable: c7.enumerable });
        return { getValue: function() {
          return d8;
        }, setValue: function(a10) {
          d8 = "" + a10;
        }, stopTracking: function() {
          a9._valueTracker = null;
          delete a9[b7];
        } };
      }
    }
    function Va(a9) {
      a9._valueTracker || (a9._valueTracker = Ua(a9));
    }
    function Wa(a9) {
      if (!a9)
        return false;
      var b7 = a9._valueTracker;
      if (!b7)
        return true;
      var c7 = b7.getValue();
      var d8 = "";
      a9 && (d8 = Ta(a9) ? a9.checked ? "true" : "false" : a9.value);
      a9 = d8;
      return a9 !== c7 ? (b7.setValue(a9), true) : false;
    }
    function Xa(a9) {
      a9 = a9 || (typeof document !== "undefined" ? document : void 0);
      if (typeof a9 === "undefined")
        return null;
      try {
        return a9.activeElement || a9.body;
      } catch (b7) {
        return a9.body;
      }
    }
    function Ya(a9, b7) {
      var c7 = b7.checked;
      return m7({}, b7, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c7 != null ? c7 : a9._wrapperState.initialChecked });
    }
    function Za(a9, b7) {
      var c7 = b7.defaultValue == null ? "" : b7.defaultValue, d8 = b7.checked != null ? b7.checked : b7.defaultChecked;
      c7 = Sa(b7.value != null ? b7.value : c7);
      a9._wrapperState = { initialChecked: d8, initialValue: c7, controlled: b7.type === "checkbox" || b7.type === "radio" ? b7.checked != null : b7.value != null };
    }
    function $a(a9, b7) {
      b7 = b7.checked;
      b7 != null && qa(a9, "checked", b7, false);
    }
    function ab(a9, b7) {
      $a(a9, b7);
      var c7 = Sa(b7.value), d8 = b7.type;
      if (c7 != null)
        if (d8 === "number") {
          if (c7 === 0 && a9.value === "" || a9.value != c7)
            a9.value = "" + c7;
        } else
          a9.value !== "" + c7 && (a9.value = "" + c7);
      else if (d8 === "submit" || d8 === "reset") {
        a9.removeAttribute("value");
        return;
      }
      b7.hasOwnProperty("value") ? bb(a9, b7.type, c7) : b7.hasOwnProperty("defaultValue") && bb(a9, b7.type, Sa(b7.defaultValue));
      b7.checked == null && b7.defaultChecked != null && (a9.defaultChecked = !!b7.defaultChecked);
    }
    function cb(a9, b7, c7) {
      if (b7.hasOwnProperty("value") || b7.hasOwnProperty("defaultValue")) {
        var d8 = b7.type;
        if (!(d8 !== "submit" && d8 !== "reset" || b7.value !== void 0 && b7.value !== null))
          return;
        b7 = "" + a9._wrapperState.initialValue;
        c7 || b7 === a9.value || (a9.value = b7);
        a9.defaultValue = b7;
      }
      c7 = a9.name;
      c7 !== "" && (a9.name = "");
      a9.defaultChecked = !!a9._wrapperState.initialChecked;
      c7 !== "" && (a9.name = c7);
    }
    function bb(a9, b7, c7) {
      if (b7 !== "number" || Xa(a9.ownerDocument) !== a9)
        c7 == null ? a9.defaultValue = "" + a9._wrapperState.initialValue : a9.defaultValue !== "" + c7 && (a9.defaultValue = "" + c7);
    }
    function db(a9) {
      var b7 = "";
      aa.Children.forEach(a9, function(a10) {
        a10 != null && (b7 += a10);
      });
      return b7;
    }
    function eb(a9, b7) {
      a9 = m7({ children: void 0 }, b7);
      if (b7 = db(b7.children))
        a9.children = b7;
      return a9;
    }
    function fb(a9, b7, c7, d8) {
      a9 = a9.options;
      if (b7) {
        b7 = {};
        for (var e12 = 0; e12 < c7.length; e12++)
          b7["$" + c7[e12]] = true;
        for (c7 = 0; c7 < a9.length; c7++)
          e12 = b7.hasOwnProperty("$" + a9[c7].value), a9[c7].selected !== e12 && (a9[c7].selected = e12), e12 && d8 && (a9[c7].defaultSelected = true);
      } else {
        c7 = "" + Sa(c7);
        b7 = null;
        for (e12 = 0; e12 < a9.length; e12++) {
          if (a9[e12].value === c7) {
            a9[e12].selected = true;
            d8 && (a9[e12].defaultSelected = true);
            return;
          }
          b7 !== null || a9[e12].disabled || (b7 = a9[e12]);
        }
        b7 !== null && (b7.selected = true);
      }
    }
    function gb(a9, b7) {
      if (b7.dangerouslySetInnerHTML != null)
        throw Error(y4(91));
      return m7({}, b7, { value: void 0, defaultValue: void 0, children: "" + a9._wrapperState.initialValue });
    }
    function hb(a9, b7) {
      var c7 = b7.value;
      if (c7 == null) {
        c7 = b7.children;
        b7 = b7.defaultValue;
        if (c7 != null) {
          if (b7 != null)
            throw Error(y4(92));
          if (Array.isArray(c7)) {
            if (!(1 >= c7.length))
              throw Error(y4(93));
            c7 = c7[0];
          }
          b7 = c7;
        }
        b7 == null && (b7 = "");
        c7 = b7;
      }
      a9._wrapperState = { initialValue: Sa(c7) };
    }
    function ib(a9, b7) {
      var c7 = Sa(b7.value), d8 = Sa(b7.defaultValue);
      c7 != null && (c7 = "" + c7, c7 !== a9.value && (a9.value = c7), b7.defaultValue == null && a9.defaultValue !== c7 && (a9.defaultValue = c7));
      d8 != null && (a9.defaultValue = "" + d8);
    }
    function jb(a9) {
      var b7 = a9.textContent;
      b7 === a9._wrapperState.initialValue && b7 !== "" && b7 !== null && (a9.value = b7);
    }
    var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
    function lb(a9) {
      switch (a9) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function mb(a9, b7) {
      return a9 == null || a9 === "http://www.w3.org/1999/xhtml" ? lb(b7) : a9 === "http://www.w3.org/2000/svg" && b7 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a9;
    }
    var nb;
    var ob = function(a9) {
      return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b7, c7, d8, e12) {
        MSApp.execUnsafeLocalFunction(function() {
          return a9(b7, c7, d8, e12);
        });
      } : a9;
    }(function(a9, b7) {
      if (a9.namespaceURI !== kb.svg || "innerHTML" in a9)
        a9.innerHTML = b7;
      else {
        nb = nb || document.createElement("div");
        nb.innerHTML = "<svg>" + b7.valueOf().toString() + "</svg>";
        for (b7 = nb.firstChild; a9.firstChild; )
          a9.removeChild(a9.firstChild);
        for (; b7.firstChild; )
          a9.appendChild(b7.firstChild);
      }
    });
    function pb(a9, b7) {
      if (b7) {
        var c7 = a9.firstChild;
        if (c7 && c7 === a9.lastChild && c7.nodeType === 3) {
          c7.nodeValue = b7;
          return;
        }
      }
      a9.textContent = b7;
    }
    var qb = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var rb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(qb).forEach(function(a9) {
      rb.forEach(function(b7) {
        b7 = b7 + a9.charAt(0).toUpperCase() + a9.substring(1);
        qb[b7] = qb[a9];
      });
    });
    function sb(a9, b7, c7) {
      return b7 == null || typeof b7 === "boolean" || b7 === "" ? "" : c7 || typeof b7 !== "number" || b7 === 0 || qb.hasOwnProperty(a9) && qb[a9] ? ("" + b7).trim() : b7 + "px";
    }
    function tb(a9, b7) {
      a9 = a9.style;
      for (var c7 in b7)
        if (b7.hasOwnProperty(c7)) {
          var d8 = c7.indexOf("--") === 0, e12 = sb(c7, b7[c7], d8);
          c7 === "float" && (c7 = "cssFloat");
          d8 ? a9.setProperty(c7, e12) : a9[c7] = e12;
        }
    }
    var ub = m7({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function vb(a9, b7) {
      if (b7) {
        if (ub[a9] && (b7.children != null || b7.dangerouslySetInnerHTML != null))
          throw Error(y4(137, a9));
        if (b7.dangerouslySetInnerHTML != null) {
          if (b7.children != null)
            throw Error(y4(60));
          if (!(typeof b7.dangerouslySetInnerHTML === "object" && "__html" in b7.dangerouslySetInnerHTML))
            throw Error(y4(61));
        }
        if (b7.style != null && typeof b7.style !== "object")
          throw Error(y4(62));
      }
    }
    function wb(a9, b7) {
      if (a9.indexOf("-") === -1)
        return typeof b7.is === "string";
      switch (a9) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    function xb(a9) {
      a9 = a9.target || a9.srcElement || window;
      a9.correspondingUseElement && (a9 = a9.correspondingUseElement);
      return a9.nodeType === 3 ? a9.parentNode : a9;
    }
    var yb = null;
    var zb = null;
    var Ab = null;
    function Bb(a9) {
      if (a9 = Cb(a9)) {
        if (typeof yb !== "function")
          throw Error(y4(280));
        var b7 = a9.stateNode;
        b7 && (b7 = Db(b7), yb(a9.stateNode, a9.type, b7));
      }
    }
    function Eb(a9) {
      zb ? Ab ? Ab.push(a9) : Ab = [a9] : zb = a9;
    }
    function Fb() {
      if (zb) {
        var a9 = zb, b7 = Ab;
        Ab = zb = null;
        Bb(a9);
        if (b7)
          for (a9 = 0; a9 < b7.length; a9++)
            Bb(b7[a9]);
      }
    }
    function Gb(a9, b7) {
      return a9(b7);
    }
    function Hb(a9, b7, c7, d8, e12) {
      return a9(b7, c7, d8, e12);
    }
    function Ib() {
    }
    var Jb = Gb;
    var Kb = false;
    var Lb = false;
    function Mb() {
      if (zb !== null || Ab !== null)
        Ib(), Fb();
    }
    function Nb(a9, b7, c7) {
      if (Lb)
        return a9(b7, c7);
      Lb = true;
      try {
        return Jb(a9, b7, c7);
      } finally {
        Lb = false, Mb();
      }
    }
    function Ob(a9, b7) {
      var c7 = a9.stateNode;
      if (c7 === null)
        return null;
      var d8 = Db(c7);
      if (d8 === null)
        return null;
      c7 = d8[b7];
      a:
        switch (b7) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d8 = !d8.disabled) || (a9 = a9.type, d8 = !(a9 === "button" || a9 === "input" || a9 === "select" || a9 === "textarea"));
            a9 = !d8;
            break a;
          default:
            a9 = false;
        }
      if (a9)
        return null;
      if (c7 && typeof c7 !== "function")
        throw Error(y4(231, b7, typeof c7));
      return c7;
    }
    var Pb = false;
    if (fa)
      try {
        Qb = {};
        Object.defineProperty(Qb, "passive", { get: function() {
          Pb = true;
        } });
        window.addEventListener("test", Qb, Qb);
        window.removeEventListener("test", Qb, Qb);
      } catch (a9) {
        Pb = false;
      }
    var Qb;
    function Rb(a9, b7, c7, d8, e12, f11, g5, h3, k3) {
      var l9 = Array.prototype.slice.call(arguments, 3);
      try {
        b7.apply(c7, l9);
      } catch (n6) {
        this.onError(n6);
      }
    }
    var Sb = false;
    var Tb = null;
    var Ub = false;
    var Vb = null;
    var Wb = { onError: function(a9) {
      Sb = true;
      Tb = a9;
    } };
    function Xb(a9, b7, c7, d8, e12, f11, g5, h3, k3) {
      Sb = false;
      Tb = null;
      Rb.apply(Wb, arguments);
    }
    function Yb(a9, b7, c7, d8, e12, f11, g5, h3, k3) {
      Xb.apply(this, arguments);
      if (Sb) {
        if (Sb) {
          var l9 = Tb;
          Sb = false;
          Tb = null;
        } else
          throw Error(y4(198));
        Ub || (Ub = true, Vb = l9);
      }
    }
    function Zb(a9) {
      var b7 = a9, c7 = a9;
      if (a9.alternate)
        for (; b7.return; )
          b7 = b7.return;
      else {
        a9 = b7;
        do
          b7 = a9, (b7.flags & 1026) !== 0 && (c7 = b7.return), a9 = b7.return;
        while (a9);
      }
      return b7.tag === 3 ? c7 : null;
    }
    function $b(a9) {
      if (a9.tag === 13) {
        var b7 = a9.memoizedState;
        b7 === null && (a9 = a9.alternate, a9 !== null && (b7 = a9.memoizedState));
        if (b7 !== null)
          return b7.dehydrated;
      }
      return null;
    }
    function ac(a9) {
      if (Zb(a9) !== a9)
        throw Error(y4(188));
    }
    function bc(a9) {
      var b7 = a9.alternate;
      if (!b7) {
        b7 = Zb(a9);
        if (b7 === null)
          throw Error(y4(188));
        return b7 !== a9 ? null : a9;
      }
      for (var c7 = a9, d8 = b7; ; ) {
        var e12 = c7.return;
        if (e12 === null)
          break;
        var f11 = e12.alternate;
        if (f11 === null) {
          d8 = e12.return;
          if (d8 !== null) {
            c7 = d8;
            continue;
          }
          break;
        }
        if (e12.child === f11.child) {
          for (f11 = e12.child; f11; ) {
            if (f11 === c7)
              return ac(e12), a9;
            if (f11 === d8)
              return ac(e12), b7;
            f11 = f11.sibling;
          }
          throw Error(y4(188));
        }
        if (c7.return !== d8.return)
          c7 = e12, d8 = f11;
        else {
          for (var g5 = false, h3 = e12.child; h3; ) {
            if (h3 === c7) {
              g5 = true;
              c7 = e12;
              d8 = f11;
              break;
            }
            if (h3 === d8) {
              g5 = true;
              d8 = e12;
              c7 = f11;
              break;
            }
            h3 = h3.sibling;
          }
          if (!g5) {
            for (h3 = f11.child; h3; ) {
              if (h3 === c7) {
                g5 = true;
                c7 = f11;
                d8 = e12;
                break;
              }
              if (h3 === d8) {
                g5 = true;
                d8 = f11;
                c7 = e12;
                break;
              }
              h3 = h3.sibling;
            }
            if (!g5)
              throw Error(y4(189));
          }
        }
        if (c7.alternate !== d8)
          throw Error(y4(190));
      }
      if (c7.tag !== 3)
        throw Error(y4(188));
      return c7.stateNode.current === c7 ? a9 : b7;
    }
    function cc(a9) {
      a9 = bc(a9);
      if (!a9)
        return null;
      for (var b7 = a9; ; ) {
        if (b7.tag === 5 || b7.tag === 6)
          return b7;
        if (b7.child)
          b7.child.return = b7, b7 = b7.child;
        else {
          if (b7 === a9)
            break;
          for (; !b7.sibling; ) {
            if (!b7.return || b7.return === a9)
              return null;
            b7 = b7.return;
          }
          b7.sibling.return = b7.return;
          b7 = b7.sibling;
        }
      }
      return null;
    }
    function dc(a9, b7) {
      for (var c7 = a9.alternate; b7 !== null; ) {
        if (b7 === a9 || b7 === c7)
          return true;
        b7 = b7.return;
      }
      return false;
    }
    var ec;
    var fc;
    var gc;
    var hc;
    var ic = false;
    var jc = [];
    var kc = null;
    var lc = null;
    var mc = null;
    var nc = new Map();
    var oc = new Map();
    var pc = [];
    var qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function rc(a9, b7, c7, d8, e12) {
      return { blockedOn: a9, domEventName: b7, eventSystemFlags: c7 | 16, nativeEvent: e12, targetContainers: [d8] };
    }
    function sc(a9, b7) {
      switch (a9) {
        case "focusin":
        case "focusout":
          kc = null;
          break;
        case "dragenter":
        case "dragleave":
          lc = null;
          break;
        case "mouseover":
        case "mouseout":
          mc = null;
          break;
        case "pointerover":
        case "pointerout":
          nc.delete(b7.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          oc.delete(b7.pointerId);
      }
    }
    function tc(a9, b7, c7, d8, e12, f11) {
      if (a9 === null || a9.nativeEvent !== f11)
        return a9 = rc(b7, c7, d8, e12, f11), b7 !== null && (b7 = Cb(b7), b7 !== null && fc(b7)), a9;
      a9.eventSystemFlags |= d8;
      b7 = a9.targetContainers;
      e12 !== null && b7.indexOf(e12) === -1 && b7.push(e12);
      return a9;
    }
    function uc(a9, b7, c7, d8, e12) {
      switch (b7) {
        case "focusin":
          return kc = tc(kc, a9, b7, c7, d8, e12), true;
        case "dragenter":
          return lc = tc(lc, a9, b7, c7, d8, e12), true;
        case "mouseover":
          return mc = tc(mc, a9, b7, c7, d8, e12), true;
        case "pointerover":
          var f11 = e12.pointerId;
          nc.set(f11, tc(nc.get(f11) || null, a9, b7, c7, d8, e12));
          return true;
        case "gotpointercapture":
          return f11 = e12.pointerId, oc.set(f11, tc(oc.get(f11) || null, a9, b7, c7, d8, e12)), true;
      }
      return false;
    }
    function vc(a9) {
      var b7 = wc(a9.target);
      if (b7 !== null) {
        var c7 = Zb(b7);
        if (c7 !== null) {
          if (b7 = c7.tag, b7 === 13) {
            if (b7 = $b(c7), b7 !== null) {
              a9.blockedOn = b7;
              hc(a9.lanePriority, function() {
                r13.unstable_runWithPriority(a9.priority, function() {
                  gc(c7);
                });
              });
              return;
            }
          } else if (b7 === 3 && c7.stateNode.hydrate) {
            a9.blockedOn = c7.tag === 3 ? c7.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a9.blockedOn = null;
    }
    function xc(a9) {
      if (a9.blockedOn !== null)
        return false;
      for (var b7 = a9.targetContainers; 0 < b7.length; ) {
        var c7 = yc(a9.domEventName, a9.eventSystemFlags, b7[0], a9.nativeEvent);
        if (c7 !== null)
          return b7 = Cb(c7), b7 !== null && fc(b7), a9.blockedOn = c7, false;
        b7.shift();
      }
      return true;
    }
    function zc(a9, b7, c7) {
      xc(a9) && c7.delete(b7);
    }
    function Ac() {
      for (ic = false; 0 < jc.length; ) {
        var a9 = jc[0];
        if (a9.blockedOn !== null) {
          a9 = Cb(a9.blockedOn);
          a9 !== null && ec(a9);
          break;
        }
        for (var b7 = a9.targetContainers; 0 < b7.length; ) {
          var c7 = yc(a9.domEventName, a9.eventSystemFlags, b7[0], a9.nativeEvent);
          if (c7 !== null) {
            a9.blockedOn = c7;
            break;
          }
          b7.shift();
        }
        a9.blockedOn === null && jc.shift();
      }
      kc !== null && xc(kc) && (kc = null);
      lc !== null && xc(lc) && (lc = null);
      mc !== null && xc(mc) && (mc = null);
      nc.forEach(zc);
      oc.forEach(zc);
    }
    function Bc(a9, b7) {
      a9.blockedOn === b7 && (a9.blockedOn = null, ic || (ic = true, r13.unstable_scheduleCallback(r13.unstable_NormalPriority, Ac)));
    }
    function Cc(a9) {
      function b7(b8) {
        return Bc(b8, a9);
      }
      if (0 < jc.length) {
        Bc(jc[0], a9);
        for (var c7 = 1; c7 < jc.length; c7++) {
          var d8 = jc[c7];
          d8.blockedOn === a9 && (d8.blockedOn = null);
        }
      }
      kc !== null && Bc(kc, a9);
      lc !== null && Bc(lc, a9);
      mc !== null && Bc(mc, a9);
      nc.forEach(b7);
      oc.forEach(b7);
      for (c7 = 0; c7 < pc.length; c7++)
        d8 = pc[c7], d8.blockedOn === a9 && (d8.blockedOn = null);
      for (; 0 < pc.length && (c7 = pc[0], c7.blockedOn === null); )
        vc(c7), c7.blockedOn === null && pc.shift();
    }
    function Dc(a9, b7) {
      var c7 = {};
      c7[a9.toLowerCase()] = b7.toLowerCase();
      c7["Webkit" + a9] = "webkit" + b7;
      c7["Moz" + a9] = "moz" + b7;
      return c7;
    }
    var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") };
    var Fc = {};
    var Gc = {};
    fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
    function Hc(a9) {
      if (Fc[a9])
        return Fc[a9];
      if (!Ec[a9])
        return a9;
      var b7 = Ec[a9], c7;
      for (c7 in b7)
        if (b7.hasOwnProperty(c7) && c7 in Gc)
          return Fc[a9] = b7[c7];
      return a9;
    }
    var Ic = Hc("animationend");
    var Jc = Hc("animationiteration");
    var Kc = Hc("animationstart");
    var Lc = Hc("transitionend");
    var Mc = new Map();
    var Nc = new Map();
    var Oc = [
      "abort",
      "abort",
      Ic,
      "animationEnd",
      Jc,
      "animationIteration",
      Kc,
      "animationStart",
      "canplay",
      "canPlay",
      "canplaythrough",
      "canPlayThrough",
      "durationchange",
      "durationChange",
      "emptied",
      "emptied",
      "encrypted",
      "encrypted",
      "ended",
      "ended",
      "error",
      "error",
      "gotpointercapture",
      "gotPointerCapture",
      "load",
      "load",
      "loadeddata",
      "loadedData",
      "loadedmetadata",
      "loadedMetadata",
      "loadstart",
      "loadStart",
      "lostpointercapture",
      "lostPointerCapture",
      "playing",
      "playing",
      "progress",
      "progress",
      "seeking",
      "seeking",
      "stalled",
      "stalled",
      "suspend",
      "suspend",
      "timeupdate",
      "timeUpdate",
      Lc,
      "transitionEnd",
      "waiting",
      "waiting"
    ];
    function Pc(a9, b7) {
      for (var c7 = 0; c7 < a9.length; c7 += 2) {
        var d8 = a9[c7], e12 = a9[c7 + 1];
        e12 = "on" + (e12[0].toUpperCase() + e12.slice(1));
        Nc.set(d8, b7);
        Mc.set(d8, e12);
        da(e12, [d8]);
      }
    }
    var Qc = r13.unstable_now;
    Qc();
    var F5 = 8;
    function Rc(a9) {
      if ((1 & a9) !== 0)
        return F5 = 15, 1;
      if ((2 & a9) !== 0)
        return F5 = 14, 2;
      if ((4 & a9) !== 0)
        return F5 = 13, 4;
      var b7 = 24 & a9;
      if (b7 !== 0)
        return F5 = 12, b7;
      if ((a9 & 32) !== 0)
        return F5 = 11, 32;
      b7 = 192 & a9;
      if (b7 !== 0)
        return F5 = 10, b7;
      if ((a9 & 256) !== 0)
        return F5 = 9, 256;
      b7 = 3584 & a9;
      if (b7 !== 0)
        return F5 = 8, b7;
      if ((a9 & 4096) !== 0)
        return F5 = 7, 4096;
      b7 = 4186112 & a9;
      if (b7 !== 0)
        return F5 = 6, b7;
      b7 = 62914560 & a9;
      if (b7 !== 0)
        return F5 = 5, b7;
      if (a9 & 67108864)
        return F5 = 4, 67108864;
      if ((a9 & 134217728) !== 0)
        return F5 = 3, 134217728;
      b7 = 805306368 & a9;
      if (b7 !== 0)
        return F5 = 2, b7;
      if ((1073741824 & a9) !== 0)
        return F5 = 1, 1073741824;
      F5 = 8;
      return a9;
    }
    function Sc(a9) {
      switch (a9) {
        case 99:
          return 15;
        case 98:
          return 10;
        case 97:
        case 96:
          return 8;
        case 95:
          return 2;
        default:
          return 0;
      }
    }
    function Tc(a9) {
      switch (a9) {
        case 15:
        case 14:
          return 99;
        case 13:
        case 12:
        case 11:
        case 10:
          return 98;
        case 9:
        case 8:
        case 7:
        case 6:
        case 4:
        case 5:
          return 97;
        case 3:
        case 2:
        case 1:
          return 95;
        case 0:
          return 90;
        default:
          throw Error(y4(358, a9));
      }
    }
    function Uc(a9, b7) {
      var c7 = a9.pendingLanes;
      if (c7 === 0)
        return F5 = 0;
      var d8 = 0, e12 = 0, f11 = a9.expiredLanes, g5 = a9.suspendedLanes, h3 = a9.pingedLanes;
      if (f11 !== 0)
        d8 = f11, e12 = F5 = 15;
      else if (f11 = c7 & 134217727, f11 !== 0) {
        var k3 = f11 & ~g5;
        k3 !== 0 ? (d8 = Rc(k3), e12 = F5) : (h3 &= f11, h3 !== 0 && (d8 = Rc(h3), e12 = F5));
      } else
        f11 = c7 & ~g5, f11 !== 0 ? (d8 = Rc(f11), e12 = F5) : h3 !== 0 && (d8 = Rc(h3), e12 = F5);
      if (d8 === 0)
        return 0;
      d8 = 31 - Vc(d8);
      d8 = c7 & ((0 > d8 ? 0 : 1 << d8) << 1) - 1;
      if (b7 !== 0 && b7 !== d8 && (b7 & g5) === 0) {
        Rc(b7);
        if (e12 <= F5)
          return b7;
        F5 = e12;
      }
      b7 = a9.entangledLanes;
      if (b7 !== 0)
        for (a9 = a9.entanglements, b7 &= d8; 0 < b7; )
          c7 = 31 - Vc(b7), e12 = 1 << c7, d8 |= a9[c7], b7 &= ~e12;
      return d8;
    }
    function Wc(a9) {
      a9 = a9.pendingLanes & -1073741825;
      return a9 !== 0 ? a9 : a9 & 1073741824 ? 1073741824 : 0;
    }
    function Xc(a9, b7) {
      switch (a9) {
        case 15:
          return 1;
        case 14:
          return 2;
        case 12:
          return a9 = Yc(24 & ~b7), a9 === 0 ? Xc(10, b7) : a9;
        case 10:
          return a9 = Yc(192 & ~b7), a9 === 0 ? Xc(8, b7) : a9;
        case 8:
          return a9 = Yc(3584 & ~b7), a9 === 0 && (a9 = Yc(4186112 & ~b7), a9 === 0 && (a9 = 512)), a9;
        case 2:
          return b7 = Yc(805306368 & ~b7), b7 === 0 && (b7 = 268435456), b7;
      }
      throw Error(y4(358, a9));
    }
    function Yc(a9) {
      return a9 & -a9;
    }
    function Zc(a9) {
      for (var b7 = [], c7 = 0; 31 > c7; c7++)
        b7.push(a9);
      return b7;
    }
    function $c(a9, b7, c7) {
      a9.pendingLanes |= b7;
      var d8 = b7 - 1;
      a9.suspendedLanes &= d8;
      a9.pingedLanes &= d8;
      a9 = a9.eventTimes;
      b7 = 31 - Vc(b7);
      a9[b7] = c7;
    }
    var Vc = Math.clz32 ? Math.clz32 : ad;
    var bd = Math.log;
    var cd = Math.LN2;
    function ad(a9) {
      return a9 === 0 ? 32 : 31 - (bd(a9) / cd | 0) | 0;
    }
    var dd = r13.unstable_UserBlockingPriority;
    var ed = r13.unstable_runWithPriority;
    var fd = true;
    function gd(a9, b7, c7, d8) {
      Kb || Ib();
      var e12 = hd, f11 = Kb;
      Kb = true;
      try {
        Hb(e12, a9, b7, c7, d8);
      } finally {
        (Kb = f11) || Mb();
      }
    }
    function id(a9, b7, c7, d8) {
      ed(dd, hd.bind(null, a9, b7, c7, d8));
    }
    function hd(a9, b7, c7, d8) {
      if (fd) {
        var e12;
        if ((e12 = (b7 & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a9))
          a9 = rc(null, a9, b7, c7, d8), jc.push(a9);
        else {
          var f11 = yc(a9, b7, c7, d8);
          if (f11 === null)
            e12 && sc(a9, d8);
          else {
            if (e12) {
              if (-1 < qc.indexOf(a9)) {
                a9 = rc(f11, a9, b7, c7, d8);
                jc.push(a9);
                return;
              }
              if (uc(f11, a9, b7, c7, d8))
                return;
              sc(a9, d8);
            }
            jd(a9, b7, d8, null, c7);
          }
        }
      }
    }
    function yc(a9, b7, c7, d8) {
      var e12 = xb(d8);
      e12 = wc(e12);
      if (e12 !== null) {
        var f11 = Zb(e12);
        if (f11 === null)
          e12 = null;
        else {
          var g5 = f11.tag;
          if (g5 === 13) {
            e12 = $b(f11);
            if (e12 !== null)
              return e12;
            e12 = null;
          } else if (g5 === 3) {
            if (f11.stateNode.hydrate)
              return f11.tag === 3 ? f11.stateNode.containerInfo : null;
            e12 = null;
          } else
            f11 !== e12 && (e12 = null);
        }
      }
      jd(a9, b7, d8, e12, c7);
      return null;
    }
    var kd = null;
    var ld = null;
    var md = null;
    function nd() {
      if (md)
        return md;
      var a9, b7 = ld, c7 = b7.length, d8, e12 = "value" in kd ? kd.value : kd.textContent, f11 = e12.length;
      for (a9 = 0; a9 < c7 && b7[a9] === e12[a9]; a9++)
        ;
      var g5 = c7 - a9;
      for (d8 = 1; d8 <= g5 && b7[c7 - d8] === e12[f11 - d8]; d8++)
        ;
      return md = e12.slice(a9, 1 < d8 ? 1 - d8 : void 0);
    }
    function od(a9) {
      var b7 = a9.keyCode;
      "charCode" in a9 ? (a9 = a9.charCode, a9 === 0 && b7 === 13 && (a9 = 13)) : a9 = b7;
      a9 === 10 && (a9 = 13);
      return 32 <= a9 || a9 === 13 ? a9 : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a9) {
      function b7(b8, d8, e12, f11, g5) {
        this._reactName = b8;
        this._targetInst = e12;
        this.type = d8;
        this.nativeEvent = f11;
        this.target = g5;
        this.currentTarget = null;
        for (var c7 in a9)
          a9.hasOwnProperty(c7) && (b8 = a9[c7], this[c7] = b8 ? b8(f11) : f11[c7]);
        this.isDefaultPrevented = (f11.defaultPrevented != null ? f11.defaultPrevented : f11.returnValue === false) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      m7(b7.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a10 = this.nativeEvent;
        a10 && (a10.preventDefault ? a10.preventDefault() : typeof a10.returnValue !== "unknown" && (a10.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a10 = this.nativeEvent;
        a10 && (a10.stopPropagation ? a10.stopPropagation() : typeof a10.cancelBubble !== "unknown" && (a10.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b7;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a9) {
      return a9.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 };
    var td = rd(sd);
    var ud = m7({}, sd, { view: 0, detail: 0 });
    var vd = rd(ud);
    var wd;
    var xd;
    var yd;
    var Ad = m7({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a9) {
      return a9.relatedTarget === void 0 ? a9.fromElement === a9.srcElement ? a9.toElement : a9.fromElement : a9.relatedTarget;
    }, movementX: function(a9) {
      if ("movementX" in a9)
        return a9.movementX;
      a9 !== yd && (yd && a9.type === "mousemove" ? (wd = a9.screenX - yd.screenX, xd = a9.screenY - yd.screenY) : xd = wd = 0, yd = a9);
      return wd;
    }, movementY: function(a9) {
      return "movementY" in a9 ? a9.movementY : xd;
    } });
    var Bd = rd(Ad);
    var Cd = m7({}, Ad, { dataTransfer: 0 });
    var Dd = rd(Cd);
    var Ed = m7({}, ud, { relatedTarget: 0 });
    var Fd = rd(Ed);
    var Gd = m7({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Hd = rd(Gd);
    var Id = m7({}, sd, { clipboardData: function(a9) {
      return "clipboardData" in a9 ? a9.clipboardData : window.clipboardData;
    } });
    var Jd = rd(Id);
    var Kd = m7({}, sd, { data: 0 });
    var Ld = rd(Kd);
    var Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a9) {
      var b7 = this.nativeEvent;
      return b7.getModifierState ? b7.getModifierState(a9) : (a9 = Od[a9]) ? !!b7[a9] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = m7({}, ud, { key: function(a9) {
      if (a9.key) {
        var b7 = Md[a9.key] || a9.key;
        if (b7 !== "Unidentified")
          return b7;
      }
      return a9.type === "keypress" ? (a9 = od(a9), a9 === 13 ? "Enter" : String.fromCharCode(a9)) : a9.type === "keydown" || a9.type === "keyup" ? Nd[a9.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a9) {
      return a9.type === "keypress" ? od(a9) : 0;
    }, keyCode: function(a9) {
      return a9.type === "keydown" || a9.type === "keyup" ? a9.keyCode : 0;
    }, which: function(a9) {
      return a9.type === "keypress" ? od(a9) : a9.type === "keydown" || a9.type === "keyup" ? a9.keyCode : 0;
    } });
    var Rd = rd(Qd);
    var Sd = m7({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
    var Td = rd(Sd);
    var Ud = m7({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
    var Vd = rd(Ud);
    var Wd = m7({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Xd = rd(Wd);
    var Yd = m7({}, Ad, {
      deltaX: function(a9) {
        return "deltaX" in a9 ? a9.deltaX : "wheelDeltaX" in a9 ? -a9.wheelDeltaX : 0;
      },
      deltaY: function(a9) {
        return "deltaY" in a9 ? a9.deltaY : "wheelDeltaY" in a9 ? -a9.wheelDeltaY : "wheelDelta" in a9 ? -a9.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    });
    var Zd = rd(Yd);
    var $d = [9, 13, 27, 32];
    var ae = fa && "CompositionEvent" in window;
    var be2 = null;
    fa && "documentMode" in document && (be2 = document.documentMode);
    var ce2 = fa && "TextEvent" in window && !be2;
    var de = fa && (!ae || be2 && 8 < be2 && 11 >= be2);
    var ee = String.fromCharCode(32);
    var fe2 = false;
    function ge2(a9, b7) {
      switch (a9) {
        case "keyup":
          return $d.indexOf(b7.keyCode) !== -1;
        case "keydown":
          return b7.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a9) {
      a9 = a9.detail;
      return typeof a9 === "object" && "data" in a9 ? a9.data : null;
    }
    var ie2 = false;
    function je(a9, b7) {
      switch (a9) {
        case "compositionend":
          return he(b7);
        case "keypress":
          if (b7.which !== 32)
            return null;
          fe2 = true;
          return ee;
        case "textInput":
          return a9 = b7.data, a9 === ee && fe2 ? null : a9;
        default:
          return null;
      }
    }
    function ke(a9, b7) {
      if (ie2)
        return a9 === "compositionend" || !ae && ge2(a9, b7) ? (a9 = nd(), md = ld = kd = null, ie2 = false, a9) : null;
      switch (a9) {
        case "paste":
          return null;
        case "keypress":
          if (!(b7.ctrlKey || b7.altKey || b7.metaKey) || b7.ctrlKey && b7.altKey) {
            if (b7.char && 1 < b7.char.length)
              return b7.char;
            if (b7.which)
              return String.fromCharCode(b7.which);
          }
          return null;
        case "compositionend":
          return de && b7.locale !== "ko" ? null : b7.data;
        default:
          return null;
      }
    }
    var le2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me2(a9) {
      var b7 = a9 && a9.nodeName && a9.nodeName.toLowerCase();
      return b7 === "input" ? !!le2[a9.type] : b7 === "textarea" ? true : false;
    }
    function ne2(a9, b7, c7, d8) {
      Eb(d8);
      b7 = oe2(b7, "onChange");
      0 < b7.length && (c7 = new td("onChange", "change", null, c7, d8), a9.push({ event: c7, listeners: b7 }));
    }
    var pe = null;
    var qe = null;
    function re2(a9) {
      se2(a9, 0);
    }
    function te(a9) {
      var b7 = ue2(a9);
      if (Wa(b7))
        return a9;
    }
    function ve(a9, b7) {
      if (a9 === "change")
        return b7;
    }
    var we = false;
    if (fa) {
      if (fa) {
        ye = "oninput" in document;
        if (!ye) {
          ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = typeof ze.oninput === "function";
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    var xe;
    var ye;
    var ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a9) {
      if (a9.propertyName === "value" && te(qe)) {
        var b7 = [];
        ne2(b7, qe, a9, xb(a9));
        a9 = re2;
        if (Kb)
          a9(b7);
        else {
          Kb = true;
          try {
            Gb(a9, b7);
          } finally {
            Kb = false, Mb();
          }
        }
      }
    }
    function Ce(a9, b7, c7) {
      a9 === "focusin" ? (Ae(), pe = b7, qe = c7, pe.attachEvent("onpropertychange", Be)) : a9 === "focusout" && Ae();
    }
    function De(a9) {
      if (a9 === "selectionchange" || a9 === "keyup" || a9 === "keydown")
        return te(qe);
    }
    function Ee(a9, b7) {
      if (a9 === "click")
        return te(b7);
    }
    function Fe(a9, b7) {
      if (a9 === "input" || a9 === "change")
        return te(b7);
    }
    function Ge(a9, b7) {
      return a9 === b7 && (a9 !== 0 || 1 / a9 === 1 / b7) || a9 !== a9 && b7 !== b7;
    }
    var He = typeof Object.is === "function" ? Object.is : Ge;
    var Ie = Object.prototype.hasOwnProperty;
    function Je(a9, b7) {
      if (He(a9, b7))
        return true;
      if (typeof a9 !== "object" || a9 === null || typeof b7 !== "object" || b7 === null)
        return false;
      var c7 = Object.keys(a9), d8 = Object.keys(b7);
      if (c7.length !== d8.length)
        return false;
      for (d8 = 0; d8 < c7.length; d8++)
        if (!Ie.call(b7, c7[d8]) || !He(a9[c7[d8]], b7[c7[d8]]))
          return false;
      return true;
    }
    function Ke(a9) {
      for (; a9 && a9.firstChild; )
        a9 = a9.firstChild;
      return a9;
    }
    function Le(a9, b7) {
      var c7 = Ke(a9);
      a9 = 0;
      for (var d8; c7; ) {
        if (c7.nodeType === 3) {
          d8 = a9 + c7.textContent.length;
          if (a9 <= b7 && d8 >= b7)
            return { node: c7, offset: b7 - a9 };
          a9 = d8;
        }
        a: {
          for (; c7; ) {
            if (c7.nextSibling) {
              c7 = c7.nextSibling;
              break a;
            }
            c7 = c7.parentNode;
          }
          c7 = void 0;
        }
        c7 = Ke(c7);
      }
    }
    function Me(a9, b7) {
      return a9 && b7 ? a9 === b7 ? true : a9 && a9.nodeType === 3 ? false : b7 && b7.nodeType === 3 ? Me(a9, b7.parentNode) : "contains" in a9 ? a9.contains(b7) : a9.compareDocumentPosition ? !!(a9.compareDocumentPosition(b7) & 16) : false : false;
    }
    function Ne() {
      for (var a9 = window, b7 = Xa(); b7 instanceof a9.HTMLIFrameElement; ) {
        try {
          var c7 = typeof b7.contentWindow.location.href === "string";
        } catch (d8) {
          c7 = false;
        }
        if (c7)
          a9 = b7.contentWindow;
        else
          break;
        b7 = Xa(a9.document);
      }
      return b7;
    }
    function Oe(a9) {
      var b7 = a9 && a9.nodeName && a9.nodeName.toLowerCase();
      return b7 && (b7 === "input" && (a9.type === "text" || a9.type === "search" || a9.type === "tel" || a9.type === "url" || a9.type === "password") || b7 === "textarea" || a9.contentEditable === "true");
    }
    var Pe = fa && "documentMode" in document && 11 >= document.documentMode;
    var Qe = null;
    var Re = null;
    var Se = null;
    var Te2 = false;
    function Ue(a9, b7, c7) {
      var d8 = c7.window === c7 ? c7.document : c7.nodeType === 9 ? c7 : c7.ownerDocument;
      Te2 || Qe == null || Qe !== Xa(d8) || (d8 = Qe, "selectionStart" in d8 && Oe(d8) ? d8 = { start: d8.selectionStart, end: d8.selectionEnd } : (d8 = (d8.ownerDocument && d8.ownerDocument.defaultView || window).getSelection(), d8 = { anchorNode: d8.anchorNode, anchorOffset: d8.anchorOffset, focusNode: d8.focusNode, focusOffset: d8.focusOffset }), Se && Je(Se, d8) || (Se = d8, d8 = oe2(Re, "onSelect"), 0 < d8.length && (b7 = new td("onSelect", "select", null, b7, c7), a9.push({ event: b7, listeners: d8 }), b7.target = Qe)));
    }
    Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
    Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
    Pc(Oc, 2);
    for (Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
      Nc.set(Ve[We], 0);
    var Ve;
    var We;
    ea("onMouseEnter", ["mouseout", "mouseover"]);
    ea("onMouseLeave", ["mouseout", "mouseover"]);
    ea("onPointerEnter", ["pointerout", "pointerover"]);
    ea("onPointerLeave", ["pointerout", "pointerover"]);
    da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
    var Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
    function Ze(a9, b7, c7) {
      var d8 = a9.type || "unknown-event";
      a9.currentTarget = c7;
      Yb(d8, b7, void 0, a9);
      a9.currentTarget = null;
    }
    function se2(a9, b7) {
      b7 = (b7 & 4) !== 0;
      for (var c7 = 0; c7 < a9.length; c7++) {
        var d8 = a9[c7], e12 = d8.event;
        d8 = d8.listeners;
        a: {
          var f11 = void 0;
          if (b7)
            for (var g5 = d8.length - 1; 0 <= g5; g5--) {
              var h3 = d8[g5], k3 = h3.instance, l9 = h3.currentTarget;
              h3 = h3.listener;
              if (k3 !== f11 && e12.isPropagationStopped())
                break a;
              Ze(e12, h3, l9);
              f11 = k3;
            }
          else
            for (g5 = 0; g5 < d8.length; g5++) {
              h3 = d8[g5];
              k3 = h3.instance;
              l9 = h3.currentTarget;
              h3 = h3.listener;
              if (k3 !== f11 && e12.isPropagationStopped())
                break a;
              Ze(e12, h3, l9);
              f11 = k3;
            }
        }
      }
      if (Ub)
        throw a9 = Vb, Ub = false, Vb = null, a9;
    }
    function G4(a9, b7) {
      var c7 = $e(b7), d8 = a9 + "__bubble";
      c7.has(d8) || (af(b7, a9, 2, false), c7.add(d8));
    }
    var bf = "_reactListening" + Math.random().toString(36).slice(2);
    function cf(a9) {
      a9[bf] || (a9[bf] = true, ba.forEach(function(b7) {
        Ye.has(b7) || df(b7, false, a9, null);
        df(b7, true, a9, null);
      }));
    }
    function df(a9, b7, c7, d8) {
      var e12 = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f11 = c7;
      a9 === "selectionchange" && c7.nodeType !== 9 && (f11 = c7.ownerDocument);
      if (d8 !== null && !b7 && Ye.has(a9)) {
        if (a9 !== "scroll")
          return;
        e12 |= 2;
        f11 = d8;
      }
      var g5 = $e(f11), h3 = a9 + "__" + (b7 ? "capture" : "bubble");
      g5.has(h3) || (b7 && (e12 |= 4), af(f11, a9, e12, b7), g5.add(h3));
    }
    function af(a9, b7, c7, d8) {
      var e12 = Nc.get(b7);
      switch (e12 === void 0 ? 2 : e12) {
        case 0:
          e12 = gd;
          break;
        case 1:
          e12 = id;
          break;
        default:
          e12 = hd;
      }
      c7 = e12.bind(null, b7, c7, a9);
      e12 = void 0;
      !Pb || b7 !== "touchstart" && b7 !== "touchmove" && b7 !== "wheel" || (e12 = true);
      d8 ? e12 !== void 0 ? a9.addEventListener(b7, c7, { capture: true, passive: e12 }) : a9.addEventListener(b7, c7, true) : e12 !== void 0 ? a9.addEventListener(b7, c7, { passive: e12 }) : a9.addEventListener(b7, c7, false);
    }
    function jd(a9, b7, c7, d8, e12) {
      var f11 = d8;
      if ((b7 & 1) === 0 && (b7 & 2) === 0 && d8 !== null)
        a:
          for (; ; ) {
            if (d8 === null)
              return;
            var g5 = d8.tag;
            if (g5 === 3 || g5 === 4) {
              var h3 = d8.stateNode.containerInfo;
              if (h3 === e12 || h3.nodeType === 8 && h3.parentNode === e12)
                break;
              if (g5 === 4)
                for (g5 = d8.return; g5 !== null; ) {
                  var k3 = g5.tag;
                  if (k3 === 3 || k3 === 4) {
                    if (k3 = g5.stateNode.containerInfo, k3 === e12 || k3.nodeType === 8 && k3.parentNode === e12)
                      return;
                  }
                  g5 = g5.return;
                }
              for (; h3 !== null; ) {
                g5 = wc(h3);
                if (g5 === null)
                  return;
                k3 = g5.tag;
                if (k3 === 5 || k3 === 6) {
                  d8 = f11 = g5;
                  continue a;
                }
                h3 = h3.parentNode;
              }
            }
            d8 = d8.return;
          }
      Nb(function() {
        var d9 = f11, e13 = xb(c7), g6 = [];
        a: {
          var h4 = Mc.get(a9);
          if (h4 !== void 0) {
            var k4 = td, x5 = a9;
            switch (a9) {
              case "keypress":
                if (od(c7) === 0)
                  break a;
              case "keydown":
              case "keyup":
                k4 = Rd;
                break;
              case "focusin":
                x5 = "focus";
                k4 = Fd;
                break;
              case "focusout":
                x5 = "blur";
                k4 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k4 = Fd;
                break;
              case "click":
                if (c7.button === 2)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k4 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k4 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k4 = Vd;
                break;
              case Ic:
              case Jc:
              case Kc:
                k4 = Hd;
                break;
              case Lc:
                k4 = Xd;
                break;
              case "scroll":
                k4 = vd;
                break;
              case "wheel":
                k4 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k4 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k4 = Td;
            }
            var w6 = (b7 & 4) !== 0, z3 = !w6 && a9 === "scroll", u4 = w6 ? h4 !== null ? h4 + "Capture" : null : h4;
            w6 = [];
            for (var t14 = d9, q3; t14 !== null; ) {
              q3 = t14;
              var v6 = q3.stateNode;
              q3.tag === 5 && v6 !== null && (q3 = v6, u4 !== null && (v6 = Ob(t14, u4), v6 != null && w6.push(ef(t14, v6, q3))));
              if (z3)
                break;
              t14 = t14.return;
            }
            0 < w6.length && (h4 = new k4(h4, x5, null, c7, e13), g6.push({ event: h4, listeners: w6 }));
          }
        }
        if ((b7 & 7) === 0) {
          a: {
            h4 = a9 === "mouseover" || a9 === "pointerover";
            k4 = a9 === "mouseout" || a9 === "pointerout";
            if (h4 && (b7 & 16) === 0 && (x5 = c7.relatedTarget || c7.fromElement) && (wc(x5) || x5[ff]))
              break a;
            if (k4 || h4) {
              h4 = e13.window === e13 ? e13 : (h4 = e13.ownerDocument) ? h4.defaultView || h4.parentWindow : window;
              if (k4) {
                if (x5 = c7.relatedTarget || c7.toElement, k4 = d9, x5 = x5 ? wc(x5) : null, x5 !== null && (z3 = Zb(x5), x5 !== z3 || x5.tag !== 5 && x5.tag !== 6))
                  x5 = null;
              } else
                k4 = null, x5 = d9;
              if (k4 !== x5) {
                w6 = Bd;
                v6 = "onMouseLeave";
                u4 = "onMouseEnter";
                t14 = "mouse";
                if (a9 === "pointerout" || a9 === "pointerover")
                  w6 = Td, v6 = "onPointerLeave", u4 = "onPointerEnter", t14 = "pointer";
                z3 = k4 == null ? h4 : ue2(k4);
                q3 = x5 == null ? h4 : ue2(x5);
                h4 = new w6(v6, t14 + "leave", k4, c7, e13);
                h4.target = z3;
                h4.relatedTarget = q3;
                v6 = null;
                wc(e13) === d9 && (w6 = new w6(u4, t14 + "enter", x5, c7, e13), w6.target = q3, w6.relatedTarget = z3, v6 = w6);
                z3 = v6;
                if (k4 && x5)
                  b: {
                    w6 = k4;
                    u4 = x5;
                    t14 = 0;
                    for (q3 = w6; q3; q3 = gf(q3))
                      t14++;
                    q3 = 0;
                    for (v6 = u4; v6; v6 = gf(v6))
                      q3++;
                    for (; 0 < t14 - q3; )
                      w6 = gf(w6), t14--;
                    for (; 0 < q3 - t14; )
                      u4 = gf(u4), q3--;
                    for (; t14--; ) {
                      if (w6 === u4 || u4 !== null && w6 === u4.alternate)
                        break b;
                      w6 = gf(w6);
                      u4 = gf(u4);
                    }
                    w6 = null;
                  }
                else
                  w6 = null;
                k4 !== null && hf(g6, h4, k4, w6, false);
                x5 !== null && z3 !== null && hf(g6, z3, x5, w6, true);
              }
            }
          }
          a: {
            h4 = d9 ? ue2(d9) : window;
            k4 = h4.nodeName && h4.nodeName.toLowerCase();
            if (k4 === "select" || k4 === "input" && h4.type === "file")
              var J3 = ve;
            else if (me2(h4))
              if (we)
                J3 = Fe;
              else {
                J3 = De;
                var K2 = Ce;
              }
            else
              (k4 = h4.nodeName) && k4.toLowerCase() === "input" && (h4.type === "checkbox" || h4.type === "radio") && (J3 = Ee);
            if (J3 && (J3 = J3(a9, d9))) {
              ne2(g6, J3, c7, e13);
              break a;
            }
            K2 && K2(a9, h4, d9);
            a9 === "focusout" && (K2 = h4._wrapperState) && K2.controlled && h4.type === "number" && bb(h4, "number", h4.value);
          }
          K2 = d9 ? ue2(d9) : window;
          switch (a9) {
            case "focusin":
              if (me2(K2) || K2.contentEditable === "true")
                Qe = K2, Re = d9, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te2 = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te2 = false;
              Ue(g6, c7, e13);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g6, c7, e13);
          }
          var Q;
          if (ae)
            b: {
              switch (a9) {
                case "compositionstart":
                  var L4 = "onCompositionStart";
                  break b;
                case "compositionend":
                  L4 = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  L4 = "onCompositionUpdate";
                  break b;
              }
              L4 = void 0;
            }
          else
            ie2 ? ge2(a9, c7) && (L4 = "onCompositionEnd") : a9 === "keydown" && c7.keyCode === 229 && (L4 = "onCompositionStart");
          L4 && (de && c7.locale !== "ko" && (ie2 || L4 !== "onCompositionStart" ? L4 === "onCompositionEnd" && ie2 && (Q = nd()) : (kd = e13, ld = "value" in kd ? kd.value : kd.textContent, ie2 = true)), K2 = oe2(d9, L4), 0 < K2.length && (L4 = new Ld(L4, a9, null, c7, e13), g6.push({ event: L4, listeners: K2 }), Q ? L4.data = Q : (Q = he(c7), Q !== null && (L4.data = Q))));
          if (Q = ce2 ? je(a9, c7) : ke(a9, c7))
            d9 = oe2(d9, "onBeforeInput"), 0 < d9.length && (e13 = new Ld("onBeforeInput", "beforeinput", null, c7, e13), g6.push({ event: e13, listeners: d9 }), e13.data = Q);
        }
        se2(g6, b7);
      });
    }
    function ef(a9, b7, c7) {
      return { instance: a9, listener: b7, currentTarget: c7 };
    }
    function oe2(a9, b7) {
      for (var c7 = b7 + "Capture", d8 = []; a9 !== null; ) {
        var e12 = a9, f11 = e12.stateNode;
        e12.tag === 5 && f11 !== null && (e12 = f11, f11 = Ob(a9, c7), f11 != null && d8.unshift(ef(a9, f11, e12)), f11 = Ob(a9, b7), f11 != null && d8.push(ef(a9, f11, e12)));
        a9 = a9.return;
      }
      return d8;
    }
    function gf(a9) {
      if (a9 === null)
        return null;
      do
        a9 = a9.return;
      while (a9 && a9.tag !== 5);
      return a9 ? a9 : null;
    }
    function hf(a9, b7, c7, d8, e12) {
      for (var f11 = b7._reactName, g5 = []; c7 !== null && c7 !== d8; ) {
        var h3 = c7, k3 = h3.alternate, l9 = h3.stateNode;
        if (k3 !== null && k3 === d8)
          break;
        h3.tag === 5 && l9 !== null && (h3 = l9, e12 ? (k3 = Ob(c7, f11), k3 != null && g5.unshift(ef(c7, k3, h3))) : e12 || (k3 = Ob(c7, f11), k3 != null && g5.push(ef(c7, k3, h3))));
        c7 = c7.return;
      }
      g5.length !== 0 && a9.push({ event: b7, listeners: g5 });
    }
    function jf() {
    }
    var kf = null;
    var lf = null;
    function mf(a9, b7) {
      switch (a9) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!b7.autoFocus;
      }
      return false;
    }
    function nf(a9, b7) {
      return a9 === "textarea" || a9 === "option" || a9 === "noscript" || typeof b7.children === "string" || typeof b7.children === "number" || typeof b7.dangerouslySetInnerHTML === "object" && b7.dangerouslySetInnerHTML !== null && b7.dangerouslySetInnerHTML.__html != null;
    }
    var of = typeof setTimeout === "function" ? setTimeout : void 0;
    var pf = typeof clearTimeout === "function" ? clearTimeout : void 0;
    function qf(a9) {
      a9.nodeType === 1 ? a9.textContent = "" : a9.nodeType === 9 && (a9 = a9.body, a9 != null && (a9.textContent = ""));
    }
    function rf(a9) {
      for (; a9 != null; a9 = a9.nextSibling) {
        var b7 = a9.nodeType;
        if (b7 === 1 || b7 === 3)
          break;
      }
      return a9;
    }
    function sf(a9) {
      a9 = a9.previousSibling;
      for (var b7 = 0; a9; ) {
        if (a9.nodeType === 8) {
          var c7 = a9.data;
          if (c7 === "$" || c7 === "$!" || c7 === "$?") {
            if (b7 === 0)
              return a9;
            b7--;
          } else
            c7 === "/$" && b7++;
        }
        a9 = a9.previousSibling;
      }
      return null;
    }
    var tf = 0;
    function uf(a9) {
      return { $$typeof: Ga, toString: a9, valueOf: a9 };
    }
    var vf = Math.random().toString(36).slice(2);
    var wf = "__reactFiber$" + vf;
    var xf = "__reactProps$" + vf;
    var ff = "__reactContainer$" + vf;
    var yf = "__reactEvents$" + vf;
    function wc(a9) {
      var b7 = a9[wf];
      if (b7)
        return b7;
      for (var c7 = a9.parentNode; c7; ) {
        if (b7 = c7[ff] || c7[wf]) {
          c7 = b7.alternate;
          if (b7.child !== null || c7 !== null && c7.child !== null)
            for (a9 = sf(a9); a9 !== null; ) {
              if (c7 = a9[wf])
                return c7;
              a9 = sf(a9);
            }
          return b7;
        }
        a9 = c7;
        c7 = a9.parentNode;
      }
      return null;
    }
    function Cb(a9) {
      a9 = a9[wf] || a9[ff];
      return !a9 || a9.tag !== 5 && a9.tag !== 6 && a9.tag !== 13 && a9.tag !== 3 ? null : a9;
    }
    function ue2(a9) {
      if (a9.tag === 5 || a9.tag === 6)
        return a9.stateNode;
      throw Error(y4(33));
    }
    function Db(a9) {
      return a9[xf] || null;
    }
    function $e(a9) {
      var b7 = a9[yf];
      b7 === void 0 && (b7 = a9[yf] = new Set());
      return b7;
    }
    var zf = [];
    var Af = -1;
    function Bf(a9) {
      return { current: a9 };
    }
    function H3(a9) {
      0 > Af || (a9.current = zf[Af], zf[Af] = null, Af--);
    }
    function I3(a9, b7) {
      Af++;
      zf[Af] = a9.current;
      a9.current = b7;
    }
    var Cf = {};
    var M4 = Bf(Cf);
    var N2 = Bf(false);
    var Df = Cf;
    function Ef(a9, b7) {
      var c7 = a9.type.contextTypes;
      if (!c7)
        return Cf;
      var d8 = a9.stateNode;
      if (d8 && d8.__reactInternalMemoizedUnmaskedChildContext === b7)
        return d8.__reactInternalMemoizedMaskedChildContext;
      var e12 = {}, f11;
      for (f11 in c7)
        e12[f11] = b7[f11];
      d8 && (a9 = a9.stateNode, a9.__reactInternalMemoizedUnmaskedChildContext = b7, a9.__reactInternalMemoizedMaskedChildContext = e12);
      return e12;
    }
    function Ff(a9) {
      a9 = a9.childContextTypes;
      return a9 !== null && a9 !== void 0;
    }
    function Gf() {
      H3(N2);
      H3(M4);
    }
    function Hf(a9, b7, c7) {
      if (M4.current !== Cf)
        throw Error(y4(168));
      I3(M4, b7);
      I3(N2, c7);
    }
    function If(a9, b7, c7) {
      var d8 = a9.stateNode;
      a9 = b7.childContextTypes;
      if (typeof d8.getChildContext !== "function")
        return c7;
      d8 = d8.getChildContext();
      for (var e12 in d8)
        if (!(e12 in a9))
          throw Error(y4(108, Ra(b7) || "Unknown", e12));
      return m7({}, c7, d8);
    }
    function Jf(a9) {
      a9 = (a9 = a9.stateNode) && a9.__reactInternalMemoizedMergedChildContext || Cf;
      Df = M4.current;
      I3(M4, a9);
      I3(N2, N2.current);
      return true;
    }
    function Kf(a9, b7, c7) {
      var d8 = a9.stateNode;
      if (!d8)
        throw Error(y4(169));
      c7 ? (a9 = If(a9, b7, Df), d8.__reactInternalMemoizedMergedChildContext = a9, H3(N2), H3(M4), I3(M4, a9)) : H3(N2);
      I3(N2, c7);
    }
    var Lf = null;
    var Mf = null;
    var Nf = r13.unstable_runWithPriority;
    var Of = r13.unstable_scheduleCallback;
    var Pf = r13.unstable_cancelCallback;
    var Qf = r13.unstable_shouldYield;
    var Rf = r13.unstable_requestPaint;
    var Sf = r13.unstable_now;
    var Tf = r13.unstable_getCurrentPriorityLevel;
    var Uf = r13.unstable_ImmediatePriority;
    var Vf = r13.unstable_UserBlockingPriority;
    var Wf = r13.unstable_NormalPriority;
    var Xf = r13.unstable_LowPriority;
    var Yf = r13.unstable_IdlePriority;
    var Zf = {};
    var $f = Rf !== void 0 ? Rf : function() {
    };
    var ag = null;
    var bg = null;
    var cg = false;
    var dg = Sf();
    var O5 = 1e4 > dg ? Sf : function() {
      return Sf() - dg;
    };
    function eg() {
      switch (Tf()) {
        case Uf:
          return 99;
        case Vf:
          return 98;
        case Wf:
          return 97;
        case Xf:
          return 96;
        case Yf:
          return 95;
        default:
          throw Error(y4(332));
      }
    }
    function fg(a9) {
      switch (a9) {
        case 99:
          return Uf;
        case 98:
          return Vf;
        case 97:
          return Wf;
        case 96:
          return Xf;
        case 95:
          return Yf;
        default:
          throw Error(y4(332));
      }
    }
    function gg(a9, b7) {
      a9 = fg(a9);
      return Nf(a9, b7);
    }
    function hg(a9, b7, c7) {
      a9 = fg(a9);
      return Of(a9, b7, c7);
    }
    function ig() {
      if (bg !== null) {
        var a9 = bg;
        bg = null;
        Pf(a9);
      }
      jg();
    }
    function jg() {
      if (!cg && ag !== null) {
        cg = true;
        var a9 = 0;
        try {
          var b7 = ag;
          gg(99, function() {
            for (; a9 < b7.length; a9++) {
              var c7 = b7[a9];
              do
                c7 = c7(true);
              while (c7 !== null);
            }
          });
          ag = null;
        } catch (c7) {
          throw ag !== null && (ag = ag.slice(a9 + 1)), Of(Uf, ig), c7;
        } finally {
          cg = false;
        }
      }
    }
    var kg = ra.ReactCurrentBatchConfig;
    function lg(a9, b7) {
      if (a9 && a9.defaultProps) {
        b7 = m7({}, b7);
        a9 = a9.defaultProps;
        for (var c7 in a9)
          b7[c7] === void 0 && (b7[c7] = a9[c7]);
        return b7;
      }
      return b7;
    }
    var mg = Bf(null);
    var ng = null;
    var og = null;
    var pg = null;
    function qg() {
      pg = og = ng = null;
    }
    function rg(a9) {
      var b7 = mg.current;
      H3(mg);
      a9.type._context._currentValue = b7;
    }
    function sg(a9, b7) {
      for (; a9 !== null; ) {
        var c7 = a9.alternate;
        if ((a9.childLanes & b7) === b7)
          if (c7 === null || (c7.childLanes & b7) === b7)
            break;
          else
            c7.childLanes |= b7;
        else
          a9.childLanes |= b7, c7 !== null && (c7.childLanes |= b7);
        a9 = a9.return;
      }
    }
    function tg(a9, b7) {
      ng = a9;
      pg = og = null;
      a9 = a9.dependencies;
      a9 !== null && a9.firstContext !== null && ((a9.lanes & b7) !== 0 && (ug = true), a9.firstContext = null);
    }
    function vg(a9, b7) {
      if (pg !== a9 && b7 !== false && b7 !== 0) {
        if (typeof b7 !== "number" || b7 === 1073741823)
          pg = a9, b7 = 1073741823;
        b7 = { context: a9, observedBits: b7, next: null };
        if (og === null) {
          if (ng === null)
            throw Error(y4(308));
          og = b7;
          ng.dependencies = { lanes: 0, firstContext: b7, responders: null };
        } else
          og = og.next = b7;
      }
      return a9._currentValue;
    }
    var wg = false;
    function xg(a9) {
      a9.updateQueue = { baseState: a9.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
    }
    function yg(a9, b7) {
      a9 = a9.updateQueue;
      b7.updateQueue === a9 && (b7.updateQueue = { baseState: a9.baseState, firstBaseUpdate: a9.firstBaseUpdate, lastBaseUpdate: a9.lastBaseUpdate, shared: a9.shared, effects: a9.effects });
    }
    function zg(a9, b7) {
      return { eventTime: a9, lane: b7, tag: 0, payload: null, callback: null, next: null };
    }
    function Ag(a9, b7) {
      a9 = a9.updateQueue;
      if (a9 !== null) {
        a9 = a9.shared;
        var c7 = a9.pending;
        c7 === null ? b7.next = b7 : (b7.next = c7.next, c7.next = b7);
        a9.pending = b7;
      }
    }
    function Bg(a9, b7) {
      var c7 = a9.updateQueue, d8 = a9.alternate;
      if (d8 !== null && (d8 = d8.updateQueue, c7 === d8)) {
        var e12 = null, f11 = null;
        c7 = c7.firstBaseUpdate;
        if (c7 !== null) {
          do {
            var g5 = { eventTime: c7.eventTime, lane: c7.lane, tag: c7.tag, payload: c7.payload, callback: c7.callback, next: null };
            f11 === null ? e12 = f11 = g5 : f11 = f11.next = g5;
            c7 = c7.next;
          } while (c7 !== null);
          f11 === null ? e12 = f11 = b7 : f11 = f11.next = b7;
        } else
          e12 = f11 = b7;
        c7 = { baseState: d8.baseState, firstBaseUpdate: e12, lastBaseUpdate: f11, shared: d8.shared, effects: d8.effects };
        a9.updateQueue = c7;
        return;
      }
      a9 = c7.lastBaseUpdate;
      a9 === null ? c7.firstBaseUpdate = b7 : a9.next = b7;
      c7.lastBaseUpdate = b7;
    }
    function Cg(a9, b7, c7, d8) {
      var e12 = a9.updateQueue;
      wg = false;
      var f11 = e12.firstBaseUpdate, g5 = e12.lastBaseUpdate, h3 = e12.shared.pending;
      if (h3 !== null) {
        e12.shared.pending = null;
        var k3 = h3, l9 = k3.next;
        k3.next = null;
        g5 === null ? f11 = l9 : g5.next = l9;
        g5 = k3;
        var n6 = a9.alternate;
        if (n6 !== null) {
          n6 = n6.updateQueue;
          var A4 = n6.lastBaseUpdate;
          A4 !== g5 && (A4 === null ? n6.firstBaseUpdate = l9 : A4.next = l9, n6.lastBaseUpdate = k3);
        }
      }
      if (f11 !== null) {
        A4 = e12.baseState;
        g5 = 0;
        n6 = l9 = k3 = null;
        do {
          h3 = f11.lane;
          var p7 = f11.eventTime;
          if ((d8 & h3) === h3) {
            n6 !== null && (n6 = n6.next = {
              eventTime: p7,
              lane: 0,
              tag: f11.tag,
              payload: f11.payload,
              callback: f11.callback,
              next: null
            });
            a: {
              var C6 = a9, x5 = f11;
              h3 = b7;
              p7 = c7;
              switch (x5.tag) {
                case 1:
                  C6 = x5.payload;
                  if (typeof C6 === "function") {
                    A4 = C6.call(p7, A4, h3);
                    break a;
                  }
                  A4 = C6;
                  break a;
                case 3:
                  C6.flags = C6.flags & -4097 | 64;
                case 0:
                  C6 = x5.payload;
                  h3 = typeof C6 === "function" ? C6.call(p7, A4, h3) : C6;
                  if (h3 === null || h3 === void 0)
                    break a;
                  A4 = m7({}, A4, h3);
                  break a;
                case 2:
                  wg = true;
              }
            }
            f11.callback !== null && (a9.flags |= 32, h3 = e12.effects, h3 === null ? e12.effects = [f11] : h3.push(f11));
          } else
            p7 = { eventTime: p7, lane: h3, tag: f11.tag, payload: f11.payload, callback: f11.callback, next: null }, n6 === null ? (l9 = n6 = p7, k3 = A4) : n6 = n6.next = p7, g5 |= h3;
          f11 = f11.next;
          if (f11 === null)
            if (h3 = e12.shared.pending, h3 === null)
              break;
            else
              f11 = h3.next, h3.next = null, e12.lastBaseUpdate = h3, e12.shared.pending = null;
        } while (1);
        n6 === null && (k3 = A4);
        e12.baseState = k3;
        e12.firstBaseUpdate = l9;
        e12.lastBaseUpdate = n6;
        Dg |= g5;
        a9.lanes = g5;
        a9.memoizedState = A4;
      }
    }
    function Eg(a9, b7, c7) {
      a9 = b7.effects;
      b7.effects = null;
      if (a9 !== null)
        for (b7 = 0; b7 < a9.length; b7++) {
          var d8 = a9[b7], e12 = d8.callback;
          if (e12 !== null) {
            d8.callback = null;
            d8 = c7;
            if (typeof e12 !== "function")
              throw Error(y4(191, e12));
            e12.call(d8);
          }
        }
    }
    var Fg = new aa.Component().refs;
    function Gg(a9, b7, c7, d8) {
      b7 = a9.memoizedState;
      c7 = c7(d8, b7);
      c7 = c7 === null || c7 === void 0 ? b7 : m7({}, b7, c7);
      a9.memoizedState = c7;
      a9.lanes === 0 && (a9.updateQueue.baseState = c7);
    }
    var Kg = { isMounted: function(a9) {
      return (a9 = a9._reactInternals) ? Zb(a9) === a9 : false;
    }, enqueueSetState: function(a9, b7, c7) {
      a9 = a9._reactInternals;
      var d8 = Hg(), e12 = Ig(a9), f11 = zg(d8, e12);
      f11.payload = b7;
      c7 !== void 0 && c7 !== null && (f11.callback = c7);
      Ag(a9, f11);
      Jg(a9, e12, d8);
    }, enqueueReplaceState: function(a9, b7, c7) {
      a9 = a9._reactInternals;
      var d8 = Hg(), e12 = Ig(a9), f11 = zg(d8, e12);
      f11.tag = 1;
      f11.payload = b7;
      c7 !== void 0 && c7 !== null && (f11.callback = c7);
      Ag(a9, f11);
      Jg(a9, e12, d8);
    }, enqueueForceUpdate: function(a9, b7) {
      a9 = a9._reactInternals;
      var c7 = Hg(), d8 = Ig(a9), e12 = zg(c7, d8);
      e12.tag = 2;
      b7 !== void 0 && b7 !== null && (e12.callback = b7);
      Ag(a9, e12);
      Jg(a9, d8, c7);
    } };
    function Lg(a9, b7, c7, d8, e12, f11, g5) {
      a9 = a9.stateNode;
      return typeof a9.shouldComponentUpdate === "function" ? a9.shouldComponentUpdate(d8, f11, g5) : b7.prototype && b7.prototype.isPureReactComponent ? !Je(c7, d8) || !Je(e12, f11) : true;
    }
    function Mg(a9, b7, c7) {
      var d8 = false, e12 = Cf;
      var f11 = b7.contextType;
      typeof f11 === "object" && f11 !== null ? f11 = vg(f11) : (e12 = Ff(b7) ? Df : M4.current, d8 = b7.contextTypes, f11 = (d8 = d8 !== null && d8 !== void 0) ? Ef(a9, e12) : Cf);
      b7 = new b7(c7, f11);
      a9.memoizedState = b7.state !== null && b7.state !== void 0 ? b7.state : null;
      b7.updater = Kg;
      a9.stateNode = b7;
      b7._reactInternals = a9;
      d8 && (a9 = a9.stateNode, a9.__reactInternalMemoizedUnmaskedChildContext = e12, a9.__reactInternalMemoizedMaskedChildContext = f11);
      return b7;
    }
    function Ng(a9, b7, c7, d8) {
      a9 = b7.state;
      typeof b7.componentWillReceiveProps === "function" && b7.componentWillReceiveProps(c7, d8);
      typeof b7.UNSAFE_componentWillReceiveProps === "function" && b7.UNSAFE_componentWillReceiveProps(c7, d8);
      b7.state !== a9 && Kg.enqueueReplaceState(b7, b7.state, null);
    }
    function Og(a9, b7, c7, d8) {
      var e12 = a9.stateNode;
      e12.props = c7;
      e12.state = a9.memoizedState;
      e12.refs = Fg;
      xg(a9);
      var f11 = b7.contextType;
      typeof f11 === "object" && f11 !== null ? e12.context = vg(f11) : (f11 = Ff(b7) ? Df : M4.current, e12.context = Ef(a9, f11));
      Cg(a9, c7, e12, d8);
      e12.state = a9.memoizedState;
      f11 = b7.getDerivedStateFromProps;
      typeof f11 === "function" && (Gg(a9, b7, f11, c7), e12.state = a9.memoizedState);
      typeof b7.getDerivedStateFromProps === "function" || typeof e12.getSnapshotBeforeUpdate === "function" || typeof e12.UNSAFE_componentWillMount !== "function" && typeof e12.componentWillMount !== "function" || (b7 = e12.state, typeof e12.componentWillMount === "function" && e12.componentWillMount(), typeof e12.UNSAFE_componentWillMount === "function" && e12.UNSAFE_componentWillMount(), b7 !== e12.state && Kg.enqueueReplaceState(e12, e12.state, null), Cg(a9, c7, e12, d8), e12.state = a9.memoizedState);
      typeof e12.componentDidMount === "function" && (a9.flags |= 4);
    }
    var Pg = Array.isArray;
    function Qg(a9, b7, c7) {
      a9 = c7.ref;
      if (a9 !== null && typeof a9 !== "function" && typeof a9 !== "object") {
        if (c7._owner) {
          c7 = c7._owner;
          if (c7) {
            if (c7.tag !== 1)
              throw Error(y4(309));
            var d8 = c7.stateNode;
          }
          if (!d8)
            throw Error(y4(147, a9));
          var e12 = "" + a9;
          if (b7 !== null && b7.ref !== null && typeof b7.ref === "function" && b7.ref._stringRef === e12)
            return b7.ref;
          b7 = function(a10) {
            var b8 = d8.refs;
            b8 === Fg && (b8 = d8.refs = {});
            a10 === null ? delete b8[e12] : b8[e12] = a10;
          };
          b7._stringRef = e12;
          return b7;
        }
        if (typeof a9 !== "string")
          throw Error(y4(284));
        if (!c7._owner)
          throw Error(y4(290, a9));
      }
      return a9;
    }
    function Rg(a9, b7) {
      if (a9.type !== "textarea")
        throw Error(y4(31, Object.prototype.toString.call(b7) === "[object Object]" ? "object with keys {" + Object.keys(b7).join(", ") + "}" : b7));
    }
    function Sg(a9) {
      function b7(b8, c8) {
        if (a9) {
          var d9 = b8.lastEffect;
          d9 !== null ? (d9.nextEffect = c8, b8.lastEffect = c8) : b8.firstEffect = b8.lastEffect = c8;
          c8.nextEffect = null;
          c8.flags = 8;
        }
      }
      function c7(c8, d9) {
        if (!a9)
          return null;
        for (; d9 !== null; )
          b7(c8, d9), d9 = d9.sibling;
        return null;
      }
      function d8(a10, b8) {
        for (a10 = new Map(); b8 !== null; )
          b8.key !== null ? a10.set(b8.key, b8) : a10.set(b8.index, b8), b8 = b8.sibling;
        return a10;
      }
      function e12(a10, b8) {
        a10 = Tg(a10, b8);
        a10.index = 0;
        a10.sibling = null;
        return a10;
      }
      function f11(b8, c8, d9) {
        b8.index = d9;
        if (!a9)
          return c8;
        d9 = b8.alternate;
        if (d9 !== null)
          return d9 = d9.index, d9 < c8 ? (b8.flags = 2, c8) : d9;
        b8.flags = 2;
        return c8;
      }
      function g5(b8) {
        a9 && b8.alternate === null && (b8.flags = 2);
        return b8;
      }
      function h3(a10, b8, c8, d9) {
        if (b8 === null || b8.tag !== 6)
          return b8 = Ug(c8, a10.mode, d9), b8.return = a10, b8;
        b8 = e12(b8, c8);
        b8.return = a10;
        return b8;
      }
      function k3(a10, b8, c8, d9) {
        if (b8 !== null && b8.elementType === c8.type)
          return d9 = e12(b8, c8.props), d9.ref = Qg(a10, b8, c8), d9.return = a10, d9;
        d9 = Vg(c8.type, c8.key, c8.props, null, a10.mode, d9);
        d9.ref = Qg(a10, b8, c8);
        d9.return = a10;
        return d9;
      }
      function l9(a10, b8, c8, d9) {
        if (b8 === null || b8.tag !== 4 || b8.stateNode.containerInfo !== c8.containerInfo || b8.stateNode.implementation !== c8.implementation)
          return b8 = Wg(c8, a10.mode, d9), b8.return = a10, b8;
        b8 = e12(b8, c8.children || []);
        b8.return = a10;
        return b8;
      }
      function n6(a10, b8, c8, d9, f12) {
        if (b8 === null || b8.tag !== 7)
          return b8 = Xg(c8, a10.mode, d9, f12), b8.return = a10, b8;
        b8 = e12(b8, c8);
        b8.return = a10;
        return b8;
      }
      function A4(a10, b8, c8) {
        if (typeof b8 === "string" || typeof b8 === "number")
          return b8 = Ug("" + b8, a10.mode, c8), b8.return = a10, b8;
        if (typeof b8 === "object" && b8 !== null) {
          switch (b8.$$typeof) {
            case sa:
              return c8 = Vg(b8.type, b8.key, b8.props, null, a10.mode, c8), c8.ref = Qg(a10, null, b8), c8.return = a10, c8;
            case ta:
              return b8 = Wg(b8, a10.mode, c8), b8.return = a10, b8;
          }
          if (Pg(b8) || La(b8))
            return b8 = Xg(b8, a10.mode, c8, null), b8.return = a10, b8;
          Rg(a10, b8);
        }
        return null;
      }
      function p7(a10, b8, c8, d9) {
        var e13 = b8 !== null ? b8.key : null;
        if (typeof c8 === "string" || typeof c8 === "number")
          return e13 !== null ? null : h3(a10, b8, "" + c8, d9);
        if (typeof c8 === "object" && c8 !== null) {
          switch (c8.$$typeof) {
            case sa:
              return c8.key === e13 ? c8.type === ua ? n6(a10, b8, c8.props.children, d9, e13) : k3(a10, b8, c8, d9) : null;
            case ta:
              return c8.key === e13 ? l9(a10, b8, c8, d9) : null;
          }
          if (Pg(c8) || La(c8))
            return e13 !== null ? null : n6(a10, b8, c8, d9, null);
          Rg(a10, c8);
        }
        return null;
      }
      function C6(a10, b8, c8, d9, e13) {
        if (typeof d9 === "string" || typeof d9 === "number")
          return a10 = a10.get(c8) || null, h3(b8, a10, "" + d9, e13);
        if (typeof d9 === "object" && d9 !== null) {
          switch (d9.$$typeof) {
            case sa:
              return a10 = a10.get(d9.key === null ? c8 : d9.key) || null, d9.type === ua ? n6(b8, a10, d9.props.children, e13, d9.key) : k3(b8, a10, d9, e13);
            case ta:
              return a10 = a10.get(d9.key === null ? c8 : d9.key) || null, l9(b8, a10, d9, e13);
          }
          if (Pg(d9) || La(d9))
            return a10 = a10.get(c8) || null, n6(b8, a10, d9, e13, null);
          Rg(b8, d9);
        }
        return null;
      }
      function x5(e13, g6, h4, k4) {
        for (var l10 = null, t14 = null, u4 = g6, z3 = g6 = 0, q3 = null; u4 !== null && z3 < h4.length; z3++) {
          u4.index > z3 ? (q3 = u4, u4 = null) : q3 = u4.sibling;
          var n7 = p7(e13, u4, h4[z3], k4);
          if (n7 === null) {
            u4 === null && (u4 = q3);
            break;
          }
          a9 && u4 && n7.alternate === null && b7(e13, u4);
          g6 = f11(n7, g6, z3);
          t14 === null ? l10 = n7 : t14.sibling = n7;
          t14 = n7;
          u4 = q3;
        }
        if (z3 === h4.length)
          return c7(e13, u4), l10;
        if (u4 === null) {
          for (; z3 < h4.length; z3++)
            u4 = A4(e13, h4[z3], k4), u4 !== null && (g6 = f11(u4, g6, z3), t14 === null ? l10 = u4 : t14.sibling = u4, t14 = u4);
          return l10;
        }
        for (u4 = d8(e13, u4); z3 < h4.length; z3++)
          q3 = C6(u4, e13, z3, h4[z3], k4), q3 !== null && (a9 && q3.alternate !== null && u4.delete(q3.key === null ? z3 : q3.key), g6 = f11(q3, g6, z3), t14 === null ? l10 = q3 : t14.sibling = q3, t14 = q3);
        a9 && u4.forEach(function(a10) {
          return b7(e13, a10);
        });
        return l10;
      }
      function w6(e13, g6, h4, k4) {
        var l10 = La(h4);
        if (typeof l10 !== "function")
          throw Error(y4(150));
        h4 = l10.call(h4);
        if (h4 == null)
          throw Error(y4(151));
        for (var t14 = l10 = null, u4 = g6, z3 = g6 = 0, q3 = null, n7 = h4.next(); u4 !== null && !n7.done; z3++, n7 = h4.next()) {
          u4.index > z3 ? (q3 = u4, u4 = null) : q3 = u4.sibling;
          var w7 = p7(e13, u4, n7.value, k4);
          if (w7 === null) {
            u4 === null && (u4 = q3);
            break;
          }
          a9 && u4 && w7.alternate === null && b7(e13, u4);
          g6 = f11(w7, g6, z3);
          t14 === null ? l10 = w7 : t14.sibling = w7;
          t14 = w7;
          u4 = q3;
        }
        if (n7.done)
          return c7(e13, u4), l10;
        if (u4 === null) {
          for (; !n7.done; z3++, n7 = h4.next())
            n7 = A4(e13, n7.value, k4), n7 !== null && (g6 = f11(n7, g6, z3), t14 === null ? l10 = n7 : t14.sibling = n7, t14 = n7);
          return l10;
        }
        for (u4 = d8(e13, u4); !n7.done; z3++, n7 = h4.next())
          n7 = C6(u4, e13, z3, n7.value, k4), n7 !== null && (a9 && n7.alternate !== null && u4.delete(n7.key === null ? z3 : n7.key), g6 = f11(n7, g6, z3), t14 === null ? l10 = n7 : t14.sibling = n7, t14 = n7);
        a9 && u4.forEach(function(a10) {
          return b7(e13, a10);
        });
        return l10;
      }
      return function(a10, d9, f12, h4) {
        var k4 = typeof f12 === "object" && f12 !== null && f12.type === ua && f12.key === null;
        k4 && (f12 = f12.props.children);
        var l10 = typeof f12 === "object" && f12 !== null;
        if (l10)
          switch (f12.$$typeof) {
            case sa:
              a: {
                l10 = f12.key;
                for (k4 = d9; k4 !== null; ) {
                  if (k4.key === l10) {
                    switch (k4.tag) {
                      case 7:
                        if (f12.type === ua) {
                          c7(a10, k4.sibling);
                          d9 = e12(k4, f12.props.children);
                          d9.return = a10;
                          a10 = d9;
                          break a;
                        }
                        break;
                      default:
                        if (k4.elementType === f12.type) {
                          c7(a10, k4.sibling);
                          d9 = e12(k4, f12.props);
                          d9.ref = Qg(a10, k4, f12);
                          d9.return = a10;
                          a10 = d9;
                          break a;
                        }
                    }
                    c7(a10, k4);
                    break;
                  } else
                    b7(a10, k4);
                  k4 = k4.sibling;
                }
                f12.type === ua ? (d9 = Xg(f12.props.children, a10.mode, h4, f12.key), d9.return = a10, a10 = d9) : (h4 = Vg(f12.type, f12.key, f12.props, null, a10.mode, h4), h4.ref = Qg(a10, d9, f12), h4.return = a10, a10 = h4);
              }
              return g5(a10);
            case ta:
              a: {
                for (k4 = f12.key; d9 !== null; ) {
                  if (d9.key === k4)
                    if (d9.tag === 4 && d9.stateNode.containerInfo === f12.containerInfo && d9.stateNode.implementation === f12.implementation) {
                      c7(a10, d9.sibling);
                      d9 = e12(d9, f12.children || []);
                      d9.return = a10;
                      a10 = d9;
                      break a;
                    } else {
                      c7(a10, d9);
                      break;
                    }
                  else
                    b7(a10, d9);
                  d9 = d9.sibling;
                }
                d9 = Wg(f12, a10.mode, h4);
                d9.return = a10;
                a10 = d9;
              }
              return g5(a10);
          }
        if (typeof f12 === "string" || typeof f12 === "number")
          return f12 = "" + f12, d9 !== null && d9.tag === 6 ? (c7(a10, d9.sibling), d9 = e12(d9, f12), d9.return = a10, a10 = d9) : (c7(a10, d9), d9 = Ug(f12, a10.mode, h4), d9.return = a10, a10 = d9), g5(a10);
        if (Pg(f12))
          return x5(a10, d9, f12, h4);
        if (La(f12))
          return w6(a10, d9, f12, h4);
        l10 && Rg(a10, f12);
        if (typeof f12 === "undefined" && !k4)
          switch (a10.tag) {
            case 1:
            case 22:
            case 0:
            case 11:
            case 15:
              throw Error(y4(152, Ra(a10.type) || "Component"));
          }
        return c7(a10, d9);
      };
    }
    var Yg = Sg(true);
    var Zg = Sg(false);
    var $g = {};
    var ah = Bf($g);
    var bh = Bf($g);
    var ch = Bf($g);
    function dh(a9) {
      if (a9 === $g)
        throw Error(y4(174));
      return a9;
    }
    function eh(a9, b7) {
      I3(ch, b7);
      I3(bh, a9);
      I3(ah, $g);
      a9 = b7.nodeType;
      switch (a9) {
        case 9:
        case 11:
          b7 = (b7 = b7.documentElement) ? b7.namespaceURI : mb(null, "");
          break;
        default:
          a9 = a9 === 8 ? b7.parentNode : b7, b7 = a9.namespaceURI || null, a9 = a9.tagName, b7 = mb(b7, a9);
      }
      H3(ah);
      I3(ah, b7);
    }
    function fh() {
      H3(ah);
      H3(bh);
      H3(ch);
    }
    function gh(a9) {
      dh(ch.current);
      var b7 = dh(ah.current);
      var c7 = mb(b7, a9.type);
      b7 !== c7 && (I3(bh, a9), I3(ah, c7));
    }
    function hh(a9) {
      bh.current === a9 && (H3(ah), H3(bh));
    }
    var P3 = Bf(0);
    function ih(a9) {
      for (var b7 = a9; b7 !== null; ) {
        if (b7.tag === 13) {
          var c7 = b7.memoizedState;
          if (c7 !== null && (c7 = c7.dehydrated, c7 === null || c7.data === "$?" || c7.data === "$!"))
            return b7;
        } else if (b7.tag === 19 && b7.memoizedProps.revealOrder !== void 0) {
          if ((b7.flags & 64) !== 0)
            return b7;
        } else if (b7.child !== null) {
          b7.child.return = b7;
          b7 = b7.child;
          continue;
        }
        if (b7 === a9)
          break;
        for (; b7.sibling === null; ) {
          if (b7.return === null || b7.return === a9)
            return null;
          b7 = b7.return;
        }
        b7.sibling.return = b7.return;
        b7 = b7.sibling;
      }
      return null;
    }
    var jh = null;
    var kh = null;
    var lh = false;
    function mh(a9, b7) {
      var c7 = nh(5, null, null, 0);
      c7.elementType = "DELETED";
      c7.type = "DELETED";
      c7.stateNode = b7;
      c7.return = a9;
      c7.flags = 8;
      a9.lastEffect !== null ? (a9.lastEffect.nextEffect = c7, a9.lastEffect = c7) : a9.firstEffect = a9.lastEffect = c7;
    }
    function oh(a9, b7) {
      switch (a9.tag) {
        case 5:
          var c7 = a9.type;
          b7 = b7.nodeType !== 1 || c7.toLowerCase() !== b7.nodeName.toLowerCase() ? null : b7;
          return b7 !== null ? (a9.stateNode = b7, true) : false;
        case 6:
          return b7 = a9.pendingProps === "" || b7.nodeType !== 3 ? null : b7, b7 !== null ? (a9.stateNode = b7, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function ph(a9) {
      if (lh) {
        var b7 = kh;
        if (b7) {
          var c7 = b7;
          if (!oh(a9, b7)) {
            b7 = rf(c7.nextSibling);
            if (!b7 || !oh(a9, b7)) {
              a9.flags = a9.flags & -1025 | 2;
              lh = false;
              jh = a9;
              return;
            }
            mh(jh, c7);
          }
          jh = a9;
          kh = rf(b7.firstChild);
        } else
          a9.flags = a9.flags & -1025 | 2, lh = false, jh = a9;
      }
    }
    function qh(a9) {
      for (a9 = a9.return; a9 !== null && a9.tag !== 5 && a9.tag !== 3 && a9.tag !== 13; )
        a9 = a9.return;
      jh = a9;
    }
    function rh(a9) {
      if (a9 !== jh)
        return false;
      if (!lh)
        return qh(a9), lh = true, false;
      var b7 = a9.type;
      if (a9.tag !== 5 || b7 !== "head" && b7 !== "body" && !nf(b7, a9.memoizedProps))
        for (b7 = kh; b7; )
          mh(a9, b7), b7 = rf(b7.nextSibling);
      qh(a9);
      if (a9.tag === 13) {
        a9 = a9.memoizedState;
        a9 = a9 !== null ? a9.dehydrated : null;
        if (!a9)
          throw Error(y4(317));
        a: {
          a9 = a9.nextSibling;
          for (b7 = 0; a9; ) {
            if (a9.nodeType === 8) {
              var c7 = a9.data;
              if (c7 === "/$") {
                if (b7 === 0) {
                  kh = rf(a9.nextSibling);
                  break a;
                }
                b7--;
              } else
                c7 !== "$" && c7 !== "$!" && c7 !== "$?" || b7++;
            }
            a9 = a9.nextSibling;
          }
          kh = null;
        }
      } else
        kh = jh ? rf(a9.stateNode.nextSibling) : null;
      return true;
    }
    function sh() {
      kh = jh = null;
      lh = false;
    }
    var th = [];
    function uh() {
      for (var a9 = 0; a9 < th.length; a9++)
        th[a9]._workInProgressVersionPrimary = null;
      th.length = 0;
    }
    var vh = ra.ReactCurrentDispatcher;
    var wh = ra.ReactCurrentBatchConfig;
    var xh = 0;
    var R5 = null;
    var S3 = null;
    var T5 = null;
    var yh = false;
    var zh = false;
    function Ah() {
      throw Error(y4(321));
    }
    function Bh(a9, b7) {
      if (b7 === null)
        return false;
      for (var c7 = 0; c7 < b7.length && c7 < a9.length; c7++)
        if (!He(a9[c7], b7[c7]))
          return false;
      return true;
    }
    function Ch(a9, b7, c7, d8, e12, f11) {
      xh = f11;
      R5 = b7;
      b7.memoizedState = null;
      b7.updateQueue = null;
      b7.lanes = 0;
      vh.current = a9 === null || a9.memoizedState === null ? Dh : Eh;
      a9 = c7(d8, e12);
      if (zh) {
        f11 = 0;
        do {
          zh = false;
          if (!(25 > f11))
            throw Error(y4(301));
          f11 += 1;
          T5 = S3 = null;
          b7.updateQueue = null;
          vh.current = Fh;
          a9 = c7(d8, e12);
        } while (zh);
      }
      vh.current = Gh;
      b7 = S3 !== null && S3.next !== null;
      xh = 0;
      T5 = S3 = R5 = null;
      yh = false;
      if (b7)
        throw Error(y4(300));
      return a9;
    }
    function Hh() {
      var a9 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      T5 === null ? R5.memoizedState = T5 = a9 : T5 = T5.next = a9;
      return T5;
    }
    function Ih() {
      if (S3 === null) {
        var a9 = R5.alternate;
        a9 = a9 !== null ? a9.memoizedState : null;
      } else
        a9 = S3.next;
      var b7 = T5 === null ? R5.memoizedState : T5.next;
      if (b7 !== null)
        T5 = b7, S3 = a9;
      else {
        if (a9 === null)
          throw Error(y4(310));
        S3 = a9;
        a9 = { memoizedState: S3.memoizedState, baseState: S3.baseState, baseQueue: S3.baseQueue, queue: S3.queue, next: null };
        T5 === null ? R5.memoizedState = T5 = a9 : T5 = T5.next = a9;
      }
      return T5;
    }
    function Jh(a9, b7) {
      return typeof b7 === "function" ? b7(a9) : b7;
    }
    function Kh(a9) {
      var b7 = Ih(), c7 = b7.queue;
      if (c7 === null)
        throw Error(y4(311));
      c7.lastRenderedReducer = a9;
      var d8 = S3, e12 = d8.baseQueue, f11 = c7.pending;
      if (f11 !== null) {
        if (e12 !== null) {
          var g5 = e12.next;
          e12.next = f11.next;
          f11.next = g5;
        }
        d8.baseQueue = e12 = f11;
        c7.pending = null;
      }
      if (e12 !== null) {
        e12 = e12.next;
        d8 = d8.baseState;
        var h3 = g5 = f11 = null, k3 = e12;
        do {
          var l9 = k3.lane;
          if ((xh & l9) === l9)
            h3 !== null && (h3 = h3.next = { lane: 0, action: k3.action, eagerReducer: k3.eagerReducer, eagerState: k3.eagerState, next: null }), d8 = k3.eagerReducer === a9 ? k3.eagerState : a9(d8, k3.action);
          else {
            var n6 = {
              lane: l9,
              action: k3.action,
              eagerReducer: k3.eagerReducer,
              eagerState: k3.eagerState,
              next: null
            };
            h3 === null ? (g5 = h3 = n6, f11 = d8) : h3 = h3.next = n6;
            R5.lanes |= l9;
            Dg |= l9;
          }
          k3 = k3.next;
        } while (k3 !== null && k3 !== e12);
        h3 === null ? f11 = d8 : h3.next = g5;
        He(d8, b7.memoizedState) || (ug = true);
        b7.memoizedState = d8;
        b7.baseState = f11;
        b7.baseQueue = h3;
        c7.lastRenderedState = d8;
      }
      return [b7.memoizedState, c7.dispatch];
    }
    function Lh(a9) {
      var b7 = Ih(), c7 = b7.queue;
      if (c7 === null)
        throw Error(y4(311));
      c7.lastRenderedReducer = a9;
      var d8 = c7.dispatch, e12 = c7.pending, f11 = b7.memoizedState;
      if (e12 !== null) {
        c7.pending = null;
        var g5 = e12 = e12.next;
        do
          f11 = a9(f11, g5.action), g5 = g5.next;
        while (g5 !== e12);
        He(f11, b7.memoizedState) || (ug = true);
        b7.memoizedState = f11;
        b7.baseQueue === null && (b7.baseState = f11);
        c7.lastRenderedState = f11;
      }
      return [f11, d8];
    }
    function Mh(a9, b7, c7) {
      var d8 = b7._getVersion;
      d8 = d8(b7._source);
      var e12 = b7._workInProgressVersionPrimary;
      if (e12 !== null)
        a9 = e12 === d8;
      else if (a9 = a9.mutableReadLanes, a9 = (xh & a9) === a9)
        b7._workInProgressVersionPrimary = d8, th.push(b7);
      if (a9)
        return c7(b7._source);
      th.push(b7);
      throw Error(y4(350));
    }
    function Nh(a9, b7, c7, d8) {
      var e12 = U3;
      if (e12 === null)
        throw Error(y4(349));
      var f11 = b7._getVersion, g5 = f11(b7._source), h3 = vh.current, k3 = h3.useState(function() {
        return Mh(e12, b7, c7);
      }), l9 = k3[1], n6 = k3[0];
      k3 = T5;
      var A4 = a9.memoizedState, p7 = A4.refs, C6 = p7.getSnapshot, x5 = A4.source;
      A4 = A4.subscribe;
      var w6 = R5;
      a9.memoizedState = { refs: p7, source: b7, subscribe: d8 };
      h3.useEffect(function() {
        p7.getSnapshot = c7;
        p7.setSnapshot = l9;
        var a10 = f11(b7._source);
        if (!He(g5, a10)) {
          a10 = c7(b7._source);
          He(n6, a10) || (l9(a10), a10 = Ig(w6), e12.mutableReadLanes |= a10 & e12.pendingLanes);
          a10 = e12.mutableReadLanes;
          e12.entangledLanes |= a10;
          for (var d9 = e12.entanglements, h4 = a10; 0 < h4; ) {
            var k4 = 31 - Vc(h4), v6 = 1 << k4;
            d9[k4] |= a10;
            h4 &= ~v6;
          }
        }
      }, [c7, b7, d8]);
      h3.useEffect(function() {
        return d8(b7._source, function() {
          var a10 = p7.getSnapshot, c8 = p7.setSnapshot;
          try {
            c8(a10(b7._source));
            var d9 = Ig(w6);
            e12.mutableReadLanes |= d9 & e12.pendingLanes;
          } catch (q3) {
            c8(function() {
              throw q3;
            });
          }
        });
      }, [b7, d8]);
      He(C6, c7) && He(x5, b7) && He(A4, d8) || (a9 = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n6 }, a9.dispatch = l9 = Oh.bind(null, R5, a9), k3.queue = a9, k3.baseQueue = null, n6 = Mh(e12, b7, c7), k3.memoizedState = k3.baseState = n6);
      return n6;
    }
    function Ph(a9, b7, c7) {
      var d8 = Ih();
      return Nh(d8, a9, b7, c7);
    }
    function Qh(a9) {
      var b7 = Hh();
      typeof a9 === "function" && (a9 = a9());
      b7.memoizedState = b7.baseState = a9;
      a9 = b7.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a9 };
      a9 = a9.dispatch = Oh.bind(null, R5, a9);
      return [b7.memoizedState, a9];
    }
    function Rh(a9, b7, c7, d8) {
      a9 = { tag: a9, create: b7, destroy: c7, deps: d8, next: null };
      b7 = R5.updateQueue;
      b7 === null ? (b7 = { lastEffect: null }, R5.updateQueue = b7, b7.lastEffect = a9.next = a9) : (c7 = b7.lastEffect, c7 === null ? b7.lastEffect = a9.next = a9 : (d8 = c7.next, c7.next = a9, a9.next = d8, b7.lastEffect = a9));
      return a9;
    }
    function Sh(a9) {
      var b7 = Hh();
      a9 = { current: a9 };
      return b7.memoizedState = a9;
    }
    function Th() {
      return Ih().memoizedState;
    }
    function Uh(a9, b7, c7, d8) {
      var e12 = Hh();
      R5.flags |= a9;
      e12.memoizedState = Rh(1 | b7, c7, void 0, d8 === void 0 ? null : d8);
    }
    function Vh(a9, b7, c7, d8) {
      var e12 = Ih();
      d8 = d8 === void 0 ? null : d8;
      var f11 = void 0;
      if (S3 !== null) {
        var g5 = S3.memoizedState;
        f11 = g5.destroy;
        if (d8 !== null && Bh(d8, g5.deps)) {
          Rh(b7, c7, f11, d8);
          return;
        }
      }
      R5.flags |= a9;
      e12.memoizedState = Rh(1 | b7, c7, f11, d8);
    }
    function Wh(a9, b7) {
      return Uh(516, 4, a9, b7);
    }
    function Xh(a9, b7) {
      return Vh(516, 4, a9, b7);
    }
    function Yh(a9, b7) {
      return Vh(4, 2, a9, b7);
    }
    function Zh(a9, b7) {
      if (typeof b7 === "function")
        return a9 = a9(), b7(a9), function() {
          b7(null);
        };
      if (b7 !== null && b7 !== void 0)
        return a9 = a9(), b7.current = a9, function() {
          b7.current = null;
        };
    }
    function $h(a9, b7, c7) {
      c7 = c7 !== null && c7 !== void 0 ? c7.concat([a9]) : null;
      return Vh(4, 2, Zh.bind(null, b7, a9), c7);
    }
    function ai() {
    }
    function bi(a9, b7) {
      var c7 = Ih();
      b7 = b7 === void 0 ? null : b7;
      var d8 = c7.memoizedState;
      if (d8 !== null && b7 !== null && Bh(b7, d8[1]))
        return d8[0];
      c7.memoizedState = [a9, b7];
      return a9;
    }
    function ci(a9, b7) {
      var c7 = Ih();
      b7 = b7 === void 0 ? null : b7;
      var d8 = c7.memoizedState;
      if (d8 !== null && b7 !== null && Bh(b7, d8[1]))
        return d8[0];
      a9 = a9();
      c7.memoizedState = [a9, b7];
      return a9;
    }
    function di(a9, b7) {
      var c7 = eg();
      gg(98 > c7 ? 98 : c7, function() {
        a9(true);
      });
      gg(97 < c7 ? 97 : c7, function() {
        var c8 = wh.transition;
        wh.transition = 1;
        try {
          a9(false), b7();
        } finally {
          wh.transition = c8;
        }
      });
    }
    function Oh(a9, b7, c7) {
      var d8 = Hg(), e12 = Ig(a9), f11 = { lane: e12, action: c7, eagerReducer: null, eagerState: null, next: null }, g5 = b7.pending;
      g5 === null ? f11.next = f11 : (f11.next = g5.next, g5.next = f11);
      b7.pending = f11;
      g5 = a9.alternate;
      if (a9 === R5 || g5 !== null && g5 === R5)
        zh = yh = true;
      else {
        if (a9.lanes === 0 && (g5 === null || g5.lanes === 0) && (g5 = b7.lastRenderedReducer, g5 !== null))
          try {
            var h3 = b7.lastRenderedState, k3 = g5(h3, c7);
            f11.eagerReducer = g5;
            f11.eagerState = k3;
            if (He(k3, h3))
              return;
          } catch (l9) {
          } finally {
          }
        Jg(a9, e12, d8);
      }
    }
    var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false };
    var Dh = { readContext: vg, useCallback: function(a9, b7) {
      Hh().memoizedState = [a9, b7 === void 0 ? null : b7];
      return a9;
    }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a9, b7, c7) {
      c7 = c7 !== null && c7 !== void 0 ? c7.concat([a9]) : null;
      return Uh(4, 2, Zh.bind(null, b7, a9), c7);
    }, useLayoutEffect: function(a9, b7) {
      return Uh(4, 2, a9, b7);
    }, useMemo: function(a9, b7) {
      var c7 = Hh();
      b7 = b7 === void 0 ? null : b7;
      a9 = a9();
      c7.memoizedState = [a9, b7];
      return a9;
    }, useReducer: function(a9, b7, c7) {
      var d8 = Hh();
      b7 = c7 !== void 0 ? c7(b7) : b7;
      d8.memoizedState = d8.baseState = b7;
      a9 = d8.queue = { pending: null, dispatch: null, lastRenderedReducer: a9, lastRenderedState: b7 };
      a9 = a9.dispatch = Oh.bind(null, R5, a9);
      return [d8.memoizedState, a9];
    }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a9) {
      var b7 = Qh(a9), c7 = b7[0], d8 = b7[1];
      Wh(function() {
        var b8 = wh.transition;
        wh.transition = 1;
        try {
          d8(a9);
        } finally {
          wh.transition = b8;
        }
      }, [a9]);
      return c7;
    }, useTransition: function() {
      var a9 = Qh(false), b7 = a9[0];
      a9 = di.bind(null, a9[1]);
      Sh(a9);
      return [a9, b7];
    }, useMutableSource: function(a9, b7, c7) {
      var d8 = Hh();
      d8.memoizedState = { refs: { getSnapshot: b7, setSnapshot: null }, source: a9, subscribe: c7 };
      return Nh(d8, a9, b7, c7);
    }, useOpaqueIdentifier: function() {
      if (lh) {
        var a9 = false, b7 = uf(function() {
          a9 || (a9 = true, c7("r:" + (tf++).toString(36)));
          throw Error(y4(355));
        }), c7 = Qh(b7)[1];
        (R5.mode & 2) === 0 && (R5.flags |= 516, Rh(5, function() {
          c7("r:" + (tf++).toString(36));
        }, void 0, null));
        return b7;
      }
      b7 = "r:" + (tf++).toString(36);
      Qh(b7);
      return b7;
    }, unstable_isNewReconciler: false };
    var Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
      return Kh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a9) {
      var b7 = Kh(Jh), c7 = b7[0], d8 = b7[1];
      Xh(function() {
        var b8 = wh.transition;
        wh.transition = 1;
        try {
          d8(a9);
        } finally {
          wh.transition = b8;
        }
      }, [a9]);
      return c7;
    }, useTransition: function() {
      var a9 = Kh(Jh)[0];
      return [
        Th().current,
        a9
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Kh(Jh)[0];
    }, unstable_isNewReconciler: false };
    var Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
      return Lh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a9) {
      var b7 = Lh(Jh), c7 = b7[0], d8 = b7[1];
      Xh(function() {
        var b8 = wh.transition;
        wh.transition = 1;
        try {
          d8(a9);
        } finally {
          wh.transition = b8;
        }
      }, [a9]);
      return c7;
    }, useTransition: function() {
      var a9 = Lh(Jh)[0];
      return [
        Th().current,
        a9
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Lh(Jh)[0];
    }, unstable_isNewReconciler: false };
    var ei = ra.ReactCurrentOwner;
    var ug = false;
    function fi(a9, b7, c7, d8) {
      b7.child = a9 === null ? Zg(b7, null, c7, d8) : Yg(b7, a9.child, c7, d8);
    }
    function gi(a9, b7, c7, d8, e12) {
      c7 = c7.render;
      var f11 = b7.ref;
      tg(b7, e12);
      d8 = Ch(a9, b7, c7, d8, f11, e12);
      if (a9 !== null && !ug)
        return b7.updateQueue = a9.updateQueue, b7.flags &= -517, a9.lanes &= ~e12, hi(a9, b7, e12);
      b7.flags |= 1;
      fi(a9, b7, d8, e12);
      return b7.child;
    }
    function ii(a9, b7, c7, d8, e12, f11) {
      if (a9 === null) {
        var g5 = c7.type;
        if (typeof g5 === "function" && !ji(g5) && g5.defaultProps === void 0 && c7.compare === null && c7.defaultProps === void 0)
          return b7.tag = 15, b7.type = g5, ki(a9, b7, g5, d8, e12, f11);
        a9 = Vg(c7.type, null, d8, b7, b7.mode, f11);
        a9.ref = b7.ref;
        a9.return = b7;
        return b7.child = a9;
      }
      g5 = a9.child;
      if ((e12 & f11) === 0 && (e12 = g5.memoizedProps, c7 = c7.compare, c7 = c7 !== null ? c7 : Je, c7(e12, d8) && a9.ref === b7.ref))
        return hi(a9, b7, f11);
      b7.flags |= 1;
      a9 = Tg(g5, d8);
      a9.ref = b7.ref;
      a9.return = b7;
      return b7.child = a9;
    }
    function ki(a9, b7, c7, d8, e12, f11) {
      if (a9 !== null && Je(a9.memoizedProps, d8) && a9.ref === b7.ref)
        if (ug = false, (f11 & e12) !== 0)
          (a9.flags & 16384) !== 0 && (ug = true);
        else
          return b7.lanes = a9.lanes, hi(a9, b7, f11);
      return li(a9, b7, c7, d8, f11);
    }
    function mi(a9, b7, c7) {
      var d8 = b7.pendingProps, e12 = d8.children, f11 = a9 !== null ? a9.memoizedState : null;
      if (d8.mode === "hidden" || d8.mode === "unstable-defer-without-hiding")
        if ((b7.mode & 4) === 0)
          b7.memoizedState = { baseLanes: 0 }, ni(b7, c7);
        else if ((c7 & 1073741824) !== 0)
          b7.memoizedState = { baseLanes: 0 }, ni(b7, f11 !== null ? f11.baseLanes : c7);
        else
          return a9 = f11 !== null ? f11.baseLanes | c7 : c7, b7.lanes = b7.childLanes = 1073741824, b7.memoizedState = { baseLanes: a9 }, ni(b7, a9), null;
      else
        f11 !== null ? (d8 = f11.baseLanes | c7, b7.memoizedState = null) : d8 = c7, ni(b7, d8);
      fi(a9, b7, e12, c7);
      return b7.child;
    }
    function oi(a9, b7) {
      var c7 = b7.ref;
      if (a9 === null && c7 !== null || a9 !== null && a9.ref !== c7)
        b7.flags |= 128;
    }
    function li(a9, b7, c7, d8, e12) {
      var f11 = Ff(c7) ? Df : M4.current;
      f11 = Ef(b7, f11);
      tg(b7, e12);
      c7 = Ch(a9, b7, c7, d8, f11, e12);
      if (a9 !== null && !ug)
        return b7.updateQueue = a9.updateQueue, b7.flags &= -517, a9.lanes &= ~e12, hi(a9, b7, e12);
      b7.flags |= 1;
      fi(a9, b7, c7, e12);
      return b7.child;
    }
    function pi(a9, b7, c7, d8, e12) {
      if (Ff(c7)) {
        var f11 = true;
        Jf(b7);
      } else
        f11 = false;
      tg(b7, e12);
      if (b7.stateNode === null)
        a9 !== null && (a9.alternate = null, b7.alternate = null, b7.flags |= 2), Mg(b7, c7, d8), Og(b7, c7, d8, e12), d8 = true;
      else if (a9 === null) {
        var g5 = b7.stateNode, h3 = b7.memoizedProps;
        g5.props = h3;
        var k3 = g5.context, l9 = c7.contextType;
        typeof l9 === "object" && l9 !== null ? l9 = vg(l9) : (l9 = Ff(c7) ? Df : M4.current, l9 = Ef(b7, l9));
        var n6 = c7.getDerivedStateFromProps, A4 = typeof n6 === "function" || typeof g5.getSnapshotBeforeUpdate === "function";
        A4 || typeof g5.UNSAFE_componentWillReceiveProps !== "function" && typeof g5.componentWillReceiveProps !== "function" || (h3 !== d8 || k3 !== l9) && Ng(b7, g5, d8, l9);
        wg = false;
        var p7 = b7.memoizedState;
        g5.state = p7;
        Cg(b7, d8, g5, e12);
        k3 = b7.memoizedState;
        h3 !== d8 || p7 !== k3 || N2.current || wg ? (typeof n6 === "function" && (Gg(b7, c7, n6, d8), k3 = b7.memoizedState), (h3 = wg || Lg(b7, c7, h3, d8, p7, k3, l9)) ? (A4 || typeof g5.UNSAFE_componentWillMount !== "function" && typeof g5.componentWillMount !== "function" || (typeof g5.componentWillMount === "function" && g5.componentWillMount(), typeof g5.UNSAFE_componentWillMount === "function" && g5.UNSAFE_componentWillMount()), typeof g5.componentDidMount === "function" && (b7.flags |= 4)) : (typeof g5.componentDidMount === "function" && (b7.flags |= 4), b7.memoizedProps = d8, b7.memoizedState = k3), g5.props = d8, g5.state = k3, g5.context = l9, d8 = h3) : (typeof g5.componentDidMount === "function" && (b7.flags |= 4), d8 = false);
      } else {
        g5 = b7.stateNode;
        yg(a9, b7);
        h3 = b7.memoizedProps;
        l9 = b7.type === b7.elementType ? h3 : lg(b7.type, h3);
        g5.props = l9;
        A4 = b7.pendingProps;
        p7 = g5.context;
        k3 = c7.contextType;
        typeof k3 === "object" && k3 !== null ? k3 = vg(k3) : (k3 = Ff(c7) ? Df : M4.current, k3 = Ef(b7, k3));
        var C6 = c7.getDerivedStateFromProps;
        (n6 = typeof C6 === "function" || typeof g5.getSnapshotBeforeUpdate === "function") || typeof g5.UNSAFE_componentWillReceiveProps !== "function" && typeof g5.componentWillReceiveProps !== "function" || (h3 !== A4 || p7 !== k3) && Ng(b7, g5, d8, k3);
        wg = false;
        p7 = b7.memoizedState;
        g5.state = p7;
        Cg(b7, d8, g5, e12);
        var x5 = b7.memoizedState;
        h3 !== A4 || p7 !== x5 || N2.current || wg ? (typeof C6 === "function" && (Gg(b7, c7, C6, d8), x5 = b7.memoizedState), (l9 = wg || Lg(b7, c7, l9, d8, p7, x5, k3)) ? (n6 || typeof g5.UNSAFE_componentWillUpdate !== "function" && typeof g5.componentWillUpdate !== "function" || (typeof g5.componentWillUpdate === "function" && g5.componentWillUpdate(d8, x5, k3), typeof g5.UNSAFE_componentWillUpdate === "function" && g5.UNSAFE_componentWillUpdate(d8, x5, k3)), typeof g5.componentDidUpdate === "function" && (b7.flags |= 4), typeof g5.getSnapshotBeforeUpdate === "function" && (b7.flags |= 256)) : (typeof g5.componentDidUpdate !== "function" || h3 === a9.memoizedProps && p7 === a9.memoizedState || (b7.flags |= 4), typeof g5.getSnapshotBeforeUpdate !== "function" || h3 === a9.memoizedProps && p7 === a9.memoizedState || (b7.flags |= 256), b7.memoizedProps = d8, b7.memoizedState = x5), g5.props = d8, g5.state = x5, g5.context = k3, d8 = l9) : (typeof g5.componentDidUpdate !== "function" || h3 === a9.memoizedProps && p7 === a9.memoizedState || (b7.flags |= 4), typeof g5.getSnapshotBeforeUpdate !== "function" || h3 === a9.memoizedProps && p7 === a9.memoizedState || (b7.flags |= 256), d8 = false);
      }
      return qi(a9, b7, c7, d8, f11, e12);
    }
    function qi(a9, b7, c7, d8, e12, f11) {
      oi(a9, b7);
      var g5 = (b7.flags & 64) !== 0;
      if (!d8 && !g5)
        return e12 && Kf(b7, c7, false), hi(a9, b7, f11);
      d8 = b7.stateNode;
      ei.current = b7;
      var h3 = g5 && typeof c7.getDerivedStateFromError !== "function" ? null : d8.render();
      b7.flags |= 1;
      a9 !== null && g5 ? (b7.child = Yg(b7, a9.child, null, f11), b7.child = Yg(b7, null, h3, f11)) : fi(a9, b7, h3, f11);
      b7.memoizedState = d8.state;
      e12 && Kf(b7, c7, true);
      return b7.child;
    }
    function ri(a9) {
      var b7 = a9.stateNode;
      b7.pendingContext ? Hf(a9, b7.pendingContext, b7.pendingContext !== b7.context) : b7.context && Hf(a9, b7.context, false);
      eh(a9, b7.containerInfo);
    }
    var si = { dehydrated: null, retryLane: 0 };
    function ti(a9, b7, c7) {
      var d8 = b7.pendingProps, e12 = P3.current, f11 = false, g5;
      (g5 = (b7.flags & 64) !== 0) || (g5 = a9 !== null && a9.memoizedState === null ? false : (e12 & 2) !== 0);
      g5 ? (f11 = true, b7.flags &= -65) : a9 !== null && a9.memoizedState === null || d8.fallback === void 0 || d8.unstable_avoidThisFallback === true || (e12 |= 1);
      I3(P3, e12 & 1);
      if (a9 === null) {
        d8.fallback !== void 0 && ph(b7);
        a9 = d8.children;
        e12 = d8.fallback;
        if (f11)
          return a9 = ui(b7, a9, e12, c7), b7.child.memoizedState = { baseLanes: c7 }, b7.memoizedState = si, a9;
        if (typeof d8.unstable_expectedLoadTime === "number")
          return a9 = ui(b7, a9, e12, c7), b7.child.memoizedState = { baseLanes: c7 }, b7.memoizedState = si, b7.lanes = 33554432, a9;
        c7 = vi({ mode: "visible", children: a9 }, b7.mode, c7, null);
        c7.return = b7;
        return b7.child = c7;
      }
      if (a9.memoizedState !== null) {
        if (f11)
          return d8 = wi(a9, b7, d8.children, d8.fallback, c7), f11 = b7.child, e12 = a9.child.memoizedState, f11.memoizedState = e12 === null ? { baseLanes: c7 } : { baseLanes: e12.baseLanes | c7 }, f11.childLanes = a9.childLanes & ~c7, b7.memoizedState = si, d8;
        c7 = xi(a9, b7, d8.children, c7);
        b7.memoizedState = null;
        return c7;
      }
      if (f11)
        return d8 = wi(a9, b7, d8.children, d8.fallback, c7), f11 = b7.child, e12 = a9.child.memoizedState, f11.memoizedState = e12 === null ? { baseLanes: c7 } : { baseLanes: e12.baseLanes | c7 }, f11.childLanes = a9.childLanes & ~c7, b7.memoizedState = si, d8;
      c7 = xi(a9, b7, d8.children, c7);
      b7.memoizedState = null;
      return c7;
    }
    function ui(a9, b7, c7, d8) {
      var e12 = a9.mode, f11 = a9.child;
      b7 = { mode: "hidden", children: b7 };
      (e12 & 2) === 0 && f11 !== null ? (f11.childLanes = 0, f11.pendingProps = b7) : f11 = vi(b7, e12, 0, null);
      c7 = Xg(c7, e12, d8, null);
      f11.return = a9;
      c7.return = a9;
      f11.sibling = c7;
      a9.child = f11;
      return c7;
    }
    function xi(a9, b7, c7, d8) {
      var e12 = a9.child;
      a9 = e12.sibling;
      c7 = Tg(e12, { mode: "visible", children: c7 });
      (b7.mode & 2) === 0 && (c7.lanes = d8);
      c7.return = b7;
      c7.sibling = null;
      a9 !== null && (a9.nextEffect = null, a9.flags = 8, b7.firstEffect = b7.lastEffect = a9);
      return b7.child = c7;
    }
    function wi(a9, b7, c7, d8, e12) {
      var f11 = b7.mode, g5 = a9.child;
      a9 = g5.sibling;
      var h3 = { mode: "hidden", children: c7 };
      (f11 & 2) === 0 && b7.child !== g5 ? (c7 = b7.child, c7.childLanes = 0, c7.pendingProps = h3, g5 = c7.lastEffect, g5 !== null ? (b7.firstEffect = c7.firstEffect, b7.lastEffect = g5, g5.nextEffect = null) : b7.firstEffect = b7.lastEffect = null) : c7 = Tg(g5, h3);
      a9 !== null ? d8 = Tg(a9, d8) : (d8 = Xg(d8, f11, e12, null), d8.flags |= 2);
      d8.return = b7;
      c7.return = b7;
      c7.sibling = d8;
      b7.child = c7;
      return d8;
    }
    function yi(a9, b7) {
      a9.lanes |= b7;
      var c7 = a9.alternate;
      c7 !== null && (c7.lanes |= b7);
      sg(a9.return, b7);
    }
    function zi(a9, b7, c7, d8, e12, f11) {
      var g5 = a9.memoizedState;
      g5 === null ? a9.memoizedState = { isBackwards: b7, rendering: null, renderingStartTime: 0, last: d8, tail: c7, tailMode: e12, lastEffect: f11 } : (g5.isBackwards = b7, g5.rendering = null, g5.renderingStartTime = 0, g5.last = d8, g5.tail = c7, g5.tailMode = e12, g5.lastEffect = f11);
    }
    function Ai(a9, b7, c7) {
      var d8 = b7.pendingProps, e12 = d8.revealOrder, f11 = d8.tail;
      fi(a9, b7, d8.children, c7);
      d8 = P3.current;
      if ((d8 & 2) !== 0)
        d8 = d8 & 1 | 2, b7.flags |= 64;
      else {
        if (a9 !== null && (a9.flags & 64) !== 0)
          a:
            for (a9 = b7.child; a9 !== null; ) {
              if (a9.tag === 13)
                a9.memoizedState !== null && yi(a9, c7);
              else if (a9.tag === 19)
                yi(a9, c7);
              else if (a9.child !== null) {
                a9.child.return = a9;
                a9 = a9.child;
                continue;
              }
              if (a9 === b7)
                break a;
              for (; a9.sibling === null; ) {
                if (a9.return === null || a9.return === b7)
                  break a;
                a9 = a9.return;
              }
              a9.sibling.return = a9.return;
              a9 = a9.sibling;
            }
        d8 &= 1;
      }
      I3(P3, d8);
      if ((b7.mode & 2) === 0)
        b7.memoizedState = null;
      else
        switch (e12) {
          case "forwards":
            c7 = b7.child;
            for (e12 = null; c7 !== null; )
              a9 = c7.alternate, a9 !== null && ih(a9) === null && (e12 = c7), c7 = c7.sibling;
            c7 = e12;
            c7 === null ? (e12 = b7.child, b7.child = null) : (e12 = c7.sibling, c7.sibling = null);
            zi(b7, false, e12, c7, f11, b7.lastEffect);
            break;
          case "backwards":
            c7 = null;
            e12 = b7.child;
            for (b7.child = null; e12 !== null; ) {
              a9 = e12.alternate;
              if (a9 !== null && ih(a9) === null) {
                b7.child = e12;
                break;
              }
              a9 = e12.sibling;
              e12.sibling = c7;
              c7 = e12;
              e12 = a9;
            }
            zi(b7, true, c7, null, f11, b7.lastEffect);
            break;
          case "together":
            zi(b7, false, null, null, void 0, b7.lastEffect);
            break;
          default:
            b7.memoizedState = null;
        }
      return b7.child;
    }
    function hi(a9, b7, c7) {
      a9 !== null && (b7.dependencies = a9.dependencies);
      Dg |= b7.lanes;
      if ((c7 & b7.childLanes) !== 0) {
        if (a9 !== null && b7.child !== a9.child)
          throw Error(y4(153));
        if (b7.child !== null) {
          a9 = b7.child;
          c7 = Tg(a9, a9.pendingProps);
          b7.child = c7;
          for (c7.return = b7; a9.sibling !== null; )
            a9 = a9.sibling, c7 = c7.sibling = Tg(a9, a9.pendingProps), c7.return = b7;
          c7.sibling = null;
        }
        return b7.child;
      }
      return null;
    }
    var Bi;
    var Ci;
    var Di;
    var Ei;
    Bi = function(a9, b7) {
      for (var c7 = b7.child; c7 !== null; ) {
        if (c7.tag === 5 || c7.tag === 6)
          a9.appendChild(c7.stateNode);
        else if (c7.tag !== 4 && c7.child !== null) {
          c7.child.return = c7;
          c7 = c7.child;
          continue;
        }
        if (c7 === b7)
          break;
        for (; c7.sibling === null; ) {
          if (c7.return === null || c7.return === b7)
            return;
          c7 = c7.return;
        }
        c7.sibling.return = c7.return;
        c7 = c7.sibling;
      }
    };
    Ci = function() {
    };
    Di = function(a9, b7, c7, d8) {
      var e12 = a9.memoizedProps;
      if (e12 !== d8) {
        a9 = b7.stateNode;
        dh(ah.current);
        var f11 = null;
        switch (c7) {
          case "input":
            e12 = Ya(a9, e12);
            d8 = Ya(a9, d8);
            f11 = [];
            break;
          case "option":
            e12 = eb(a9, e12);
            d8 = eb(a9, d8);
            f11 = [];
            break;
          case "select":
            e12 = m7({}, e12, { value: void 0 });
            d8 = m7({}, d8, { value: void 0 });
            f11 = [];
            break;
          case "textarea":
            e12 = gb(a9, e12);
            d8 = gb(a9, d8);
            f11 = [];
            break;
          default:
            typeof e12.onClick !== "function" && typeof d8.onClick === "function" && (a9.onclick = jf);
        }
        vb(c7, d8);
        var g5;
        c7 = null;
        for (l9 in e12)
          if (!d8.hasOwnProperty(l9) && e12.hasOwnProperty(l9) && e12[l9] != null)
            if (l9 === "style") {
              var h3 = e12[l9];
              for (g5 in h3)
                h3.hasOwnProperty(g5) && (c7 || (c7 = {}), c7[g5] = "");
            } else
              l9 !== "dangerouslySetInnerHTML" && l9 !== "children" && l9 !== "suppressContentEditableWarning" && l9 !== "suppressHydrationWarning" && l9 !== "autoFocus" && (ca.hasOwnProperty(l9) ? f11 || (f11 = []) : (f11 = f11 || []).push(l9, null));
        for (l9 in d8) {
          var k3 = d8[l9];
          h3 = e12 != null ? e12[l9] : void 0;
          if (d8.hasOwnProperty(l9) && k3 !== h3 && (k3 != null || h3 != null))
            if (l9 === "style")
              if (h3) {
                for (g5 in h3)
                  !h3.hasOwnProperty(g5) || k3 && k3.hasOwnProperty(g5) || (c7 || (c7 = {}), c7[g5] = "");
                for (g5 in k3)
                  k3.hasOwnProperty(g5) && h3[g5] !== k3[g5] && (c7 || (c7 = {}), c7[g5] = k3[g5]);
              } else
                c7 || (f11 || (f11 = []), f11.push(l9, c7)), c7 = k3;
            else
              l9 === "dangerouslySetInnerHTML" ? (k3 = k3 ? k3.__html : void 0, h3 = h3 ? h3.__html : void 0, k3 != null && h3 !== k3 && (f11 = f11 || []).push(l9, k3)) : l9 === "children" ? typeof k3 !== "string" && typeof k3 !== "number" || (f11 = f11 || []).push(l9, "" + k3) : l9 !== "suppressContentEditableWarning" && l9 !== "suppressHydrationWarning" && (ca.hasOwnProperty(l9) ? (k3 != null && l9 === "onScroll" && G4("scroll", a9), f11 || h3 === k3 || (f11 = [])) : typeof k3 === "object" && k3 !== null && k3.$$typeof === Ga ? k3.toString() : (f11 = f11 || []).push(l9, k3));
        }
        c7 && (f11 = f11 || []).push("style", c7);
        var l9 = f11;
        if (b7.updateQueue = l9)
          b7.flags |= 4;
      }
    };
    Ei = function(a9, b7, c7, d8) {
      c7 !== d8 && (b7.flags |= 4);
    };
    function Fi(a9, b7) {
      if (!lh)
        switch (a9.tailMode) {
          case "hidden":
            b7 = a9.tail;
            for (var c7 = null; b7 !== null; )
              b7.alternate !== null && (c7 = b7), b7 = b7.sibling;
            c7 === null ? a9.tail = null : c7.sibling = null;
            break;
          case "collapsed":
            c7 = a9.tail;
            for (var d8 = null; c7 !== null; )
              c7.alternate !== null && (d8 = c7), c7 = c7.sibling;
            d8 === null ? b7 || a9.tail === null ? a9.tail = null : a9.tail.sibling = null : d8.sibling = null;
        }
    }
    function Gi(a9, b7, c7) {
      var d8 = b7.pendingProps;
      switch (b7.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return null;
        case 1:
          return Ff(b7.type) && Gf(), null;
        case 3:
          fh();
          H3(N2);
          H3(M4);
          uh();
          d8 = b7.stateNode;
          d8.pendingContext && (d8.context = d8.pendingContext, d8.pendingContext = null);
          if (a9 === null || a9.child === null)
            rh(b7) ? b7.flags |= 4 : d8.hydrate || (b7.flags |= 256);
          Ci(b7);
          return null;
        case 5:
          hh(b7);
          var e12 = dh(ch.current);
          c7 = b7.type;
          if (a9 !== null && b7.stateNode != null)
            Di(a9, b7, c7, d8, e12), a9.ref !== b7.ref && (b7.flags |= 128);
          else {
            if (!d8) {
              if (b7.stateNode === null)
                throw Error(y4(166));
              return null;
            }
            a9 = dh(ah.current);
            if (rh(b7)) {
              d8 = b7.stateNode;
              c7 = b7.type;
              var f11 = b7.memoizedProps;
              d8[wf] = b7;
              d8[xf] = f11;
              switch (c7) {
                case "dialog":
                  G4("cancel", d8);
                  G4("close", d8);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G4("load", d8);
                  break;
                case "video":
                case "audio":
                  for (a9 = 0; a9 < Xe.length; a9++)
                    G4(Xe[a9], d8);
                  break;
                case "source":
                  G4("error", d8);
                  break;
                case "img":
                case "image":
                case "link":
                  G4("error", d8);
                  G4("load", d8);
                  break;
                case "details":
                  G4("toggle", d8);
                  break;
                case "input":
                  Za(d8, f11);
                  G4("invalid", d8);
                  break;
                case "select":
                  d8._wrapperState = { wasMultiple: !!f11.multiple };
                  G4("invalid", d8);
                  break;
                case "textarea":
                  hb(d8, f11), G4("invalid", d8);
              }
              vb(c7, f11);
              a9 = null;
              for (var g5 in f11)
                f11.hasOwnProperty(g5) && (e12 = f11[g5], g5 === "children" ? typeof e12 === "string" ? d8.textContent !== e12 && (a9 = ["children", e12]) : typeof e12 === "number" && d8.textContent !== "" + e12 && (a9 = ["children", "" + e12]) : ca.hasOwnProperty(g5) && e12 != null && g5 === "onScroll" && G4("scroll", d8));
              switch (c7) {
                case "input":
                  Va(d8);
                  cb(d8, f11, true);
                  break;
                case "textarea":
                  Va(d8);
                  jb(d8);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  typeof f11.onClick === "function" && (d8.onclick = jf);
              }
              d8 = a9;
              b7.updateQueue = d8;
              d8 !== null && (b7.flags |= 4);
            } else {
              g5 = e12.nodeType === 9 ? e12 : e12.ownerDocument;
              a9 === kb.html && (a9 = lb(c7));
              a9 === kb.html ? c7 === "script" ? (a9 = g5.createElement("div"), a9.innerHTML = "<script><\/script>", a9 = a9.removeChild(a9.firstChild)) : typeof d8.is === "string" ? a9 = g5.createElement(c7, { is: d8.is }) : (a9 = g5.createElement(c7), c7 === "select" && (g5 = a9, d8.multiple ? g5.multiple = true : d8.size && (g5.size = d8.size))) : a9 = g5.createElementNS(a9, c7);
              a9[wf] = b7;
              a9[xf] = d8;
              Bi(a9, b7, false, false);
              b7.stateNode = a9;
              g5 = wb(c7, d8);
              switch (c7) {
                case "dialog":
                  G4("cancel", a9);
                  G4("close", a9);
                  e12 = d8;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G4("load", a9);
                  e12 = d8;
                  break;
                case "video":
                case "audio":
                  for (e12 = 0; e12 < Xe.length; e12++)
                    G4(Xe[e12], a9);
                  e12 = d8;
                  break;
                case "source":
                  G4("error", a9);
                  e12 = d8;
                  break;
                case "img":
                case "image":
                case "link":
                  G4("error", a9);
                  G4("load", a9);
                  e12 = d8;
                  break;
                case "details":
                  G4("toggle", a9);
                  e12 = d8;
                  break;
                case "input":
                  Za(a9, d8);
                  e12 = Ya(a9, d8);
                  G4("invalid", a9);
                  break;
                case "option":
                  e12 = eb(a9, d8);
                  break;
                case "select":
                  a9._wrapperState = { wasMultiple: !!d8.multiple };
                  e12 = m7({}, d8, { value: void 0 });
                  G4("invalid", a9);
                  break;
                case "textarea":
                  hb(a9, d8);
                  e12 = gb(a9, d8);
                  G4("invalid", a9);
                  break;
                default:
                  e12 = d8;
              }
              vb(c7, e12);
              var h3 = e12;
              for (f11 in h3)
                if (h3.hasOwnProperty(f11)) {
                  var k3 = h3[f11];
                  f11 === "style" ? tb(a9, k3) : f11 === "dangerouslySetInnerHTML" ? (k3 = k3 ? k3.__html : void 0, k3 != null && ob(a9, k3)) : f11 === "children" ? typeof k3 === "string" ? (c7 !== "textarea" || k3 !== "") && pb(a9, k3) : typeof k3 === "number" && pb(a9, "" + k3) : f11 !== "suppressContentEditableWarning" && f11 !== "suppressHydrationWarning" && f11 !== "autoFocus" && (ca.hasOwnProperty(f11) ? k3 != null && f11 === "onScroll" && G4("scroll", a9) : k3 != null && qa(a9, f11, k3, g5));
                }
              switch (c7) {
                case "input":
                  Va(a9);
                  cb(a9, d8, false);
                  break;
                case "textarea":
                  Va(a9);
                  jb(a9);
                  break;
                case "option":
                  d8.value != null && a9.setAttribute("value", "" + Sa(d8.value));
                  break;
                case "select":
                  a9.multiple = !!d8.multiple;
                  f11 = d8.value;
                  f11 != null ? fb(a9, !!d8.multiple, f11, false) : d8.defaultValue != null && fb(a9, !!d8.multiple, d8.defaultValue, true);
                  break;
                default:
                  typeof e12.onClick === "function" && (a9.onclick = jf);
              }
              mf(c7, d8) && (b7.flags |= 4);
            }
            b7.ref !== null && (b7.flags |= 128);
          }
          return null;
        case 6:
          if (a9 && b7.stateNode != null)
            Ei(a9, b7, a9.memoizedProps, d8);
          else {
            if (typeof d8 !== "string" && b7.stateNode === null)
              throw Error(y4(166));
            c7 = dh(ch.current);
            dh(ah.current);
            rh(b7) ? (d8 = b7.stateNode, c7 = b7.memoizedProps, d8[wf] = b7, d8.nodeValue !== c7 && (b7.flags |= 4)) : (d8 = (c7.nodeType === 9 ? c7 : c7.ownerDocument).createTextNode(d8), d8[wf] = b7, b7.stateNode = d8);
          }
          return null;
        case 13:
          H3(P3);
          d8 = b7.memoizedState;
          if ((b7.flags & 64) !== 0)
            return b7.lanes = c7, b7;
          d8 = d8 !== null;
          c7 = false;
          a9 === null ? b7.memoizedProps.fallback !== void 0 && rh(b7) : c7 = a9.memoizedState !== null;
          if (d8 && !c7 && (b7.mode & 2) !== 0)
            if (a9 === null && b7.memoizedProps.unstable_avoidThisFallback !== true || (P3.current & 1) !== 0)
              V5 === 0 && (V5 = 3);
            else {
              if (V5 === 0 || V5 === 3)
                V5 = 4;
              U3 === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U3, W4);
            }
          if (d8 || c7)
            b7.flags |= 4;
          return null;
        case 4:
          return fh(), Ci(b7), a9 === null && cf(b7.stateNode.containerInfo), null;
        case 10:
          return rg(b7), null;
        case 17:
          return Ff(b7.type) && Gf(), null;
        case 19:
          H3(P3);
          d8 = b7.memoizedState;
          if (d8 === null)
            return null;
          f11 = (b7.flags & 64) !== 0;
          g5 = d8.rendering;
          if (g5 === null)
            if (f11)
              Fi(d8, false);
            else {
              if (V5 !== 0 || a9 !== null && (a9.flags & 64) !== 0)
                for (a9 = b7.child; a9 !== null; ) {
                  g5 = ih(a9);
                  if (g5 !== null) {
                    b7.flags |= 64;
                    Fi(d8, false);
                    f11 = g5.updateQueue;
                    f11 !== null && (b7.updateQueue = f11, b7.flags |= 4);
                    d8.lastEffect === null && (b7.firstEffect = null);
                    b7.lastEffect = d8.lastEffect;
                    d8 = c7;
                    for (c7 = b7.child; c7 !== null; )
                      f11 = c7, a9 = d8, f11.flags &= 2, f11.nextEffect = null, f11.firstEffect = null, f11.lastEffect = null, g5 = f11.alternate, g5 === null ? (f11.childLanes = 0, f11.lanes = a9, f11.child = null, f11.memoizedProps = null, f11.memoizedState = null, f11.updateQueue = null, f11.dependencies = null, f11.stateNode = null) : (f11.childLanes = g5.childLanes, f11.lanes = g5.lanes, f11.child = g5.child, f11.memoizedProps = g5.memoizedProps, f11.memoizedState = g5.memoizedState, f11.updateQueue = g5.updateQueue, f11.type = g5.type, a9 = g5.dependencies, f11.dependencies = a9 === null ? null : { lanes: a9.lanes, firstContext: a9.firstContext }), c7 = c7.sibling;
                    I3(P3, P3.current & 1 | 2);
                    return b7.child;
                  }
                  a9 = a9.sibling;
                }
              d8.tail !== null && O5() > Ji && (b7.flags |= 64, f11 = true, Fi(d8, false), b7.lanes = 33554432);
            }
          else {
            if (!f11)
              if (a9 = ih(g5), a9 !== null) {
                if (b7.flags |= 64, f11 = true, c7 = a9.updateQueue, c7 !== null && (b7.updateQueue = c7, b7.flags |= 4), Fi(d8, true), d8.tail === null && d8.tailMode === "hidden" && !g5.alternate && !lh)
                  return b7 = b7.lastEffect = d8.lastEffect, b7 !== null && (b7.nextEffect = null), null;
              } else
                2 * O5() - d8.renderingStartTime > Ji && c7 !== 1073741824 && (b7.flags |= 64, f11 = true, Fi(d8, false), b7.lanes = 33554432);
            d8.isBackwards ? (g5.sibling = b7.child, b7.child = g5) : (c7 = d8.last, c7 !== null ? c7.sibling = g5 : b7.child = g5, d8.last = g5);
          }
          return d8.tail !== null ? (c7 = d8.tail, d8.rendering = c7, d8.tail = c7.sibling, d8.lastEffect = b7.lastEffect, d8.renderingStartTime = O5(), c7.sibling = null, b7 = P3.current, I3(P3, f11 ? b7 & 1 | 2 : b7 & 1), c7) : null;
        case 23:
        case 24:
          return Ki(), a9 !== null && a9.memoizedState !== null !== (b7.memoizedState !== null) && d8.mode !== "unstable-defer-without-hiding" && (b7.flags |= 4), null;
      }
      throw Error(y4(156, b7.tag));
    }
    function Li(a9) {
      switch (a9.tag) {
        case 1:
          Ff(a9.type) && Gf();
          var b7 = a9.flags;
          return b7 & 4096 ? (a9.flags = b7 & -4097 | 64, a9) : null;
        case 3:
          fh();
          H3(N2);
          H3(M4);
          uh();
          b7 = a9.flags;
          if ((b7 & 64) !== 0)
            throw Error(y4(285));
          a9.flags = b7 & -4097 | 64;
          return a9;
        case 5:
          return hh(a9), null;
        case 13:
          return H3(P3), b7 = a9.flags, b7 & 4096 ? (a9.flags = b7 & -4097 | 64, a9) : null;
        case 19:
          return H3(P3), null;
        case 4:
          return fh(), null;
        case 10:
          return rg(a9), null;
        case 23:
        case 24:
          return Ki(), null;
        default:
          return null;
      }
    }
    function Mi(a9, b7) {
      try {
        var c7 = "", d8 = b7;
        do
          c7 += Qa(d8), d8 = d8.return;
        while (d8);
        var e12 = c7;
      } catch (f11) {
        e12 = "\nError generating stack: " + f11.message + "\n" + f11.stack;
      }
      return { value: a9, source: b7, stack: e12 };
    }
    function Ni(a9, b7) {
      try {
        console.error(b7.value);
      } catch (c7) {
        setTimeout(function() {
          throw c7;
        });
      }
    }
    var Oi = typeof WeakMap === "function" ? WeakMap : Map;
    function Pi(a9, b7, c7) {
      c7 = zg(-1, c7);
      c7.tag = 3;
      c7.payload = { element: null };
      var d8 = b7.value;
      c7.callback = function() {
        Qi || (Qi = true, Ri = d8);
        Ni(a9, b7);
      };
      return c7;
    }
    function Si(a9, b7, c7) {
      c7 = zg(-1, c7);
      c7.tag = 3;
      var d8 = a9.type.getDerivedStateFromError;
      if (typeof d8 === "function") {
        var e12 = b7.value;
        c7.payload = function() {
          Ni(a9, b7);
          return d8(e12);
        };
      }
      var f11 = a9.stateNode;
      f11 !== null && typeof f11.componentDidCatch === "function" && (c7.callback = function() {
        typeof d8 !== "function" && (Ti === null ? Ti = new Set([this]) : Ti.add(this), Ni(a9, b7));
        var c8 = b7.stack;
        this.componentDidCatch(b7.value, { componentStack: c8 !== null ? c8 : "" });
      });
      return c7;
    }
    var Ui = typeof WeakSet === "function" ? WeakSet : Set;
    function Vi(a9) {
      var b7 = a9.ref;
      if (b7 !== null)
        if (typeof b7 === "function")
          try {
            b7(null);
          } catch (c7) {
            Wi(a9, c7);
          }
        else
          b7.current = null;
    }
    function Xi(a9, b7) {
      switch (b7.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          return;
        case 1:
          if (b7.flags & 256 && a9 !== null) {
            var c7 = a9.memoizedProps, d8 = a9.memoizedState;
            a9 = b7.stateNode;
            b7 = a9.getSnapshotBeforeUpdate(b7.elementType === b7.type ? c7 : lg(b7.type, c7), d8);
            a9.__reactInternalSnapshotBeforeUpdate = b7;
          }
          return;
        case 3:
          b7.flags & 256 && qf(b7.stateNode.containerInfo);
          return;
        case 5:
        case 6:
        case 4:
        case 17:
          return;
      }
      throw Error(y4(163));
    }
    function Yi(a9, b7, c7) {
      switch (c7.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          b7 = c7.updateQueue;
          b7 = b7 !== null ? b7.lastEffect : null;
          if (b7 !== null) {
            a9 = b7 = b7.next;
            do {
              if ((a9.tag & 3) === 3) {
                var d8 = a9.create;
                a9.destroy = d8();
              }
              a9 = a9.next;
            } while (a9 !== b7);
          }
          b7 = c7.updateQueue;
          b7 = b7 !== null ? b7.lastEffect : null;
          if (b7 !== null) {
            a9 = b7 = b7.next;
            do {
              var e12 = a9;
              d8 = e12.next;
              e12 = e12.tag;
              (e12 & 4) !== 0 && (e12 & 1) !== 0 && (Zi(c7, a9), $i(c7, a9));
              a9 = d8;
            } while (a9 !== b7);
          }
          return;
        case 1:
          a9 = c7.stateNode;
          c7.flags & 4 && (b7 === null ? a9.componentDidMount() : (d8 = c7.elementType === c7.type ? b7.memoizedProps : lg(c7.type, b7.memoizedProps), a9.componentDidUpdate(d8, b7.memoizedState, a9.__reactInternalSnapshotBeforeUpdate)));
          b7 = c7.updateQueue;
          b7 !== null && Eg(c7, b7, a9);
          return;
        case 3:
          b7 = c7.updateQueue;
          if (b7 !== null) {
            a9 = null;
            if (c7.child !== null)
              switch (c7.child.tag) {
                case 5:
                  a9 = c7.child.stateNode;
                  break;
                case 1:
                  a9 = c7.child.stateNode;
              }
            Eg(c7, b7, a9);
          }
          return;
        case 5:
          a9 = c7.stateNode;
          b7 === null && c7.flags & 4 && mf(c7.type, c7.memoizedProps) && a9.focus();
          return;
        case 6:
          return;
        case 4:
          return;
        case 12:
          return;
        case 13:
          c7.memoizedState === null && (c7 = c7.alternate, c7 !== null && (c7 = c7.memoizedState, c7 !== null && (c7 = c7.dehydrated, c7 !== null && Cc(c7))));
          return;
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
          return;
      }
      throw Error(y4(163));
    }
    function aj(a9, b7) {
      for (var c7 = a9; ; ) {
        if (c7.tag === 5) {
          var d8 = c7.stateNode;
          if (b7)
            d8 = d8.style, typeof d8.setProperty === "function" ? d8.setProperty("display", "none", "important") : d8.display = "none";
          else {
            d8 = c7.stateNode;
            var e12 = c7.memoizedProps.style;
            e12 = e12 !== void 0 && e12 !== null && e12.hasOwnProperty("display") ? e12.display : null;
            d8.style.display = sb("display", e12);
          }
        } else if (c7.tag === 6)
          c7.stateNode.nodeValue = b7 ? "" : c7.memoizedProps;
        else if ((c7.tag !== 23 && c7.tag !== 24 || c7.memoizedState === null || c7 === a9) && c7.child !== null) {
          c7.child.return = c7;
          c7 = c7.child;
          continue;
        }
        if (c7 === a9)
          break;
        for (; c7.sibling === null; ) {
          if (c7.return === null || c7.return === a9)
            return;
          c7 = c7.return;
        }
        c7.sibling.return = c7.return;
        c7 = c7.sibling;
      }
    }
    function bj(a9, b7) {
      if (Mf && typeof Mf.onCommitFiberUnmount === "function")
        try {
          Mf.onCommitFiberUnmount(Lf, b7);
        } catch (f11) {
        }
      switch (b7.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          a9 = b7.updateQueue;
          if (a9 !== null && (a9 = a9.lastEffect, a9 !== null)) {
            var c7 = a9 = a9.next;
            do {
              var d8 = c7, e12 = d8.destroy;
              d8 = d8.tag;
              if (e12 !== void 0)
                if ((d8 & 4) !== 0)
                  Zi(b7, c7);
                else {
                  d8 = b7;
                  try {
                    e12();
                  } catch (f11) {
                    Wi(d8, f11);
                  }
                }
              c7 = c7.next;
            } while (c7 !== a9);
          }
          break;
        case 1:
          Vi(b7);
          a9 = b7.stateNode;
          if (typeof a9.componentWillUnmount === "function")
            try {
              a9.props = b7.memoizedProps, a9.state = b7.memoizedState, a9.componentWillUnmount();
            } catch (f11) {
              Wi(b7, f11);
            }
          break;
        case 5:
          Vi(b7);
          break;
        case 4:
          cj(a9, b7);
      }
    }
    function dj(a9) {
      a9.alternate = null;
      a9.child = null;
      a9.dependencies = null;
      a9.firstEffect = null;
      a9.lastEffect = null;
      a9.memoizedProps = null;
      a9.memoizedState = null;
      a9.pendingProps = null;
      a9.return = null;
      a9.updateQueue = null;
    }
    function ej(a9) {
      return a9.tag === 5 || a9.tag === 3 || a9.tag === 4;
    }
    function fj(a9) {
      a: {
        for (var b7 = a9.return; b7 !== null; ) {
          if (ej(b7))
            break a;
          b7 = b7.return;
        }
        throw Error(y4(160));
      }
      var c7 = b7;
      b7 = c7.stateNode;
      switch (c7.tag) {
        case 5:
          var d8 = false;
          break;
        case 3:
          b7 = b7.containerInfo;
          d8 = true;
          break;
        case 4:
          b7 = b7.containerInfo;
          d8 = true;
          break;
        default:
          throw Error(y4(161));
      }
      c7.flags & 16 && (pb(b7, ""), c7.flags &= -17);
      a:
        b:
          for (c7 = a9; ; ) {
            for (; c7.sibling === null; ) {
              if (c7.return === null || ej(c7.return)) {
                c7 = null;
                break a;
              }
              c7 = c7.return;
            }
            c7.sibling.return = c7.return;
            for (c7 = c7.sibling; c7.tag !== 5 && c7.tag !== 6 && c7.tag !== 18; ) {
              if (c7.flags & 2)
                continue b;
              if (c7.child === null || c7.tag === 4)
                continue b;
              else
                c7.child.return = c7, c7 = c7.child;
            }
            if (!(c7.flags & 2)) {
              c7 = c7.stateNode;
              break a;
            }
          }
      d8 ? gj(a9, c7, b7) : hj(a9, c7, b7);
    }
    function gj(a9, b7, c7) {
      var d8 = a9.tag, e12 = d8 === 5 || d8 === 6;
      if (e12)
        a9 = e12 ? a9.stateNode : a9.stateNode.instance, b7 ? c7.nodeType === 8 ? c7.parentNode.insertBefore(a9, b7) : c7.insertBefore(a9, b7) : (c7.nodeType === 8 ? (b7 = c7.parentNode, b7.insertBefore(a9, c7)) : (b7 = c7, b7.appendChild(a9)), c7 = c7._reactRootContainer, c7 !== null && c7 !== void 0 || b7.onclick !== null || (b7.onclick = jf));
      else if (d8 !== 4 && (a9 = a9.child, a9 !== null))
        for (gj(a9, b7, c7), a9 = a9.sibling; a9 !== null; )
          gj(a9, b7, c7), a9 = a9.sibling;
    }
    function hj(a9, b7, c7) {
      var d8 = a9.tag, e12 = d8 === 5 || d8 === 6;
      if (e12)
        a9 = e12 ? a9.stateNode : a9.stateNode.instance, b7 ? c7.insertBefore(a9, b7) : c7.appendChild(a9);
      else if (d8 !== 4 && (a9 = a9.child, a9 !== null))
        for (hj(a9, b7, c7), a9 = a9.sibling; a9 !== null; )
          hj(a9, b7, c7), a9 = a9.sibling;
    }
    function cj(a9, b7) {
      for (var c7 = b7, d8 = false, e12, f11; ; ) {
        if (!d8) {
          d8 = c7.return;
          a:
            for (; ; ) {
              if (d8 === null)
                throw Error(y4(160));
              e12 = d8.stateNode;
              switch (d8.tag) {
                case 5:
                  f11 = false;
                  break a;
                case 3:
                  e12 = e12.containerInfo;
                  f11 = true;
                  break a;
                case 4:
                  e12 = e12.containerInfo;
                  f11 = true;
                  break a;
              }
              d8 = d8.return;
            }
          d8 = true;
        }
        if (c7.tag === 5 || c7.tag === 6) {
          a:
            for (var g5 = a9, h3 = c7, k3 = h3; ; )
              if (bj(g5, k3), k3.child !== null && k3.tag !== 4)
                k3.child.return = k3, k3 = k3.child;
              else {
                if (k3 === h3)
                  break a;
                for (; k3.sibling === null; ) {
                  if (k3.return === null || k3.return === h3)
                    break a;
                  k3 = k3.return;
                }
                k3.sibling.return = k3.return;
                k3 = k3.sibling;
              }
          f11 ? (g5 = e12, h3 = c7.stateNode, g5.nodeType === 8 ? g5.parentNode.removeChild(h3) : g5.removeChild(h3)) : e12.removeChild(c7.stateNode);
        } else if (c7.tag === 4) {
          if (c7.child !== null) {
            e12 = c7.stateNode.containerInfo;
            f11 = true;
            c7.child.return = c7;
            c7 = c7.child;
            continue;
          }
        } else if (bj(a9, c7), c7.child !== null) {
          c7.child.return = c7;
          c7 = c7.child;
          continue;
        }
        if (c7 === b7)
          break;
        for (; c7.sibling === null; ) {
          if (c7.return === null || c7.return === b7)
            return;
          c7 = c7.return;
          c7.tag === 4 && (d8 = false);
        }
        c7.sibling.return = c7.return;
        c7 = c7.sibling;
      }
    }
    function ij(a9, b7) {
      switch (b7.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          var c7 = b7.updateQueue;
          c7 = c7 !== null ? c7.lastEffect : null;
          if (c7 !== null) {
            var d8 = c7 = c7.next;
            do
              (d8.tag & 3) === 3 && (a9 = d8.destroy, d8.destroy = void 0, a9 !== void 0 && a9()), d8 = d8.next;
            while (d8 !== c7);
          }
          return;
        case 1:
          return;
        case 5:
          c7 = b7.stateNode;
          if (c7 != null) {
            d8 = b7.memoizedProps;
            var e12 = a9 !== null ? a9.memoizedProps : d8;
            a9 = b7.type;
            var f11 = b7.updateQueue;
            b7.updateQueue = null;
            if (f11 !== null) {
              c7[xf] = d8;
              a9 === "input" && d8.type === "radio" && d8.name != null && $a(c7, d8);
              wb(a9, e12);
              b7 = wb(a9, d8);
              for (e12 = 0; e12 < f11.length; e12 += 2) {
                var g5 = f11[e12], h3 = f11[e12 + 1];
                g5 === "style" ? tb(c7, h3) : g5 === "dangerouslySetInnerHTML" ? ob(c7, h3) : g5 === "children" ? pb(c7, h3) : qa(c7, g5, h3, b7);
              }
              switch (a9) {
                case "input":
                  ab(c7, d8);
                  break;
                case "textarea":
                  ib(c7, d8);
                  break;
                case "select":
                  a9 = c7._wrapperState.wasMultiple, c7._wrapperState.wasMultiple = !!d8.multiple, f11 = d8.value, f11 != null ? fb(c7, !!d8.multiple, f11, false) : a9 !== !!d8.multiple && (d8.defaultValue != null ? fb(c7, !!d8.multiple, d8.defaultValue, true) : fb(c7, !!d8.multiple, d8.multiple ? [] : "", false));
              }
            }
          }
          return;
        case 6:
          if (b7.stateNode === null)
            throw Error(y4(162));
          b7.stateNode.nodeValue = b7.memoizedProps;
          return;
        case 3:
          c7 = b7.stateNode;
          c7.hydrate && (c7.hydrate = false, Cc(c7.containerInfo));
          return;
        case 12:
          return;
        case 13:
          b7.memoizedState !== null && (jj = O5(), aj(b7.child, true));
          kj(b7);
          return;
        case 19:
          kj(b7);
          return;
        case 17:
          return;
        case 23:
        case 24:
          aj(b7, b7.memoizedState !== null);
          return;
      }
      throw Error(y4(163));
    }
    function kj(a9) {
      var b7 = a9.updateQueue;
      if (b7 !== null) {
        a9.updateQueue = null;
        var c7 = a9.stateNode;
        c7 === null && (c7 = a9.stateNode = new Ui());
        b7.forEach(function(b8) {
          var d8 = lj.bind(null, a9, b8);
          c7.has(b8) || (c7.add(b8), b8.then(d8, d8));
        });
      }
    }
    function mj(a9, b7) {
      return a9 !== null && (a9 = a9.memoizedState, a9 === null || a9.dehydrated !== null) ? (b7 = b7.memoizedState, b7 !== null && b7.dehydrated === null) : false;
    }
    var nj = Math.ceil;
    var oj = ra.ReactCurrentDispatcher;
    var pj = ra.ReactCurrentOwner;
    var X2 = 0;
    var U3 = null;
    var Y4 = null;
    var W4 = 0;
    var qj = 0;
    var rj = Bf(0);
    var V5 = 0;
    var sj = null;
    var tj = 0;
    var Dg = 0;
    var Hi = 0;
    var uj = 0;
    var vj = null;
    var jj = 0;
    var Ji = Infinity;
    function wj() {
      Ji = O5() + 500;
    }
    var Z4 = null;
    var Qi = false;
    var Ri = null;
    var Ti = null;
    var xj = false;
    var yj = null;
    var zj = 90;
    var Aj = [];
    var Bj = [];
    var Cj = null;
    var Dj = 0;
    var Ej = null;
    var Fj = -1;
    var Gj = 0;
    var Hj = 0;
    var Ij = null;
    var Jj = false;
    function Hg() {
      return (X2 & 48) !== 0 ? O5() : Fj !== -1 ? Fj : Fj = O5();
    }
    function Ig(a9) {
      a9 = a9.mode;
      if ((a9 & 2) === 0)
        return 1;
      if ((a9 & 4) === 0)
        return eg() === 99 ? 1 : 2;
      Gj === 0 && (Gj = tj);
      if (kg.transition !== 0) {
        Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);
        a9 = Gj;
        var b7 = 4186112 & ~Hj;
        b7 &= -b7;
        b7 === 0 && (a9 = 4186112 & ~a9, b7 = a9 & -a9, b7 === 0 && (b7 = 8192));
        return b7;
      }
      a9 = eg();
      (X2 & 4) !== 0 && a9 === 98 ? a9 = Xc(12, Gj) : (a9 = Sc(a9), a9 = Xc(a9, Gj));
      return a9;
    }
    function Jg(a9, b7, c7) {
      if (50 < Dj)
        throw Dj = 0, Ej = null, Error(y4(185));
      a9 = Kj(a9, b7);
      if (a9 === null)
        return null;
      $c(a9, b7, c7);
      a9 === U3 && (Hi |= b7, V5 === 4 && Ii(a9, W4));
      var d8 = eg();
      b7 === 1 ? (X2 & 8) !== 0 && (X2 & 48) === 0 ? Lj(a9) : (Mj(a9, c7), X2 === 0 && (wj(), ig())) : ((X2 & 4) === 0 || d8 !== 98 && d8 !== 99 || (Cj === null ? Cj = new Set([a9]) : Cj.add(a9)), Mj(a9, c7));
      vj = a9;
    }
    function Kj(a9, b7) {
      a9.lanes |= b7;
      var c7 = a9.alternate;
      c7 !== null && (c7.lanes |= b7);
      c7 = a9;
      for (a9 = a9.return; a9 !== null; )
        a9.childLanes |= b7, c7 = a9.alternate, c7 !== null && (c7.childLanes |= b7), c7 = a9, a9 = a9.return;
      return c7.tag === 3 ? c7.stateNode : null;
    }
    function Mj(a9, b7) {
      for (var c7 = a9.callbackNode, d8 = a9.suspendedLanes, e12 = a9.pingedLanes, f11 = a9.expirationTimes, g5 = a9.pendingLanes; 0 < g5; ) {
        var h3 = 31 - Vc(g5), k3 = 1 << h3, l9 = f11[h3];
        if (l9 === -1) {
          if ((k3 & d8) === 0 || (k3 & e12) !== 0) {
            l9 = b7;
            Rc(k3);
            var n6 = F5;
            f11[h3] = 10 <= n6 ? l9 + 250 : 6 <= n6 ? l9 + 5e3 : -1;
          }
        } else
          l9 <= b7 && (a9.expiredLanes |= k3);
        g5 &= ~k3;
      }
      d8 = Uc(a9, a9 === U3 ? W4 : 0);
      b7 = F5;
      if (d8 === 0)
        c7 !== null && (c7 !== Zf && Pf(c7), a9.callbackNode = null, a9.callbackPriority = 0);
      else {
        if (c7 !== null) {
          if (a9.callbackPriority === b7)
            return;
          c7 !== Zf && Pf(c7);
        }
        b7 === 15 ? (c7 = Lj.bind(null, a9), ag === null ? (ag = [c7], bg = Of(Uf, jg)) : ag.push(c7), c7 = Zf) : b7 === 14 ? c7 = hg(99, Lj.bind(null, a9)) : (c7 = Tc(b7), c7 = hg(c7, Nj.bind(null, a9)));
        a9.callbackPriority = b7;
        a9.callbackNode = c7;
      }
    }
    function Nj(a9) {
      Fj = -1;
      Hj = Gj = 0;
      if ((X2 & 48) !== 0)
        throw Error(y4(327));
      var b7 = a9.callbackNode;
      if (Oj() && a9.callbackNode !== b7)
        return null;
      var c7 = Uc(a9, a9 === U3 ? W4 : 0);
      if (c7 === 0)
        return null;
      var d8 = c7;
      var e12 = X2;
      X2 |= 16;
      var f11 = Pj();
      if (U3 !== a9 || W4 !== d8)
        wj(), Qj(a9, d8);
      do
        try {
          Rj();
          break;
        } catch (h3) {
          Sj(a9, h3);
        }
      while (1);
      qg();
      oj.current = f11;
      X2 = e12;
      Y4 !== null ? d8 = 0 : (U3 = null, W4 = 0, d8 = V5);
      if ((tj & Hi) !== 0)
        Qj(a9, 0);
      else if (d8 !== 0) {
        d8 === 2 && (X2 |= 64, a9.hydrate && (a9.hydrate = false, qf(a9.containerInfo)), c7 = Wc(a9), c7 !== 0 && (d8 = Tj(a9, c7)));
        if (d8 === 1)
          throw b7 = sj, Qj(a9, 0), Ii(a9, c7), Mj(a9, O5()), b7;
        a9.finishedWork = a9.current.alternate;
        a9.finishedLanes = c7;
        switch (d8) {
          case 0:
          case 1:
            throw Error(y4(345));
          case 2:
            Uj(a9);
            break;
          case 3:
            Ii(a9, c7);
            if ((c7 & 62914560) === c7 && (d8 = jj + 500 - O5(), 10 < d8)) {
              if (Uc(a9, 0) !== 0)
                break;
              e12 = a9.suspendedLanes;
              if ((e12 & c7) !== c7) {
                Hg();
                a9.pingedLanes |= a9.suspendedLanes & e12;
                break;
              }
              a9.timeoutHandle = of(Uj.bind(null, a9), d8);
              break;
            }
            Uj(a9);
            break;
          case 4:
            Ii(a9, c7);
            if ((c7 & 4186112) === c7)
              break;
            d8 = a9.eventTimes;
            for (e12 = -1; 0 < c7; ) {
              var g5 = 31 - Vc(c7);
              f11 = 1 << g5;
              g5 = d8[g5];
              g5 > e12 && (e12 = g5);
              c7 &= ~f11;
            }
            c7 = e12;
            c7 = O5() - c7;
            c7 = (120 > c7 ? 120 : 480 > c7 ? 480 : 1080 > c7 ? 1080 : 1920 > c7 ? 1920 : 3e3 > c7 ? 3e3 : 4320 > c7 ? 4320 : 1960 * nj(c7 / 1960)) - c7;
            if (10 < c7) {
              a9.timeoutHandle = of(Uj.bind(null, a9), c7);
              break;
            }
            Uj(a9);
            break;
          case 5:
            Uj(a9);
            break;
          default:
            throw Error(y4(329));
        }
      }
      Mj(a9, O5());
      return a9.callbackNode === b7 ? Nj.bind(null, a9) : null;
    }
    function Ii(a9, b7) {
      b7 &= ~uj;
      b7 &= ~Hi;
      a9.suspendedLanes |= b7;
      a9.pingedLanes &= ~b7;
      for (a9 = a9.expirationTimes; 0 < b7; ) {
        var c7 = 31 - Vc(b7), d8 = 1 << c7;
        a9[c7] = -1;
        b7 &= ~d8;
      }
    }
    function Lj(a9) {
      if ((X2 & 48) !== 0)
        throw Error(y4(327));
      Oj();
      if (a9 === U3 && (a9.expiredLanes & W4) !== 0) {
        var b7 = W4;
        var c7 = Tj(a9, b7);
        (tj & Hi) !== 0 && (b7 = Uc(a9, b7), c7 = Tj(a9, b7));
      } else
        b7 = Uc(a9, 0), c7 = Tj(a9, b7);
      a9.tag !== 0 && c7 === 2 && (X2 |= 64, a9.hydrate && (a9.hydrate = false, qf(a9.containerInfo)), b7 = Wc(a9), b7 !== 0 && (c7 = Tj(a9, b7)));
      if (c7 === 1)
        throw c7 = sj, Qj(a9, 0), Ii(a9, b7), Mj(a9, O5()), c7;
      a9.finishedWork = a9.current.alternate;
      a9.finishedLanes = b7;
      Uj(a9);
      Mj(a9, O5());
      return null;
    }
    function Vj() {
      if (Cj !== null) {
        var a9 = Cj;
        Cj = null;
        a9.forEach(function(a10) {
          a10.expiredLanes |= 24 & a10.pendingLanes;
          Mj(a10, O5());
        });
      }
      ig();
    }
    function Wj(a9, b7) {
      var c7 = X2;
      X2 |= 1;
      try {
        return a9(b7);
      } finally {
        X2 = c7, X2 === 0 && (wj(), ig());
      }
    }
    function Xj(a9, b7) {
      var c7 = X2;
      X2 &= -2;
      X2 |= 8;
      try {
        return a9(b7);
      } finally {
        X2 = c7, X2 === 0 && (wj(), ig());
      }
    }
    function ni(a9, b7) {
      I3(rj, qj);
      qj |= b7;
      tj |= b7;
    }
    function Ki() {
      qj = rj.current;
      H3(rj);
    }
    function Qj(a9, b7) {
      a9.finishedWork = null;
      a9.finishedLanes = 0;
      var c7 = a9.timeoutHandle;
      c7 !== -1 && (a9.timeoutHandle = -1, pf(c7));
      if (Y4 !== null)
        for (c7 = Y4.return; c7 !== null; ) {
          var d8 = c7;
          switch (d8.tag) {
            case 1:
              d8 = d8.type.childContextTypes;
              d8 !== null && d8 !== void 0 && Gf();
              break;
            case 3:
              fh();
              H3(N2);
              H3(M4);
              uh();
              break;
            case 5:
              hh(d8);
              break;
            case 4:
              fh();
              break;
            case 13:
              H3(P3);
              break;
            case 19:
              H3(P3);
              break;
            case 10:
              rg(d8);
              break;
            case 23:
            case 24:
              Ki();
          }
          c7 = c7.return;
        }
      U3 = a9;
      Y4 = Tg(a9.current, null);
      W4 = qj = tj = b7;
      V5 = 0;
      sj = null;
      uj = Hi = Dg = 0;
    }
    function Sj(a9, b7) {
      do {
        var c7 = Y4;
        try {
          qg();
          vh.current = Gh;
          if (yh) {
            for (var d8 = R5.memoizedState; d8 !== null; ) {
              var e12 = d8.queue;
              e12 !== null && (e12.pending = null);
              d8 = d8.next;
            }
            yh = false;
          }
          xh = 0;
          T5 = S3 = R5 = null;
          zh = false;
          pj.current = null;
          if (c7 === null || c7.return === null) {
            V5 = 1;
            sj = b7;
            Y4 = null;
            break;
          }
          a: {
            var f11 = a9, g5 = c7.return, h3 = c7, k3 = b7;
            b7 = W4;
            h3.flags |= 2048;
            h3.firstEffect = h3.lastEffect = null;
            if (k3 !== null && typeof k3 === "object" && typeof k3.then === "function") {
              var l9 = k3;
              if ((h3.mode & 2) === 0) {
                var n6 = h3.alternate;
                n6 ? (h3.updateQueue = n6.updateQueue, h3.memoizedState = n6.memoizedState, h3.lanes = n6.lanes) : (h3.updateQueue = null, h3.memoizedState = null);
              }
              var A4 = (P3.current & 1) !== 0, p7 = g5;
              do {
                var C6;
                if (C6 = p7.tag === 13) {
                  var x5 = p7.memoizedState;
                  if (x5 !== null)
                    C6 = x5.dehydrated !== null ? true : false;
                  else {
                    var w6 = p7.memoizedProps;
                    C6 = w6.fallback === void 0 ? false : w6.unstable_avoidThisFallback !== true ? true : A4 ? false : true;
                  }
                }
                if (C6) {
                  var z3 = p7.updateQueue;
                  if (z3 === null) {
                    var u4 = new Set();
                    u4.add(l9);
                    p7.updateQueue = u4;
                  } else
                    z3.add(l9);
                  if ((p7.mode & 2) === 0) {
                    p7.flags |= 64;
                    h3.flags |= 16384;
                    h3.flags &= -2981;
                    if (h3.tag === 1)
                      if (h3.alternate === null)
                        h3.tag = 17;
                      else {
                        var t14 = zg(-1, 1);
                        t14.tag = 2;
                        Ag(h3, t14);
                      }
                    h3.lanes |= 1;
                    break a;
                  }
                  k3 = void 0;
                  h3 = b7;
                  var q3 = f11.pingCache;
                  q3 === null ? (q3 = f11.pingCache = new Oi(), k3 = new Set(), q3.set(l9, k3)) : (k3 = q3.get(l9), k3 === void 0 && (k3 = new Set(), q3.set(l9, k3)));
                  if (!k3.has(h3)) {
                    k3.add(h3);
                    var v6 = Yj.bind(null, f11, l9, h3);
                    l9.then(v6, v6);
                  }
                  p7.flags |= 4096;
                  p7.lanes = b7;
                  break a;
                }
                p7 = p7.return;
              } while (p7 !== null);
              k3 = Error((Ra(h3.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            V5 !== 5 && (V5 = 2);
            k3 = Mi(k3, h3);
            p7 = g5;
            do {
              switch (p7.tag) {
                case 3:
                  f11 = k3;
                  p7.flags |= 4096;
                  b7 &= -b7;
                  p7.lanes |= b7;
                  var J3 = Pi(p7, f11, b7);
                  Bg(p7, J3);
                  break a;
                case 1:
                  f11 = k3;
                  var K2 = p7.type, Q = p7.stateNode;
                  if ((p7.flags & 64) === 0 && (typeof K2.getDerivedStateFromError === "function" || Q !== null && typeof Q.componentDidCatch === "function" && (Ti === null || !Ti.has(Q)))) {
                    p7.flags |= 4096;
                    b7 &= -b7;
                    p7.lanes |= b7;
                    var L4 = Si(p7, f11, b7);
                    Bg(p7, L4);
                    break a;
                  }
              }
              p7 = p7.return;
            } while (p7 !== null);
          }
          Zj(c7);
        } catch (va) {
          b7 = va;
          Y4 === c7 && c7 !== null && (Y4 = c7 = c7.return);
          continue;
        }
        break;
      } while (1);
    }
    function Pj() {
      var a9 = oj.current;
      oj.current = Gh;
      return a9 === null ? Gh : a9;
    }
    function Tj(a9, b7) {
      var c7 = X2;
      X2 |= 16;
      var d8 = Pj();
      U3 === a9 && W4 === b7 || Qj(a9, b7);
      do
        try {
          ak();
          break;
        } catch (e12) {
          Sj(a9, e12);
        }
      while (1);
      qg();
      X2 = c7;
      oj.current = d8;
      if (Y4 !== null)
        throw Error(y4(261));
      U3 = null;
      W4 = 0;
      return V5;
    }
    function ak() {
      for (; Y4 !== null; )
        bk(Y4);
    }
    function Rj() {
      for (; Y4 !== null && !Qf(); )
        bk(Y4);
    }
    function bk(a9) {
      var b7 = ck(a9.alternate, a9, qj);
      a9.memoizedProps = a9.pendingProps;
      b7 === null ? Zj(a9) : Y4 = b7;
      pj.current = null;
    }
    function Zj(a9) {
      var b7 = a9;
      do {
        var c7 = b7.alternate;
        a9 = b7.return;
        if ((b7.flags & 2048) === 0) {
          c7 = Gi(c7, b7, qj);
          if (c7 !== null) {
            Y4 = c7;
            return;
          }
          c7 = b7;
          if (c7.tag !== 24 && c7.tag !== 23 || c7.memoizedState === null || (qj & 1073741824) !== 0 || (c7.mode & 4) === 0) {
            for (var d8 = 0, e12 = c7.child; e12 !== null; )
              d8 |= e12.lanes | e12.childLanes, e12 = e12.sibling;
            c7.childLanes = d8;
          }
          a9 !== null && (a9.flags & 2048) === 0 && (a9.firstEffect === null && (a9.firstEffect = b7.firstEffect), b7.lastEffect !== null && (a9.lastEffect !== null && (a9.lastEffect.nextEffect = b7.firstEffect), a9.lastEffect = b7.lastEffect), 1 < b7.flags && (a9.lastEffect !== null ? a9.lastEffect.nextEffect = b7 : a9.firstEffect = b7, a9.lastEffect = b7));
        } else {
          c7 = Li(b7);
          if (c7 !== null) {
            c7.flags &= 2047;
            Y4 = c7;
            return;
          }
          a9 !== null && (a9.firstEffect = a9.lastEffect = null, a9.flags |= 2048);
        }
        b7 = b7.sibling;
        if (b7 !== null) {
          Y4 = b7;
          return;
        }
        Y4 = b7 = a9;
      } while (b7 !== null);
      V5 === 0 && (V5 = 5);
    }
    function Uj(a9) {
      var b7 = eg();
      gg(99, dk.bind(null, a9, b7));
      return null;
    }
    function dk(a9, b7) {
      do
        Oj();
      while (yj !== null);
      if ((X2 & 48) !== 0)
        throw Error(y4(327));
      var c7 = a9.finishedWork;
      if (c7 === null)
        return null;
      a9.finishedWork = null;
      a9.finishedLanes = 0;
      if (c7 === a9.current)
        throw Error(y4(177));
      a9.callbackNode = null;
      var d8 = c7.lanes | c7.childLanes, e12 = d8, f11 = a9.pendingLanes & ~e12;
      a9.pendingLanes = e12;
      a9.suspendedLanes = 0;
      a9.pingedLanes = 0;
      a9.expiredLanes &= e12;
      a9.mutableReadLanes &= e12;
      a9.entangledLanes &= e12;
      e12 = a9.entanglements;
      for (var g5 = a9.eventTimes, h3 = a9.expirationTimes; 0 < f11; ) {
        var k3 = 31 - Vc(f11), l9 = 1 << k3;
        e12[k3] = 0;
        g5[k3] = -1;
        h3[k3] = -1;
        f11 &= ~l9;
      }
      Cj !== null && (d8 & 24) === 0 && Cj.has(a9) && Cj.delete(a9);
      a9 === U3 && (Y4 = U3 = null, W4 = 0);
      1 < c7.flags ? c7.lastEffect !== null ? (c7.lastEffect.nextEffect = c7, d8 = c7.firstEffect) : d8 = c7 : d8 = c7.firstEffect;
      if (d8 !== null) {
        e12 = X2;
        X2 |= 32;
        pj.current = null;
        kf = fd;
        g5 = Ne();
        if (Oe(g5)) {
          if ("selectionStart" in g5)
            h3 = { start: g5.selectionStart, end: g5.selectionEnd };
          else
            a:
              if (h3 = (h3 = g5.ownerDocument) && h3.defaultView || window, (l9 = h3.getSelection && h3.getSelection()) && l9.rangeCount !== 0) {
                h3 = l9.anchorNode;
                f11 = l9.anchorOffset;
                k3 = l9.focusNode;
                l9 = l9.focusOffset;
                try {
                  h3.nodeType, k3.nodeType;
                } catch (va) {
                  h3 = null;
                  break a;
                }
                var n6 = 0, A4 = -1, p7 = -1, C6 = 0, x5 = 0, w6 = g5, z3 = null;
                b:
                  for (; ; ) {
                    for (var u4; ; ) {
                      w6 !== h3 || f11 !== 0 && w6.nodeType !== 3 || (A4 = n6 + f11);
                      w6 !== k3 || l9 !== 0 && w6.nodeType !== 3 || (p7 = n6 + l9);
                      w6.nodeType === 3 && (n6 += w6.nodeValue.length);
                      if ((u4 = w6.firstChild) === null)
                        break;
                      z3 = w6;
                      w6 = u4;
                    }
                    for (; ; ) {
                      if (w6 === g5)
                        break b;
                      z3 === h3 && ++C6 === f11 && (A4 = n6);
                      z3 === k3 && ++x5 === l9 && (p7 = n6);
                      if ((u4 = w6.nextSibling) !== null)
                        break;
                      w6 = z3;
                      z3 = w6.parentNode;
                    }
                    w6 = u4;
                  }
                h3 = A4 === -1 || p7 === -1 ? null : { start: A4, end: p7 };
              } else
                h3 = null;
          h3 = h3 || { start: 0, end: 0 };
        } else
          h3 = null;
        lf = { focusedElem: g5, selectionRange: h3 };
        fd = false;
        Ij = null;
        Jj = false;
        Z4 = d8;
        do
          try {
            ek();
          } catch (va) {
            if (Z4 === null)
              throw Error(y4(330));
            Wi(Z4, va);
            Z4 = Z4.nextEffect;
          }
        while (Z4 !== null);
        Ij = null;
        Z4 = d8;
        do
          try {
            for (g5 = a9; Z4 !== null; ) {
              var t14 = Z4.flags;
              t14 & 16 && pb(Z4.stateNode, "");
              if (t14 & 128) {
                var q3 = Z4.alternate;
                if (q3 !== null) {
                  var v6 = q3.ref;
                  v6 !== null && (typeof v6 === "function" ? v6(null) : v6.current = null);
                }
              }
              switch (t14 & 1038) {
                case 2:
                  fj(Z4);
                  Z4.flags &= -3;
                  break;
                case 6:
                  fj(Z4);
                  Z4.flags &= -3;
                  ij(Z4.alternate, Z4);
                  break;
                case 1024:
                  Z4.flags &= -1025;
                  break;
                case 1028:
                  Z4.flags &= -1025;
                  ij(Z4.alternate, Z4);
                  break;
                case 4:
                  ij(Z4.alternate, Z4);
                  break;
                case 8:
                  h3 = Z4;
                  cj(g5, h3);
                  var J3 = h3.alternate;
                  dj(h3);
                  J3 !== null && dj(J3);
              }
              Z4 = Z4.nextEffect;
            }
          } catch (va) {
            if (Z4 === null)
              throw Error(y4(330));
            Wi(Z4, va);
            Z4 = Z4.nextEffect;
          }
        while (Z4 !== null);
        v6 = lf;
        q3 = Ne();
        t14 = v6.focusedElem;
        g5 = v6.selectionRange;
        if (q3 !== t14 && t14 && t14.ownerDocument && Me(t14.ownerDocument.documentElement, t14)) {
          g5 !== null && Oe(t14) && (q3 = g5.start, v6 = g5.end, v6 === void 0 && (v6 = q3), "selectionStart" in t14 ? (t14.selectionStart = q3, t14.selectionEnd = Math.min(v6, t14.value.length)) : (v6 = (q3 = t14.ownerDocument || document) && q3.defaultView || window, v6.getSelection && (v6 = v6.getSelection(), h3 = t14.textContent.length, J3 = Math.min(g5.start, h3), g5 = g5.end === void 0 ? J3 : Math.min(g5.end, h3), !v6.extend && J3 > g5 && (h3 = g5, g5 = J3, J3 = h3), h3 = Le(t14, J3), f11 = Le(t14, g5), h3 && f11 && (v6.rangeCount !== 1 || v6.anchorNode !== h3.node || v6.anchorOffset !== h3.offset || v6.focusNode !== f11.node || v6.focusOffset !== f11.offset) && (q3 = q3.createRange(), q3.setStart(h3.node, h3.offset), v6.removeAllRanges(), J3 > g5 ? (v6.addRange(q3), v6.extend(f11.node, f11.offset)) : (q3.setEnd(f11.node, f11.offset), v6.addRange(q3))))));
          q3 = [];
          for (v6 = t14; v6 = v6.parentNode; )
            v6.nodeType === 1 && q3.push({ element: v6, left: v6.scrollLeft, top: v6.scrollTop });
          typeof t14.focus === "function" && t14.focus();
          for (t14 = 0; t14 < q3.length; t14++)
            v6 = q3[t14], v6.element.scrollLeft = v6.left, v6.element.scrollTop = v6.top;
        }
        fd = !!kf;
        lf = kf = null;
        a9.current = c7;
        Z4 = d8;
        do
          try {
            for (t14 = a9; Z4 !== null; ) {
              var K2 = Z4.flags;
              K2 & 36 && Yi(t14, Z4.alternate, Z4);
              if (K2 & 128) {
                q3 = void 0;
                var Q = Z4.ref;
                if (Q !== null) {
                  var L4 = Z4.stateNode;
                  switch (Z4.tag) {
                    case 5:
                      q3 = L4;
                      break;
                    default:
                      q3 = L4;
                  }
                  typeof Q === "function" ? Q(q3) : Q.current = q3;
                }
              }
              Z4 = Z4.nextEffect;
            }
          } catch (va) {
            if (Z4 === null)
              throw Error(y4(330));
            Wi(Z4, va);
            Z4 = Z4.nextEffect;
          }
        while (Z4 !== null);
        Z4 = null;
        $f();
        X2 = e12;
      } else
        a9.current = c7;
      if (xj)
        xj = false, yj = a9, zj = b7;
      else
        for (Z4 = d8; Z4 !== null; )
          b7 = Z4.nextEffect, Z4.nextEffect = null, Z4.flags & 8 && (K2 = Z4, K2.sibling = null, K2.stateNode = null), Z4 = b7;
      d8 = a9.pendingLanes;
      d8 === 0 && (Ti = null);
      d8 === 1 ? a9 === Ej ? Dj++ : (Dj = 0, Ej = a9) : Dj = 0;
      c7 = c7.stateNode;
      if (Mf && typeof Mf.onCommitFiberRoot === "function")
        try {
          Mf.onCommitFiberRoot(Lf, c7, void 0, (c7.current.flags & 64) === 64);
        } catch (va) {
        }
      Mj(a9, O5());
      if (Qi)
        throw Qi = false, a9 = Ri, Ri = null, a9;
      if ((X2 & 8) !== 0)
        return null;
      ig();
      return null;
    }
    function ek() {
      for (; Z4 !== null; ) {
        var a9 = Z4.alternate;
        Jj || Ij === null || ((Z4.flags & 8) !== 0 ? dc(Z4, Ij) && (Jj = true) : Z4.tag === 13 && mj(a9, Z4) && dc(Z4, Ij) && (Jj = true));
        var b7 = Z4.flags;
        (b7 & 256) !== 0 && Xi(a9, Z4);
        (b7 & 512) === 0 || xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
        Z4 = Z4.nextEffect;
      }
    }
    function Oj() {
      if (zj !== 90) {
        var a9 = 97 < zj ? 97 : zj;
        zj = 90;
        return gg(a9, fk);
      }
      return false;
    }
    function $i(a9, b7) {
      Aj.push(b7, a9);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function Zi(a9, b7) {
      Bj.push(b7, a9);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function fk() {
      if (yj === null)
        return false;
      var a9 = yj;
      yj = null;
      if ((X2 & 48) !== 0)
        throw Error(y4(331));
      var b7 = X2;
      X2 |= 32;
      var c7 = Bj;
      Bj = [];
      for (var d8 = 0; d8 < c7.length; d8 += 2) {
        var e12 = c7[d8], f11 = c7[d8 + 1], g5 = e12.destroy;
        e12.destroy = void 0;
        if (typeof g5 === "function")
          try {
            g5();
          } catch (k3) {
            if (f11 === null)
              throw Error(y4(330));
            Wi(f11, k3);
          }
      }
      c7 = Aj;
      Aj = [];
      for (d8 = 0; d8 < c7.length; d8 += 2) {
        e12 = c7[d8];
        f11 = c7[d8 + 1];
        try {
          var h3 = e12.create;
          e12.destroy = h3();
        } catch (k3) {
          if (f11 === null)
            throw Error(y4(330));
          Wi(f11, k3);
        }
      }
      for (h3 = a9.current.firstEffect; h3 !== null; )
        a9 = h3.nextEffect, h3.nextEffect = null, h3.flags & 8 && (h3.sibling = null, h3.stateNode = null), h3 = a9;
      X2 = b7;
      ig();
      return true;
    }
    function gk(a9, b7, c7) {
      b7 = Mi(c7, b7);
      b7 = Pi(a9, b7, 1);
      Ag(a9, b7);
      b7 = Hg();
      a9 = Kj(a9, 1);
      a9 !== null && ($c(a9, 1, b7), Mj(a9, b7));
    }
    function Wi(a9, b7) {
      if (a9.tag === 3)
        gk(a9, a9, b7);
      else
        for (var c7 = a9.return; c7 !== null; ) {
          if (c7.tag === 3) {
            gk(c7, a9, b7);
            break;
          } else if (c7.tag === 1) {
            var d8 = c7.stateNode;
            if (typeof c7.type.getDerivedStateFromError === "function" || typeof d8.componentDidCatch === "function" && (Ti === null || !Ti.has(d8))) {
              a9 = Mi(b7, a9);
              var e12 = Si(c7, a9, 1);
              Ag(c7, e12);
              e12 = Hg();
              c7 = Kj(c7, 1);
              if (c7 !== null)
                $c(c7, 1, e12), Mj(c7, e12);
              else if (typeof d8.componentDidCatch === "function" && (Ti === null || !Ti.has(d8)))
                try {
                  d8.componentDidCatch(b7, a9);
                } catch (f11) {
                }
              break;
            }
          }
          c7 = c7.return;
        }
    }
    function Yj(a9, b7, c7) {
      var d8 = a9.pingCache;
      d8 !== null && d8.delete(b7);
      b7 = Hg();
      a9.pingedLanes |= a9.suspendedLanes & c7;
      U3 === a9 && (W4 & c7) === c7 && (V5 === 4 || V5 === 3 && (W4 & 62914560) === W4 && 500 > O5() - jj ? Qj(a9, 0) : uj |= c7);
      Mj(a9, b7);
    }
    function lj(a9, b7) {
      var c7 = a9.stateNode;
      c7 !== null && c7.delete(b7);
      b7 = 0;
      b7 === 0 && (b7 = a9.mode, (b7 & 2) === 0 ? b7 = 1 : (b7 & 4) === 0 ? b7 = eg() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b7 = Yc(62914560 & ~Gj), b7 === 0 && (b7 = 4194304)));
      c7 = Hg();
      a9 = Kj(a9, b7);
      a9 !== null && ($c(a9, b7, c7), Mj(a9, c7));
    }
    var ck;
    ck = function(a9, b7, c7) {
      var d8 = b7.lanes;
      if (a9 !== null)
        if (a9.memoizedProps !== b7.pendingProps || N2.current)
          ug = true;
        else if ((c7 & d8) !== 0)
          ug = (a9.flags & 16384) !== 0 ? true : false;
        else {
          ug = false;
          switch (b7.tag) {
            case 3:
              ri(b7);
              sh();
              break;
            case 5:
              gh(b7);
              break;
            case 1:
              Ff(b7.type) && Jf(b7);
              break;
            case 4:
              eh(b7, b7.stateNode.containerInfo);
              break;
            case 10:
              d8 = b7.memoizedProps.value;
              var e12 = b7.type._context;
              I3(mg, e12._currentValue);
              e12._currentValue = d8;
              break;
            case 13:
              if (b7.memoizedState !== null) {
                if ((c7 & b7.child.childLanes) !== 0)
                  return ti(a9, b7, c7);
                I3(P3, P3.current & 1);
                b7 = hi(a9, b7, c7);
                return b7 !== null ? b7.sibling : null;
              }
              I3(P3, P3.current & 1);
              break;
            case 19:
              d8 = (c7 & b7.childLanes) !== 0;
              if ((a9.flags & 64) !== 0) {
                if (d8)
                  return Ai(a9, b7, c7);
                b7.flags |= 64;
              }
              e12 = b7.memoizedState;
              e12 !== null && (e12.rendering = null, e12.tail = null, e12.lastEffect = null);
              I3(P3, P3.current);
              if (d8)
                break;
              else
                return null;
            case 23:
            case 24:
              return b7.lanes = 0, mi(a9, b7, c7);
          }
          return hi(a9, b7, c7);
        }
      else
        ug = false;
      b7.lanes = 0;
      switch (b7.tag) {
        case 2:
          d8 = b7.type;
          a9 !== null && (a9.alternate = null, b7.alternate = null, b7.flags |= 2);
          a9 = b7.pendingProps;
          e12 = Ef(b7, M4.current);
          tg(b7, c7);
          e12 = Ch(null, b7, d8, a9, e12, c7);
          b7.flags |= 1;
          if (typeof e12 === "object" && e12 !== null && typeof e12.render === "function" && e12.$$typeof === void 0) {
            b7.tag = 1;
            b7.memoizedState = null;
            b7.updateQueue = null;
            if (Ff(d8)) {
              var f11 = true;
              Jf(b7);
            } else
              f11 = false;
            b7.memoizedState = e12.state !== null && e12.state !== void 0 ? e12.state : null;
            xg(b7);
            var g5 = d8.getDerivedStateFromProps;
            typeof g5 === "function" && Gg(b7, d8, g5, a9);
            e12.updater = Kg;
            b7.stateNode = e12;
            e12._reactInternals = b7;
            Og(b7, d8, a9, c7);
            b7 = qi(null, b7, d8, true, f11, c7);
          } else
            b7.tag = 0, fi(null, b7, e12, c7), b7 = b7.child;
          return b7;
        case 16:
          e12 = b7.elementType;
          a: {
            a9 !== null && (a9.alternate = null, b7.alternate = null, b7.flags |= 2);
            a9 = b7.pendingProps;
            f11 = e12._init;
            e12 = f11(e12._payload);
            b7.type = e12;
            f11 = b7.tag = hk(e12);
            a9 = lg(e12, a9);
            switch (f11) {
              case 0:
                b7 = li(null, b7, e12, a9, c7);
                break a;
              case 1:
                b7 = pi(null, b7, e12, a9, c7);
                break a;
              case 11:
                b7 = gi(null, b7, e12, a9, c7);
                break a;
              case 14:
                b7 = ii(null, b7, e12, lg(e12.type, a9), d8, c7);
                break a;
            }
            throw Error(y4(306, e12, ""));
          }
          return b7;
        case 0:
          return d8 = b7.type, e12 = b7.pendingProps, e12 = b7.elementType === d8 ? e12 : lg(d8, e12), li(a9, b7, d8, e12, c7);
        case 1:
          return d8 = b7.type, e12 = b7.pendingProps, e12 = b7.elementType === d8 ? e12 : lg(d8, e12), pi(a9, b7, d8, e12, c7);
        case 3:
          ri(b7);
          d8 = b7.updateQueue;
          if (a9 === null || d8 === null)
            throw Error(y4(282));
          d8 = b7.pendingProps;
          e12 = b7.memoizedState;
          e12 = e12 !== null ? e12.element : null;
          yg(a9, b7);
          Cg(b7, d8, null, c7);
          d8 = b7.memoizedState.element;
          if (d8 === e12)
            sh(), b7 = hi(a9, b7, c7);
          else {
            e12 = b7.stateNode;
            if (f11 = e12.hydrate)
              kh = rf(b7.stateNode.containerInfo.firstChild), jh = b7, f11 = lh = true;
            if (f11) {
              a9 = e12.mutableSourceEagerHydrationData;
              if (a9 != null)
                for (e12 = 0; e12 < a9.length; e12 += 2)
                  f11 = a9[e12], f11._workInProgressVersionPrimary = a9[e12 + 1], th.push(f11);
              c7 = Zg(b7, null, d8, c7);
              for (b7.child = c7; c7; )
                c7.flags = c7.flags & -3 | 1024, c7 = c7.sibling;
            } else
              fi(a9, b7, d8, c7), sh();
            b7 = b7.child;
          }
          return b7;
        case 5:
          return gh(b7), a9 === null && ph(b7), d8 = b7.type, e12 = b7.pendingProps, f11 = a9 !== null ? a9.memoizedProps : null, g5 = e12.children, nf(d8, e12) ? g5 = null : f11 !== null && nf(d8, f11) && (b7.flags |= 16), oi(a9, b7), fi(a9, b7, g5, c7), b7.child;
        case 6:
          return a9 === null && ph(b7), null;
        case 13:
          return ti(a9, b7, c7);
        case 4:
          return eh(b7, b7.stateNode.containerInfo), d8 = b7.pendingProps, a9 === null ? b7.child = Yg(b7, null, d8, c7) : fi(a9, b7, d8, c7), b7.child;
        case 11:
          return d8 = b7.type, e12 = b7.pendingProps, e12 = b7.elementType === d8 ? e12 : lg(d8, e12), gi(a9, b7, d8, e12, c7);
        case 7:
          return fi(a9, b7, b7.pendingProps, c7), b7.child;
        case 8:
          return fi(a9, b7, b7.pendingProps.children, c7), b7.child;
        case 12:
          return fi(a9, b7, b7.pendingProps.children, c7), b7.child;
        case 10:
          a: {
            d8 = b7.type._context;
            e12 = b7.pendingProps;
            g5 = b7.memoizedProps;
            f11 = e12.value;
            var h3 = b7.type._context;
            I3(mg, h3._currentValue);
            h3._currentValue = f11;
            if (g5 !== null)
              if (h3 = g5.value, f11 = He(h3, f11) ? 0 : (typeof d8._calculateChangedBits === "function" ? d8._calculateChangedBits(h3, f11) : 1073741823) | 0, f11 === 0) {
                if (g5.children === e12.children && !N2.current) {
                  b7 = hi(a9, b7, c7);
                  break a;
                }
              } else
                for (h3 = b7.child, h3 !== null && (h3.return = b7); h3 !== null; ) {
                  var k3 = h3.dependencies;
                  if (k3 !== null) {
                    g5 = h3.child;
                    for (var l9 = k3.firstContext; l9 !== null; ) {
                      if (l9.context === d8 && (l9.observedBits & f11) !== 0) {
                        h3.tag === 1 && (l9 = zg(-1, c7 & -c7), l9.tag = 2, Ag(h3, l9));
                        h3.lanes |= c7;
                        l9 = h3.alternate;
                        l9 !== null && (l9.lanes |= c7);
                        sg(h3.return, c7);
                        k3.lanes |= c7;
                        break;
                      }
                      l9 = l9.next;
                    }
                  } else
                    g5 = h3.tag === 10 ? h3.type === b7.type ? null : h3.child : h3.child;
                  if (g5 !== null)
                    g5.return = h3;
                  else
                    for (g5 = h3; g5 !== null; ) {
                      if (g5 === b7) {
                        g5 = null;
                        break;
                      }
                      h3 = g5.sibling;
                      if (h3 !== null) {
                        h3.return = g5.return;
                        g5 = h3;
                        break;
                      }
                      g5 = g5.return;
                    }
                  h3 = g5;
                }
            fi(a9, b7, e12.children, c7);
            b7 = b7.child;
          }
          return b7;
        case 9:
          return e12 = b7.type, f11 = b7.pendingProps, d8 = f11.children, tg(b7, c7), e12 = vg(e12, f11.unstable_observedBits), d8 = d8(e12), b7.flags |= 1, fi(a9, b7, d8, c7), b7.child;
        case 14:
          return e12 = b7.type, f11 = lg(e12, b7.pendingProps), f11 = lg(e12.type, f11), ii(a9, b7, e12, f11, d8, c7);
        case 15:
          return ki(a9, b7, b7.type, b7.pendingProps, d8, c7);
        case 17:
          return d8 = b7.type, e12 = b7.pendingProps, e12 = b7.elementType === d8 ? e12 : lg(d8, e12), a9 !== null && (a9.alternate = null, b7.alternate = null, b7.flags |= 2), b7.tag = 1, Ff(d8) ? (a9 = true, Jf(b7)) : a9 = false, tg(b7, c7), Mg(b7, d8, e12), Og(b7, d8, e12, c7), qi(null, b7, d8, true, a9, c7);
        case 19:
          return Ai(a9, b7, c7);
        case 23:
          return mi(a9, b7, c7);
        case 24:
          return mi(a9, b7, c7);
      }
      throw Error(y4(156, b7.tag));
    };
    function ik(a9, b7, c7, d8) {
      this.tag = a9;
      this.key = c7;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b7;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d8;
      this.flags = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function nh(a9, b7, c7, d8) {
      return new ik(a9, b7, c7, d8);
    }
    function ji(a9) {
      a9 = a9.prototype;
      return !(!a9 || !a9.isReactComponent);
    }
    function hk(a9) {
      if (typeof a9 === "function")
        return ji(a9) ? 1 : 0;
      if (a9 !== void 0 && a9 !== null) {
        a9 = a9.$$typeof;
        if (a9 === Aa)
          return 11;
        if (a9 === Da)
          return 14;
      }
      return 2;
    }
    function Tg(a9, b7) {
      var c7 = a9.alternate;
      c7 === null ? (c7 = nh(a9.tag, b7, a9.key, a9.mode), c7.elementType = a9.elementType, c7.type = a9.type, c7.stateNode = a9.stateNode, c7.alternate = a9, a9.alternate = c7) : (c7.pendingProps = b7, c7.type = a9.type, c7.flags = 0, c7.nextEffect = null, c7.firstEffect = null, c7.lastEffect = null);
      c7.childLanes = a9.childLanes;
      c7.lanes = a9.lanes;
      c7.child = a9.child;
      c7.memoizedProps = a9.memoizedProps;
      c7.memoizedState = a9.memoizedState;
      c7.updateQueue = a9.updateQueue;
      b7 = a9.dependencies;
      c7.dependencies = b7 === null ? null : { lanes: b7.lanes, firstContext: b7.firstContext };
      c7.sibling = a9.sibling;
      c7.index = a9.index;
      c7.ref = a9.ref;
      return c7;
    }
    function Vg(a9, b7, c7, d8, e12, f11) {
      var g5 = 2;
      d8 = a9;
      if (typeof a9 === "function")
        ji(a9) && (g5 = 1);
      else if (typeof a9 === "string")
        g5 = 5;
      else
        a:
          switch (a9) {
            case ua:
              return Xg(c7.children, e12, f11, b7);
            case Ha:
              g5 = 8;
              e12 |= 16;
              break;
            case wa:
              g5 = 8;
              e12 |= 1;
              break;
            case xa:
              return a9 = nh(12, c7, b7, e12 | 8), a9.elementType = xa, a9.type = xa, a9.lanes = f11, a9;
            case Ba:
              return a9 = nh(13, c7, b7, e12), a9.type = Ba, a9.elementType = Ba, a9.lanes = f11, a9;
            case Ca:
              return a9 = nh(19, c7, b7, e12), a9.elementType = Ca, a9.lanes = f11, a9;
            case Ia:
              return vi(c7, e12, f11, b7);
            case Ja:
              return a9 = nh(24, c7, b7, e12), a9.elementType = Ja, a9.lanes = f11, a9;
            default:
              if (typeof a9 === "object" && a9 !== null)
                switch (a9.$$typeof) {
                  case ya:
                    g5 = 10;
                    break a;
                  case za:
                    g5 = 9;
                    break a;
                  case Aa:
                    g5 = 11;
                    break a;
                  case Da:
                    g5 = 14;
                    break a;
                  case Ea:
                    g5 = 16;
                    d8 = null;
                    break a;
                  case Fa:
                    g5 = 22;
                    break a;
                }
              throw Error(y4(130, a9 == null ? a9 : typeof a9, ""));
          }
      b7 = nh(g5, c7, b7, e12);
      b7.elementType = a9;
      b7.type = d8;
      b7.lanes = f11;
      return b7;
    }
    function Xg(a9, b7, c7, d8) {
      a9 = nh(7, a9, d8, b7);
      a9.lanes = c7;
      return a9;
    }
    function vi(a9, b7, c7, d8) {
      a9 = nh(23, a9, d8, b7);
      a9.elementType = Ia;
      a9.lanes = c7;
      return a9;
    }
    function Ug(a9, b7, c7) {
      a9 = nh(6, a9, null, b7);
      a9.lanes = c7;
      return a9;
    }
    function Wg(a9, b7, c7) {
      b7 = nh(4, a9.children !== null ? a9.children : [], a9.key, b7);
      b7.lanes = c7;
      b7.stateNode = { containerInfo: a9.containerInfo, pendingChildren: null, implementation: a9.implementation };
      return b7;
    }
    function jk(a9, b7, c7) {
      this.tag = b7;
      this.containerInfo = a9;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.pendingContext = this.context = null;
      this.hydrate = c7;
      this.callbackNode = null;
      this.callbackPriority = 0;
      this.eventTimes = Zc(0);
      this.expirationTimes = Zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = Zc(0);
      this.mutableSourceEagerHydrationData = null;
    }
    function kk(a9, b7, c7) {
      var d8 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: ta, key: d8 == null ? null : "" + d8, children: a9, containerInfo: b7, implementation: c7 };
    }
    function lk(a9, b7, c7, d8) {
      var e12 = b7.current, f11 = Hg(), g5 = Ig(e12);
      a:
        if (c7) {
          c7 = c7._reactInternals;
          b: {
            if (Zb(c7) !== c7 || c7.tag !== 1)
              throw Error(y4(170));
            var h3 = c7;
            do {
              switch (h3.tag) {
                case 3:
                  h3 = h3.stateNode.context;
                  break b;
                case 1:
                  if (Ff(h3.type)) {
                    h3 = h3.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              h3 = h3.return;
            } while (h3 !== null);
            throw Error(y4(171));
          }
          if (c7.tag === 1) {
            var k3 = c7.type;
            if (Ff(k3)) {
              c7 = If(c7, k3, h3);
              break a;
            }
          }
          c7 = h3;
        } else
          c7 = Cf;
      b7.context === null ? b7.context = c7 : b7.pendingContext = c7;
      b7 = zg(f11, g5);
      b7.payload = { element: a9 };
      d8 = d8 === void 0 ? null : d8;
      d8 !== null && (b7.callback = d8);
      Ag(e12, b7);
      Jg(e12, g5, f11);
      return g5;
    }
    function mk(a9) {
      a9 = a9.current;
      if (!a9.child)
        return null;
      switch (a9.child.tag) {
        case 5:
          return a9.child.stateNode;
        default:
          return a9.child.stateNode;
      }
    }
    function nk(a9, b7) {
      a9 = a9.memoizedState;
      if (a9 !== null && a9.dehydrated !== null) {
        var c7 = a9.retryLane;
        a9.retryLane = c7 !== 0 && c7 < b7 ? c7 : b7;
      }
    }
    function ok(a9, b7) {
      nk(a9, b7);
      (a9 = a9.alternate) && nk(a9, b7);
    }
    function pk() {
      return null;
    }
    function qk(a9, b7, c7) {
      var d8 = c7 != null && c7.hydrationOptions != null && c7.hydrationOptions.mutableSources || null;
      c7 = new jk(a9, b7, c7 != null && c7.hydrate === true);
      b7 = nh(3, null, null, b7 === 2 ? 7 : b7 === 1 ? 3 : 0);
      c7.current = b7;
      b7.stateNode = c7;
      xg(b7);
      a9[ff] = c7.current;
      cf(a9.nodeType === 8 ? a9.parentNode : a9);
      if (d8)
        for (a9 = 0; a9 < d8.length; a9++) {
          b7 = d8[a9];
          var e12 = b7._getVersion;
          e12 = e12(b7._source);
          c7.mutableSourceEagerHydrationData == null ? c7.mutableSourceEagerHydrationData = [b7, e12] : c7.mutableSourceEagerHydrationData.push(b7, e12);
        }
      this._internalRoot = c7;
    }
    qk.prototype.render = function(a9) {
      lk(a9, this._internalRoot, null, null);
    };
    qk.prototype.unmount = function() {
      var a9 = this._internalRoot, b7 = a9.containerInfo;
      lk(null, a9, null, function() {
        b7[ff] = null;
      });
    };
    function rk(a9) {
      return !(!a9 || a9.nodeType !== 1 && a9.nodeType !== 9 && a9.nodeType !== 11 && (a9.nodeType !== 8 || a9.nodeValue !== " react-mount-point-unstable "));
    }
    function sk(a9, b7) {
      b7 || (b7 = a9 ? a9.nodeType === 9 ? a9.documentElement : a9.firstChild : null, b7 = !(!b7 || b7.nodeType !== 1 || !b7.hasAttribute("data-reactroot")));
      if (!b7)
        for (var c7; c7 = a9.lastChild; )
          a9.removeChild(c7);
      return new qk(a9, 0, b7 ? { hydrate: true } : void 0);
    }
    function tk(a9, b7, c7, d8, e12) {
      var f11 = c7._reactRootContainer;
      if (f11) {
        var g5 = f11._internalRoot;
        if (typeof e12 === "function") {
          var h3 = e12;
          e12 = function() {
            var a10 = mk(g5);
            h3.call(a10);
          };
        }
        lk(b7, g5, a9, e12);
      } else {
        f11 = c7._reactRootContainer = sk(c7, d8);
        g5 = f11._internalRoot;
        if (typeof e12 === "function") {
          var k3 = e12;
          e12 = function() {
            var a10 = mk(g5);
            k3.call(a10);
          };
        }
        Xj(function() {
          lk(b7, g5, a9, e12);
        });
      }
      return mk(g5);
    }
    ec = function(a9) {
      if (a9.tag === 13) {
        var b7 = Hg();
        Jg(a9, 4, b7);
        ok(a9, 4);
      }
    };
    fc = function(a9) {
      if (a9.tag === 13) {
        var b7 = Hg();
        Jg(a9, 67108864, b7);
        ok(a9, 67108864);
      }
    };
    gc = function(a9) {
      if (a9.tag === 13) {
        var b7 = Hg(), c7 = Ig(a9);
        Jg(a9, c7, b7);
        ok(a9, c7);
      }
    };
    hc = function(a9, b7) {
      return b7();
    };
    yb = function(a9, b7, c7) {
      switch (b7) {
        case "input":
          ab(a9, c7);
          b7 = c7.name;
          if (c7.type === "radio" && b7 != null) {
            for (c7 = a9; c7.parentNode; )
              c7 = c7.parentNode;
            c7 = c7.querySelectorAll("input[name=" + JSON.stringify("" + b7) + '][type="radio"]');
            for (b7 = 0; b7 < c7.length; b7++) {
              var d8 = c7[b7];
              if (d8 !== a9 && d8.form === a9.form) {
                var e12 = Db(d8);
                if (!e12)
                  throw Error(y4(90));
                Wa(d8);
                ab(d8, e12);
              }
            }
          }
          break;
        case "textarea":
          ib(a9, c7);
          break;
        case "select":
          b7 = c7.value, b7 != null && fb(a9, !!c7.multiple, b7, false);
      }
    };
    Gb = Wj;
    Hb = function(a9, b7, c7, d8, e12) {
      var f11 = X2;
      X2 |= 4;
      try {
        return gg(98, a9.bind(null, b7, c7, d8, e12));
      } finally {
        X2 = f11, X2 === 0 && (wj(), ig());
      }
    };
    Ib = function() {
      (X2 & 49) === 0 && (Vj(), Oj());
    };
    Jb = function(a9, b7) {
      var c7 = X2;
      X2 |= 2;
      try {
        return a9(b7);
      } finally {
        X2 = c7, X2 === 0 && (wj(), ig());
      }
    };
    function uk(a9, b7) {
      var c7 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!rk(b7))
        throw Error(y4(200));
      return kk(a9, b7, null, c7);
    }
    var vk = { Events: [Cb, ue2, Db, Eb, Fb, Oj, { current: false }] };
    var wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
    var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a9) {
      a9 = cc(a9);
      return a9 === null ? null : a9.stateNode;
    }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
      yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!yk.isDisabled && yk.supportsFiber)
        try {
          Lf = yk.inject(xk), Mf = yk;
        } catch (a9) {
        }
    }
    var yk;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
    exports2.createPortal = uk;
    exports2.findDOMNode = function(a9) {
      if (a9 == null)
        return null;
      if (a9.nodeType === 1)
        return a9;
      var b7 = a9._reactInternals;
      if (b7 === void 0) {
        if (typeof a9.render === "function")
          throw Error(y4(188));
        throw Error(y4(268, Object.keys(a9)));
      }
      a9 = cc(b7);
      a9 = a9 === null ? null : a9.stateNode;
      return a9;
    };
    exports2.flushSync = function(a9, b7) {
      var c7 = X2;
      if ((c7 & 48) !== 0)
        return a9(b7);
      X2 |= 1;
      try {
        if (a9)
          return gg(99, a9.bind(null, b7));
      } finally {
        X2 = c7, ig();
      }
    };
    exports2.hydrate = function(a9, b7, c7) {
      if (!rk(b7))
        throw Error(y4(200));
      return tk(null, a9, b7, true, c7);
    };
    exports2.render = function(a9, b7, c7) {
      if (!rk(b7))
        throw Error(y4(200));
      return tk(null, a9, b7, false, c7);
    };
    exports2.unmountComponentAtNode = function(a9) {
      if (!rk(a9))
        throw Error(y4(40));
      return a9._reactRootContainer ? (Xj(function() {
        tk(null, null, a9, false, function() {
          a9._reactRootContainer = null;
          a9[ff] = null;
        });
      }), true) : false;
    };
    exports2.unstable_batchedUpdates = Wj;
    exports2.unstable_createPortal = function(a9, b7) {
      return uk(a9, b7, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
    };
    exports2.unstable_renderSubtreeIntoContainer = function(a9, b7, c7, d8) {
      if (!rk(c7))
        throw Error(y4(200));
      if (a9 == null || a9._reactInternals === void 0)
        throw Error(y4(38));
      return tk(a9, b7, c7, false, d8);
    };
    exports2.version = "17.0.2";
  }
});

// ../../node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "../../node_modules/react-dom/index.js"(exports2, module2) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    if (true) {
      checkDCE();
      module2.exports = require_react_dom_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/react-remove-scroll/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../../node_modules/react-remove-scroll/node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends3;
    var __assign4;
    var __rest3;
    var __decorate3;
    var __param3;
    var __metadata3;
    var __awaiter3;
    var __generator3;
    var __exportStar3;
    var __values4;
    var __read4;
    var __spread3;
    var __spreadArrays3;
    var __await3;
    var __asyncGenerator3;
    var __asyncDelegator3;
    var __asyncValues3;
    var __makeTemplateObject3;
    var __importStar3;
    var __importDefault3;
    var __classPrivateFieldGet3;
    var __classPrivateFieldSet3;
    var __createBinding3;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v6) {
          return exports3[id] = previous ? previous(id, v6) : v6;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d8, b7) {
        d8.__proto__ = b7;
      } || function(d8, b7) {
        for (var p7 in b7)
          if (b7.hasOwnProperty(p7))
            d8[p7] = b7[p7];
      };
      __extends3 = function(d8, b7) {
        extendStatics(d8, b7);
        function __() {
          this.constructor = d8;
        }
        d8.prototype = b7 === null ? Object.create(b7) : (__.prototype = b7.prototype, new __());
      };
      __assign4 = Object.assign || function(t14) {
        for (var s8, i8 = 1, n6 = arguments.length; i8 < n6; i8++) {
          s8 = arguments[i8];
          for (var p7 in s8)
            if (Object.prototype.hasOwnProperty.call(s8, p7))
              t14[p7] = s8[p7];
        }
        return t14;
      };
      __rest3 = function(s8, e12) {
        var t14 = {};
        for (var p7 in s8)
          if (Object.prototype.hasOwnProperty.call(s8, p7) && e12.indexOf(p7) < 0)
            t14[p7] = s8[p7];
        if (s8 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i8 = 0, p7 = Object.getOwnPropertySymbols(s8); i8 < p7.length; i8++) {
            if (e12.indexOf(p7[i8]) < 0 && Object.prototype.propertyIsEnumerable.call(s8, p7[i8]))
              t14[p7[i8]] = s8[p7[i8]];
          }
        return t14;
      };
      __decorate3 = function(decorators, target, key, desc) {
        var c7 = arguments.length, r13 = c7 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d8;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r13 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i8 = decorators.length - 1; i8 >= 0; i8--)
            if (d8 = decorators[i8])
              r13 = (c7 < 3 ? d8(r13) : c7 > 3 ? d8(target, key, r13) : d8(target, key)) || r13;
        return c7 > 3 && r13 && Object.defineProperty(target, key, r13), r13;
      };
      __param3 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata3 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter3 = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e12) {
              reject(e12);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e12) {
              reject(e12);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator3 = function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t14[0] & 1)
            throw t14[1];
          return t14[1];
        }, trys: [], ops: [] }, f11, y4, t14, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n6) {
          return function(v6) {
            return step([n6, v6]);
          };
        }
        function step(op) {
          if (f11)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f11 = 1, y4 && (t14 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t14 = y4["return"]) && t14.call(y4), 0) : y4.next) && !(t14 = t14.call(y4, op[1])).done)
                return t14;
              if (y4 = 0, t14)
                op = [op[0] & 2, t14.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t14 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t14 = _18.trys, t14 = t14.length > 0 && t14[t14.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t14 || op[1] > t14[0] && op[1] < t14[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t14[1]) {
                    _18.label = t14[1];
                    t14 = op;
                    break;
                  }
                  if (t14 && _18.label < t14[2]) {
                    _18.label = t14[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t14[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e12) {
              op = [6, e12];
              y4 = 0;
            } finally {
              f11 = t14 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding3 = function(o13, m7, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o13[k22] = m7[k3];
      };
      __exportStar3 = function(m7, exports3) {
        for (var p7 in m7)
          if (p7 !== "default" && !exports3.hasOwnProperty(p7))
            exports3[p7] = m7[p7];
      };
      __values4 = function(o13) {
        var s8 = typeof Symbol === "function" && Symbol.iterator, m7 = s8 && o13[s8], i8 = 0;
        if (m7)
          return m7.call(o13);
        if (o13 && typeof o13.length === "number")
          return {
            next: function() {
              if (o13 && i8 >= o13.length)
                o13 = void 0;
              return { value: o13 && o13[i8++], done: !o13 };
            }
          };
        throw new TypeError(s8 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read4 = function(o13, n6) {
        var m7 = typeof Symbol === "function" && o13[Symbol.iterator];
        if (!m7)
          return o13;
        var i8 = m7.call(o13), r13, ar = [], e12;
        try {
          while ((n6 === void 0 || n6-- > 0) && !(r13 = i8.next()).done)
            ar.push(r13.value);
        } catch (error) {
          e12 = { error };
        } finally {
          try {
            if (r13 && !r13.done && (m7 = i8["return"]))
              m7.call(i8);
          } finally {
            if (e12)
              throw e12.error;
          }
        }
        return ar;
      };
      __spread3 = function() {
        for (var ar = [], i8 = 0; i8 < arguments.length; i8++)
          ar = ar.concat(__read4(arguments[i8]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s8 = 0, i8 = 0, il = arguments.length; i8 < il; i8++)
          s8 += arguments[i8].length;
        for (var r13 = Array(s8), k3 = 0, i8 = 0; i8 < il; i8++)
          for (var a9 = arguments[i8], j4 = 0, jl = a9.length; j4 < jl; j4++, k3++)
            r13[k3] = a9[j4];
        return r13;
      };
      __await3 = function(v6) {
        return this instanceof __await3 ? (this.v = v6, this) : new __await3(v6);
      };
      __asyncGenerator3 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g5 = generator.apply(thisArg, _arguments || []), i8, q3 = [];
        return i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
          return this;
        }, i8;
        function verb(n6) {
          if (g5[n6])
            i8[n6] = function(v6) {
              return new Promise(function(a9, b7) {
                q3.push([n6, v6, a9, b7]) > 1 || resume(n6, v6);
              });
            };
        }
        function resume(n6, v6) {
          try {
            step(g5[n6](v6));
          } catch (e12) {
            settle(q3[0][3], e12);
          }
        }
        function step(r13) {
          r13.value instanceof __await3 ? Promise.resolve(r13.value.v).then(fulfill, reject) : settle(q3[0][2], r13);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f11, v6) {
          if (f11(v6), q3.shift(), q3.length)
            resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator3 = function(o13) {
        var i8, p7;
        return i8 = {}, verb("next"), verb("throw", function(e12) {
          throw e12;
        }), verb("return"), i8[Symbol.iterator] = function() {
          return this;
        }, i8;
        function verb(n6, f11) {
          i8[n6] = o13[n6] ? function(v6) {
            return (p7 = !p7) ? { value: __await3(o13[n6](v6)), done: n6 === "return" } : f11 ? f11(v6) : v6;
          } : f11;
        }
      };
      __asyncValues3 = function(o13) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m7 = o13[Symbol.asyncIterator], i8;
        return m7 ? m7.call(o13) : (o13 = typeof __values4 === "function" ? __values4(o13) : o13[Symbol.iterator](), i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
          return this;
        }, i8);
        function verb(n6) {
          i8[n6] = o13[n6] && function(v6) {
            return new Promise(function(resolve, reject) {
              v6 = o13[n6](v6), settle(resolve, reject, v6.done, v6.value);
            });
          };
        }
        function settle(resolve, reject, d8, v6) {
          Promise.resolve(v6).then(function(v7) {
            resolve({ value: v7, done: d8 });
          }, reject);
        }
      };
      __makeTemplateObject3 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar3 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (Object.hasOwnProperty.call(mod, k3))
              result[k3] = mod[k3];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault3 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet3 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet3 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends3);
      exporter("__assign", __assign4);
      exporter("__rest", __rest3);
      exporter("__decorate", __decorate3);
      exporter("__param", __param3);
      exporter("__metadata", __metadata3);
      exporter("__awaiter", __awaiter3);
      exporter("__generator", __generator3);
      exporter("__exportStar", __exportStar3);
      exporter("__createBinding", __createBinding3);
      exporter("__values", __values4);
      exporter("__read", __read4);
      exporter("__spread", __spread3);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__await", __await3);
      exporter("__asyncGenerator", __asyncGenerator3);
      exporter("__asyncDelegator", __asyncDelegator3);
      exporter("__asyncValues", __asyncValues3);
      exporter("__makeTemplateObject", __makeTemplateObject3);
      exporter("__importStar", __importStar3);
      exporter("__importDefault", __importDefault3);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
    });
  }
});

// ../../node_modules/use-sidecar/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS({
  "../../node_modules/use-sidecar/node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends3;
    var __assign4;
    var __rest3;
    var __decorate3;
    var __param3;
    var __metadata3;
    var __awaiter3;
    var __generator3;
    var __exportStar3;
    var __values4;
    var __read4;
    var __spread3;
    var __spreadArrays3;
    var __await3;
    var __asyncGenerator3;
    var __asyncDelegator3;
    var __asyncValues3;
    var __makeTemplateObject3;
    var __importStar3;
    var __importDefault3;
    var __classPrivateFieldGet3;
    var __classPrivateFieldSet3;
    var __createBinding3;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v6) {
          return exports3[id] = previous ? previous(id, v6) : v6;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d8, b7) {
        d8.__proto__ = b7;
      } || function(d8, b7) {
        for (var p7 in b7)
          if (b7.hasOwnProperty(p7))
            d8[p7] = b7[p7];
      };
      __extends3 = function(d8, b7) {
        extendStatics(d8, b7);
        function __() {
          this.constructor = d8;
        }
        d8.prototype = b7 === null ? Object.create(b7) : (__.prototype = b7.prototype, new __());
      };
      __assign4 = Object.assign || function(t14) {
        for (var s8, i8 = 1, n6 = arguments.length; i8 < n6; i8++) {
          s8 = arguments[i8];
          for (var p7 in s8)
            if (Object.prototype.hasOwnProperty.call(s8, p7))
              t14[p7] = s8[p7];
        }
        return t14;
      };
      __rest3 = function(s8, e12) {
        var t14 = {};
        for (var p7 in s8)
          if (Object.prototype.hasOwnProperty.call(s8, p7) && e12.indexOf(p7) < 0)
            t14[p7] = s8[p7];
        if (s8 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i8 = 0, p7 = Object.getOwnPropertySymbols(s8); i8 < p7.length; i8++) {
            if (e12.indexOf(p7[i8]) < 0 && Object.prototype.propertyIsEnumerable.call(s8, p7[i8]))
              t14[p7[i8]] = s8[p7[i8]];
          }
        return t14;
      };
      __decorate3 = function(decorators, target, key, desc) {
        var c7 = arguments.length, r13 = c7 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d8;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r13 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i8 = decorators.length - 1; i8 >= 0; i8--)
            if (d8 = decorators[i8])
              r13 = (c7 < 3 ? d8(r13) : c7 > 3 ? d8(target, key, r13) : d8(target, key)) || r13;
        return c7 > 3 && r13 && Object.defineProperty(target, key, r13), r13;
      };
      __param3 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata3 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter3 = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e12) {
              reject(e12);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e12) {
              reject(e12);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator3 = function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t14[0] & 1)
            throw t14[1];
          return t14[1];
        }, trys: [], ops: [] }, f11, y4, t14, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n6) {
          return function(v6) {
            return step([n6, v6]);
          };
        }
        function step(op) {
          if (f11)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f11 = 1, y4 && (t14 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t14 = y4["return"]) && t14.call(y4), 0) : y4.next) && !(t14 = t14.call(y4, op[1])).done)
                return t14;
              if (y4 = 0, t14)
                op = [op[0] & 2, t14.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t14 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t14 = _18.trys, t14 = t14.length > 0 && t14[t14.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t14 || op[1] > t14[0] && op[1] < t14[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t14[1]) {
                    _18.label = t14[1];
                    t14 = op;
                    break;
                  }
                  if (t14 && _18.label < t14[2]) {
                    _18.label = t14[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t14[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e12) {
              op = [6, e12];
              y4 = 0;
            } finally {
              f11 = t14 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding3 = function(o13, m7, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o13[k22] = m7[k3];
      };
      __exportStar3 = function(m7, exports3) {
        for (var p7 in m7)
          if (p7 !== "default" && !exports3.hasOwnProperty(p7))
            exports3[p7] = m7[p7];
      };
      __values4 = function(o13) {
        var s8 = typeof Symbol === "function" && Symbol.iterator, m7 = s8 && o13[s8], i8 = 0;
        if (m7)
          return m7.call(o13);
        if (o13 && typeof o13.length === "number")
          return {
            next: function() {
              if (o13 && i8 >= o13.length)
                o13 = void 0;
              return { value: o13 && o13[i8++], done: !o13 };
            }
          };
        throw new TypeError(s8 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read4 = function(o13, n6) {
        var m7 = typeof Symbol === "function" && o13[Symbol.iterator];
        if (!m7)
          return o13;
        var i8 = m7.call(o13), r13, ar = [], e12;
        try {
          while ((n6 === void 0 || n6-- > 0) && !(r13 = i8.next()).done)
            ar.push(r13.value);
        } catch (error) {
          e12 = { error };
        } finally {
          try {
            if (r13 && !r13.done && (m7 = i8["return"]))
              m7.call(i8);
          } finally {
            if (e12)
              throw e12.error;
          }
        }
        return ar;
      };
      __spread3 = function() {
        for (var ar = [], i8 = 0; i8 < arguments.length; i8++)
          ar = ar.concat(__read4(arguments[i8]));
        return ar;
      };
      __spreadArrays3 = function() {
        for (var s8 = 0, i8 = 0, il = arguments.length; i8 < il; i8++)
          s8 += arguments[i8].length;
        for (var r13 = Array(s8), k3 = 0, i8 = 0; i8 < il; i8++)
          for (var a9 = arguments[i8], j4 = 0, jl = a9.length; j4 < jl; j4++, k3++)
            r13[k3] = a9[j4];
        return r13;
      };
      __await3 = function(v6) {
        return this instanceof __await3 ? (this.v = v6, this) : new __await3(v6);
      };
      __asyncGenerator3 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g5 = generator.apply(thisArg, _arguments || []), i8, q3 = [];
        return i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
          return this;
        }, i8;
        function verb(n6) {
          if (g5[n6])
            i8[n6] = function(v6) {
              return new Promise(function(a9, b7) {
                q3.push([n6, v6, a9, b7]) > 1 || resume(n6, v6);
              });
            };
        }
        function resume(n6, v6) {
          try {
            step(g5[n6](v6));
          } catch (e12) {
            settle(q3[0][3], e12);
          }
        }
        function step(r13) {
          r13.value instanceof __await3 ? Promise.resolve(r13.value.v).then(fulfill, reject) : settle(q3[0][2], r13);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f11, v6) {
          if (f11(v6), q3.shift(), q3.length)
            resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator3 = function(o13) {
        var i8, p7;
        return i8 = {}, verb("next"), verb("throw", function(e12) {
          throw e12;
        }), verb("return"), i8[Symbol.iterator] = function() {
          return this;
        }, i8;
        function verb(n6, f11) {
          i8[n6] = o13[n6] ? function(v6) {
            return (p7 = !p7) ? { value: __await3(o13[n6](v6)), done: n6 === "return" } : f11 ? f11(v6) : v6;
          } : f11;
        }
      };
      __asyncValues3 = function(o13) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m7 = o13[Symbol.asyncIterator], i8;
        return m7 ? m7.call(o13) : (o13 = typeof __values4 === "function" ? __values4(o13) : o13[Symbol.iterator](), i8 = {}, verb("next"), verb("throw"), verb("return"), i8[Symbol.asyncIterator] = function() {
          return this;
        }, i8);
        function verb(n6) {
          i8[n6] = o13[n6] && function(v6) {
            return new Promise(function(resolve, reject) {
              v6 = o13[n6](v6), settle(resolve, reject, v6.done, v6.value);
            });
          };
        }
        function settle(resolve, reject, d8, v6) {
          Promise.resolve(v6).then(function(v7) {
            resolve({ value: v7, done: d8 });
          }, reject);
        }
      };
      __makeTemplateObject3 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      __importStar3 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (Object.hasOwnProperty.call(mod, k3))
              result[k3] = mod[k3];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault3 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet3 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet3 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends3);
      exporter("__assign", __assign4);
      exporter("__rest", __rest3);
      exporter("__decorate", __decorate3);
      exporter("__param", __param3);
      exporter("__metadata", __metadata3);
      exporter("__awaiter", __awaiter3);
      exporter("__generator", __generator3);
      exporter("__exportStar", __exportStar3);
      exporter("__createBinding", __createBinding3);
      exporter("__values", __values4);
      exporter("__read", __read4);
      exporter("__spread", __spread3);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__await", __await3);
      exporter("__asyncGenerator", __asyncGenerator3);
      exporter("__asyncDelegator", __asyncDelegator3);
      exporter("__asyncValues", __asyncValues3);
      exporter("__makeTemplateObject", __makeTemplateObject3);
      exporter("__importStar", __importStar3);
      exporter("__importDefault", __importDefault3);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
    });
  }
});

// ../../node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "../../node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports2, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// ../../node_modules/prop-types/factoryWithThrowingShims.js
var require_factoryWithThrowingShims = __commonJS({
  "../../node_modules/prop-types/factoryWithThrowingShims.js"(exports2, module2) {
    "use strict";
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    module2.exports = function() {
      function shim(props, propName, componentName, location2, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
        err.name = "Invariant Violation";
        throw err;
      }
      ;
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      ;
      var ReactPropTypes = {
        array: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// ../../node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "../../node_modules/prop-types/index.js"(exports2, module2) {
    if (false) {
      ReactIs = null;
      throwOnDirectAccess = true;
      module2.exports = null(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = require_factoryWithThrowingShims()();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// ../../node_modules/path-to-regexp/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../../node_modules/path-to-regexp/node_modules/isarray/index.js"(exports2, module2) {
    module2.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "../../node_modules/path-to-regexp/index.js"(exports2, module2) {
    var isarray = require_isarray();
    module2.exports = pathToRegexp2;
    module2.exports.parse = parse3;
    module2.exports.compile = compile;
    module2.exports.tokensToFunction = tokensToFunction;
    module2.exports.tokensToRegExp = tokensToRegExp;
    var PATH_REGEXP = new RegExp([
      "(\\\\.)",
      "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
    ].join("|"), "g");
    function parse3(str, options2) {
      var tokens = [];
      var key = 0;
      var index2 = 0;
      var path = "";
      var defaultDelimiter = options2 && options2.delimiter || "/";
      var res;
      while ((res = PATH_REGEXP.exec(str)) != null) {
        var m7 = res[0];
        var escaped = res[1];
        var offset = res.index;
        path += str.slice(index2, offset);
        index2 = offset + m7.length;
        if (escaped) {
          path += escaped[1];
          continue;
        }
        var next = str[index2];
        var prefix2 = res[2];
        var name = res[3];
        var capture = res[4];
        var group = res[5];
        var modifier = res[6];
        var asterisk = res[7];
        if (path) {
          tokens.push(path);
          path = "";
        }
        var partial = prefix2 != null && next != null && next !== prefix2;
        var repeat = modifier === "+" || modifier === "*";
        var optional = modifier === "?" || modifier === "*";
        var delimiter = res[2] || defaultDelimiter;
        var pattern = capture || group;
        tokens.push({
          name: name || key++,
          prefix: prefix2 || "",
          delimiter,
          optional,
          repeat,
          partial,
          asterisk: !!asterisk,
          pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
        });
      }
      if (index2 < str.length) {
        path += str.substr(index2);
      }
      if (path) {
        tokens.push(path);
      }
      return tokens;
    }
    function compile(str, options2) {
      return tokensToFunction(parse3(str, options2), options2);
    }
    function encodeURIComponentPretty(str) {
      return encodeURI(str).replace(/[\/?#]/g, function(c7) {
        return "%" + c7.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeAsterisk(str) {
      return encodeURI(str).replace(/[?#]/g, function(c7) {
        return "%" + c7.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function tokensToFunction(tokens, options2) {
      var matches = new Array(tokens.length);
      for (var i8 = 0; i8 < tokens.length; i8++) {
        if (typeof tokens[i8] === "object") {
          matches[i8] = new RegExp("^(?:" + tokens[i8].pattern + ")$", flags(options2));
        }
      }
      return function(obj, opts) {
        var path = "";
        var data = obj || {};
        var options3 = opts || {};
        var encode = options3.pretty ? encodeURIComponentPretty : encodeURIComponent;
        for (var i9 = 0; i9 < tokens.length; i9++) {
          var token = tokens[i9];
          if (typeof token === "string") {
            path += token;
            continue;
          }
          var value = data[token.name];
          var segment;
          if (value == null) {
            if (token.optional) {
              if (token.partial) {
                path += token.prefix;
              }
              continue;
            } else {
              throw new TypeError('Expected "' + token.name + '" to be defined');
            }
          }
          if (isarray(value)) {
            if (!token.repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
            }
            if (value.length === 0) {
              if (token.optional) {
                continue;
              } else {
                throw new TypeError('Expected "' + token.name + '" to not be empty');
              }
            }
            for (var j4 = 0; j4 < value.length; j4++) {
              segment = encode(value[j4]);
              if (!matches[i9].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
              }
              path += (j4 === 0 ? token.prefix : token.delimiter) + segment;
            }
            continue;
          }
          segment = token.asterisk ? encodeAsterisk(value) : encode(value);
          if (!matches[i9].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
          }
          path += token.prefix + segment;
        }
        return path;
      };
    }
    function escapeString(str) {
      return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
    }
    function escapeGroup(group) {
      return group.replace(/([=!:$\/()])/g, "\\$1");
    }
    function attachKeys(re2, keys) {
      re2.keys = keys;
      return re2;
    }
    function flags(options2) {
      return options2 && options2.sensitive ? "" : "i";
    }
    function regexpToRegexp(path, keys) {
      var groups = path.source.match(/\((?!\?)/g);
      if (groups) {
        for (var i8 = 0; i8 < groups.length; i8++) {
          keys.push({
            name: i8,
            prefix: null,
            delimiter: null,
            optional: false,
            repeat: false,
            partial: false,
            asterisk: false,
            pattern: null
          });
        }
      }
      return attachKeys(path, keys);
    }
    function arrayToRegexp(path, keys, options2) {
      var parts = [];
      for (var i8 = 0; i8 < path.length; i8++) {
        parts.push(pathToRegexp2(path[i8], keys, options2).source);
      }
      var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options2));
      return attachKeys(regexp, keys);
    }
    function stringToRegexp(path, keys, options2) {
      return tokensToRegExp(parse3(path, options2), keys, options2);
    }
    function tokensToRegExp(tokens, keys, options2) {
      if (!isarray(keys)) {
        options2 = keys || options2;
        keys = [];
      }
      options2 = options2 || {};
      var strict = options2.strict;
      var end = options2.end !== false;
      var route = "";
      for (var i8 = 0; i8 < tokens.length; i8++) {
        var token = tokens[i8];
        if (typeof token === "string") {
          route += escapeString(token);
        } else {
          var prefix2 = escapeString(token.prefix);
          var capture = "(?:" + token.pattern + ")";
          keys.push(token);
          if (token.repeat) {
            capture += "(?:" + prefix2 + capture + ")*";
          }
          if (token.optional) {
            if (!token.partial) {
              capture = "(?:" + prefix2 + "(" + capture + "))?";
            } else {
              capture = prefix2 + "(" + capture + ")?";
            }
          } else {
            capture = prefix2 + "(" + capture + ")";
          }
          route += capture;
        }
      }
      var delimiter = escapeString(options2.delimiter || "/");
      var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
      if (!strict) {
        route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
      }
      if (end) {
        route += "$";
      } else {
        route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
      }
      return attachKeys(new RegExp("^" + route, flags(options2)), keys);
    }
    function pathToRegexp2(path, keys, options2) {
      if (!isarray(keys)) {
        options2 = keys || options2;
        keys = [];
      }
      options2 = options2 || {};
      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys);
      }
      if (isarray(path)) {
        return arrayToRegexp(path, keys, options2);
      }
      return stringToRegexp(path, keys, options2);
    }
  }
});

// ../../node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS({
  "../../node_modules/react-is/cjs/react-is.production.min.js"(exports2) {
    "use strict";
    var b7 = typeof Symbol === "function" && Symbol.for;
    var c7 = b7 ? Symbol.for("react.element") : 60103;
    var d8 = b7 ? Symbol.for("react.portal") : 60106;
    var e12 = b7 ? Symbol.for("react.fragment") : 60107;
    var f11 = b7 ? Symbol.for("react.strict_mode") : 60108;
    var g5 = b7 ? Symbol.for("react.profiler") : 60114;
    var h3 = b7 ? Symbol.for("react.provider") : 60109;
    var k3 = b7 ? Symbol.for("react.context") : 60110;
    var l9 = b7 ? Symbol.for("react.async_mode") : 60111;
    var m7 = b7 ? Symbol.for("react.concurrent_mode") : 60111;
    var n6 = b7 ? Symbol.for("react.forward_ref") : 60112;
    var p7 = b7 ? Symbol.for("react.suspense") : 60113;
    var q3 = b7 ? Symbol.for("react.suspense_list") : 60120;
    var r13 = b7 ? Symbol.for("react.memo") : 60115;
    var t14 = b7 ? Symbol.for("react.lazy") : 60116;
    var v6 = b7 ? Symbol.for("react.block") : 60121;
    var w6 = b7 ? Symbol.for("react.fundamental") : 60117;
    var x5 = b7 ? Symbol.for("react.responder") : 60118;
    var y4 = b7 ? Symbol.for("react.scope") : 60119;
    function z3(a9) {
      if (typeof a9 === "object" && a9 !== null) {
        var u4 = a9.$$typeof;
        switch (u4) {
          case c7:
            switch (a9 = a9.type, a9) {
              case l9:
              case m7:
              case e12:
              case g5:
              case f11:
              case p7:
                return a9;
              default:
                switch (a9 = a9 && a9.$$typeof, a9) {
                  case k3:
                  case n6:
                  case t14:
                  case r13:
                  case h3:
                    return a9;
                  default:
                    return u4;
                }
            }
          case d8:
            return u4;
        }
      }
    }
    function A4(a9) {
      return z3(a9) === m7;
    }
    exports2.AsyncMode = l9;
    exports2.ConcurrentMode = m7;
    exports2.ContextConsumer = k3;
    exports2.ContextProvider = h3;
    exports2.Element = c7;
    exports2.ForwardRef = n6;
    exports2.Fragment = e12;
    exports2.Lazy = t14;
    exports2.Memo = r13;
    exports2.Portal = d8;
    exports2.Profiler = g5;
    exports2.StrictMode = f11;
    exports2.Suspense = p7;
    exports2.isAsyncMode = function(a9) {
      return A4(a9) || z3(a9) === l9;
    };
    exports2.isConcurrentMode = A4;
    exports2.isContextConsumer = function(a9) {
      return z3(a9) === k3;
    };
    exports2.isContextProvider = function(a9) {
      return z3(a9) === h3;
    };
    exports2.isElement = function(a9) {
      return typeof a9 === "object" && a9 !== null && a9.$$typeof === c7;
    };
    exports2.isForwardRef = function(a9) {
      return z3(a9) === n6;
    };
    exports2.isFragment = function(a9) {
      return z3(a9) === e12;
    };
    exports2.isLazy = function(a9) {
      return z3(a9) === t14;
    };
    exports2.isMemo = function(a9) {
      return z3(a9) === r13;
    };
    exports2.isPortal = function(a9) {
      return z3(a9) === d8;
    };
    exports2.isProfiler = function(a9) {
      return z3(a9) === g5;
    };
    exports2.isStrictMode = function(a9) {
      return z3(a9) === f11;
    };
    exports2.isSuspense = function(a9) {
      return z3(a9) === p7;
    };
    exports2.isValidElementType = function(a9) {
      return typeof a9 === "string" || typeof a9 === "function" || a9 === e12 || a9 === m7 || a9 === g5 || a9 === f11 || a9 === p7 || a9 === q3 || typeof a9 === "object" && a9 !== null && (a9.$$typeof === t14 || a9.$$typeof === r13 || a9.$$typeof === h3 || a9.$$typeof === k3 || a9.$$typeof === n6 || a9.$$typeof === w6 || a9.$$typeof === x5 || a9.$$typeof === y4 || a9.$$typeof === v6);
    };
    exports2.typeOf = z3;
  }
});

// ../../node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../../node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (true) {
      module2.exports = require_react_is_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports2, module2) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty4 = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype3 = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype3) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype3) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i8 = 0; i8 < keys.length; ++i8) {
          var key = keys[i8];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty4(targetComponent, key, descriptor);
            } catch (e12) {
            }
          }
        }
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics;
  }
});

// src/index.tsx
var import_react123 = __toModule(require_react());
var import_react_dom3 = __toModule(require_react_dom());

// src/app.tsx
var React9 = __toModule(require_react());

// ../../packages/tldraw/dist/esm/index.js
var import_react60 = __toModule(require_react());

// ../../node_modules/mobx/dist/mobx.esm.js
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (false) {
    var e12 = typeof error === "string" ? error : errors[error];
    if (typeof e12 === "function")
      e12 = e12.apply(null, args);
    throw new Error("[MobX] " + e12);
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die(false ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
  }
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked)
      return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop2() {
};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t14 = typeof value;
  switch (t14) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  var _proto$constructor;
  if (!isObject(value))
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null)
    return true;
  return ((_proto$constructor = proto.constructor) == null ? void 0 : _proto$constructor.toString()) === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor)
    return false;
  if (constructor.name === "GeneratorFunction" || constructor.displayName === "GeneratorFunction")
    return true;
  return false;
}
function addHiddenProp(object3, propName, value) {
  defineProperty(object3, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object3, propName, value) {
  defineProperty(object3, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x5) {
    return isObject(x5) && x5[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object3) {
  var keys = Object.keys(object3);
  if (!hasGetOwnPropertySymbols)
    return keys;
  var symbols = Object.getOwnPropertySymbols(object3);
  if (!symbols.length)
    return keys;
  return [].concat(keys, symbols.filter(function(s8) {
    return objectPrototype.propertyIsEnumerable.call(object3, s8);
  }));
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : Object.getOwnPropertyNames;
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys(target).forEach(function(key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function _defineProperties(target, props) {
  for (var i8 = 0; i8 < props.length; i8++) {
    var descriptor = props[i8];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i8 = 1; i8 < arguments.length; i8++) {
      var source = arguments[i8];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray(o13, minLen) {
  if (!o13)
    return;
  if (typeof o13 === "string")
    return _arrayLikeToArray(o13, minLen);
  var n6 = Object.prototype.toString.call(o13).slice(8, -1);
  if (n6 === "Object" && o13.constructor)
    n6 = o13.constructor.name;
  if (n6 === "Map" || n6 === "Set")
    return Array.from(o13);
  if (n6 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n6))
    return _arrayLikeToArray(o13, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i8 = 0, arr2 = new Array(len); i8 < len; i8++)
    arr2[i8] = arr[i8];
  return arr2;
}
function _createForOfIteratorHelperLoose(o13, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o13[Symbol.iterator] == null) {
    if (Array.isArray(o13) || (it = _unsupportedIterableToArray(o13)) || allowArrayLike && o13 && typeof o13.length === "number") {
      if (it)
        o13 = it;
      var i8 = 0;
      return function() {
        if (i8 >= o13.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o13[i8++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o13[Symbol.iterator]();
  return it.next.bind(it);
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  }
  if (false) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(prototype, annotation, key);
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function assertNotDecorated(prototype, annotation, key) {
  if (false) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overriden by subclass.");
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    if (false) {
      die("No annotations were passed to makeObservable, but no decorated members have been found either");
    }
    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration");
var Atom = /* @__PURE__ */ function() {
  function Atom3(name_) {
    if (name_ === void 0) {
      name_ = false ? "Atom@" + getNextId() : "Atom";
    }
    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  var _proto = Atom3.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString3() {
    return this.name_;
  };
  return Atom3;
}();
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a9, b7) {
  return a9 === b7;
}
function structuralComparer(a9, b7) {
  return deepEqual(a9, b7);
}
function shallowComparer(a9, b7) {
  return deepEqual(a9, b7, 1);
}
function defaultComparer(a9, b7) {
  if (Object.is)
    return Object.is(a9, b7);
  return a9 === b7 ? a9 !== 0 || 1 / a9 === 1 / b7 : a9 !== a9 && b7 !== b7;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v6, _18, name) {
  if (isObservable(v6))
    return v6;
  if (Array.isArray(v6))
    return observable.array(v6, {
      name
    });
  if (isPlainObject(v6))
    return observable.object(v6, void 0, {
      name
    });
  if (isES6Map(v6))
    return observable.map(v6, {
      name
    });
  if (isES6Set(v6))
    return observable.set(v6, {
      name
    });
  if (typeof v6 === "function" && !isAction(v6) && !isFlow(v6)) {
    if (isGenerator(v6)) {
      return flow(v6);
    } else {
      return autoAction(name, v6);
    }
  }
  return v6;
}
function shallowEnhancer(v6, _18, name) {
  if (v6 === void 0 || v6 === null)
    return v6;
  if (isObservableObject(v6) || isObservableArray(v6) || isObservableMap(v6) || isObservableSet(v6))
    return v6;
  if (Array.isArray(v6))
    return observable.array(v6, {
      name,
      deep: false
    });
  if (isPlainObject(v6))
    return observable.object(v6, void 0, {
      name,
      deep: false
    });
  if (isES6Map(v6))
    return observable.map(v6, {
      name,
      deep: false
    });
  if (isES6Set(v6))
    return observable.set(v6, {
      name,
      deep: false
    });
  if (false)
    die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v6, oldValue) {
  if (false)
    die("observable.struct should not be used with observable values");
  if (deepEqual(v6, oldValue))
    return oldValue;
  return v6;
}
var OVERRIDE = "override";
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function createActionAnnotation(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$1,
    extend_: extend_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, ((_annotation$options_4 = annotation.options_) == null ? void 0 : _annotation$options_4.bound) ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0),
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    enumerable: false,
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$2,
    extend_: extend_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) && !isFlow(adm.target_[key])) {
    if (this.extend_(adm, key, descriptor, false) === null)
      return 0;
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: flow(value),
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    enumerable: false,
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$3,
    extend_: extend_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get5 = _ref2.get;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}
function createObservableAnnotation(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$4,
    extend_: extend_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;
  if (false) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}
var AUTO = "true";
var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(options2) {
  return {
    annotationType_: AUTO,
    options_: options2,
    make_: make_$5,
    extend_: extend_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set6 = createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set6
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set6
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation3 = ((_this$options_ = this.options_) == null ? void 0 : _this$options_.autoBind) ? flow.bound : flow;
      return flowAnnotation3.make_(adm, key, descriptor, source);
    }
    var actionAnnotation3 = ((_this$options_2 = this.options_) == null ? void 0 : _this$options_2.autoBind) ? autoAction.bound : autoAction;
    return actionAnnotation3.make_(adm, key, descriptor, source);
  }
  var observableAnnotation3 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && ((_this$options_4 = this.options_) == null ? void 0 : _this$options_4.autoBind)) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation3.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && ((_this$options_5 = this.options_) == null ? void 0 : _this$options_5.autoBind)) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation3 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation3.extend_(adm, key, descriptor, proxyTrap);
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options2) {
  return options2.deep === true ? deepEnhancer : options2.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options2.defaultDecorator);
}
function getAnnotationFromOptions(options2) {
  var _options$defaultDecor;
  return options2 ? (_options$defaultDecor = options2.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options2) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v6, arg2, arg3) {
  if (isStringish(arg2)) {
    storeAnnotation(v6, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v6))
    return v6;
  if (isPlainObject(v6))
    return observable.object(v6, arg2, arg3);
  if (Array.isArray(v6))
    return observable.array(v6, arg2);
  if (isES6Map(v6))
    return observable.map(v6, arg2);
  if (isES6Set(v6))
    return observable.set(v6, arg2);
  if (typeof v6 === "object" && v6 !== null)
    return v6;
  return observable.box(v6, arg2);
}
Object.assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options2) {
    var o13 = asCreateObservableOptions(options2);
    return new ObservableValue(value, getEnhancerFromOptions(o13), o13.name, true, o13.equals);
  },
  array: function array(initialValues, options2) {
    var o13 = asCreateObservableOptions(options2);
    return (globalState.useProxies === false || o13.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o13), o13.name);
  },
  map: function map(initialValues, options2) {
    var o13 = asCreateObservableOptions(options2);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o13), o13.name);
  },
  set: function set(initialValues, options2) {
    var o13 = asCreateObservableOptions(options2);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o13), o13.name);
  },
  object: function object(props, decorators, options2) {
    return extendObservable(globalState.useProxies === false || (options2 == null ? void 0 : options2.proxy) === false ? asObservableObject({}, options2) : asDynamicObservableObject({}, options2), props, decorators);
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
};
var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  if (false) {
    if (!isFunction(arg1))
      die("First argument to `computed` should be an expression.");
    if (isFunction(arg2))
      die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  }
  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config;
var _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction3, ref) {
  if (autoAction3 === void 0) {
    autoAction3 = false;
  }
  if (false) {
    if (!isFunction(fn))
      die("`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName)
      die("actions should have valid names, got: '" + actionName + "'");
  }
  function res() {
    return executeAction(actionName, autoAction3, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    Object.defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = false;
  var startTime_ = 0;
  if (false) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_)
    untrackedEnd(runInfo.prevDerivation_);
  if (false) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var _Symbol$toPrimitive;
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /* @__PURE__ */ function(_Atom) {
  _inheritsLoose(ObservableValue3, _Atom);
  function ObservableValue3(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = false ? "ObservableValue@" + getNextId() : "ObservableValue";
    }
    if (notifySpy === void 0) {
      notifySpy = true;
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    if (false) {
      spyReport({
        type: CREATE,
        object: _assertThisInitialized(_this),
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }
    return _this;
  }
  var _proto = ObservableValue3.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0)
      return this.dehancer(value);
    return value;
  };
  _proto.set = function set6(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      if (false) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue,
          oldValue
        });
      }
      this.setNewValue_(newValue);
      if (false)
        spyReportEnd();
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change)
        return globalState.UNCHANGED;
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get5() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately)
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON3() {
    return this.get();
  };
  _proto.toString = function toString3() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive] = function() {
    return this.valueOf();
  };
  return ObservableValue3;
}(Atom);
var _Symbol$toPrimitive$1;
_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /* @__PURE__ */ function() {
  function ComputedValue3(options2) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options2.get)
      die(31);
    this.derivation = options2.get;
    this.name_ = options2.name || (false ? "ComputedValue@" + getNextId() : "ComputedValue");
    if (options2.set) {
      this.setter_ = createAction(false ? this.name_ + "-setter" : "ComputedValue-setter", options2.set);
    }
    this.equals_ = options2.equals || (options2.compareStructural || options2.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options2.context;
    this.requiresReaction_ = !!options2.requiresReaction;
    this.keepAlive_ = !!options2.keepAlive;
  }
  var _proto = ComputedValue3.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get5() {
    if (this.isComputing_)
      die(32, this.name_, this.derivation);
    if (globalState.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext)
          globalState.trackingContext = this;
        if (this.trackAndCompute())
          propagateChangeConfirmed(this);
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result))
      throw result.cause;
    return result;
  };
  _proto.set = function set6(value) {
    if (this.setter_) {
      if (this.isRunningSetter_)
        die(33, this.name_);
      this.isRunningSetter_ = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else
      die(34, this.name_);
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
      if (false) {
        spyReport({
          observableKind: "computed",
          debugObjectName: this.name_,
          object: this.scope_,
          type: "update",
          oldValue,
          newValue
        });
      }
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true;
    var prev = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e12) {
          res = new CaughtException(e12);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
      if (false) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    if (true)
      return;
    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
    if (globalState.computedRequiresReaction || this.requiresReaction_) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };
  _proto.toString = function toString3() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive$1] = function() {
    return this.valueOf();
  };
  return ComputedValue3;
}();
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_3) {
  IDerivationState_3[IDerivationState_3["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_3[IDerivationState_3["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_3[IDerivationState_3["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_3[IDerivationState_3["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode3) {
  TraceMode3[TraceMode3["NONE"] = 0] = "NONE";
  TraceMode3[TraceMode3["LOG"] = 1] = "LOG";
  TraceMode3[TraceMode3["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e12) {
  return e12 instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l9 = obs.length;
      for (var i8 = 0; i8 < l9; i8++) {
        var obj = obs[i8];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e12) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  if (true) {
    return;
  }
  var hasObservers = atom.observers_.size > 0;
  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always"))
    console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
}
function checkIfStateReadsAreAllowed(observable3) {
  if (false) {
    console.warn("[mobx] Observable '" + observable3.name_ + "' being read outside a reactive context.");
  }
}
function trackDerivedFunction(derivation, f11, context2) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f11.call(context2);
  } else {
    try {
      result = f11.call(context2);
    } catch (e12) {
      result = new CaughtException(e12);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
  if (true)
    return;
  if (derivation.observing_.length !== 0)
    return;
  if (globalState.reactionRequiresObservable || derivation.requiresObservable_) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l9 = derivation.unboundDepsCount_;
  for (var i8 = 0; i8 < l9; i8++) {
    var dep = observing[i8];
    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i8)
        observing[i0] = dep;
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l9 = prevObserving.length;
  while (l9--) {
    var _dep = prevObserving[l9];
    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue_ = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i8 = obs.length;
  while (i8--) {
    removeObserver(obs[i8], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action3) {
  var prev = untrackedStart();
  try {
    return action3();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_)
    return;
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i8 = obs.length;
  while (i8--) {
    obs[i8].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /* @__PURE__ */ function() {
  var global2 = /* @__PURE__ */ getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals)
    canMergeGlobalState = false;
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version)
    canMergeGlobalState = false;
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED)
      global2.__mobxGlobals.UNCHANGED = {};
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions)
    die(36);
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global2 = getGlobal();
    if (--global2.__mobxInstanceCount === 0)
      global2.__mobxGlobals = void 0;
    globalState = new MobXGlobals();
  }
}
function addObserver(observable3, node) {
  observable3.observers_.add(node);
  if (observable3.lowestObserverState_ > node.dependenciesState_)
    observable3.lowestObserverState_ = node.dependenciesState_;
}
function removeObserver(observable3, node) {
  observable3.observers_["delete"](node);
  if (observable3.observers_.size === 0) {
    queueForUnobservation(observable3);
  }
}
function queueForUnobservation(observable3) {
  if (observable3.isPendingUnobservation_ === false) {
    observable3.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable3);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i8 = 0; i8 < list.length; i8++) {
      var observable3 = list[i8];
      observable3.isPendingUnobservation_ = false;
      if (observable3.observers_.size === 0) {
        if (observable3.isBeingObserved_) {
          observable3.isBeingObserved_ = false;
          observable3.onBUO();
        }
        if (observable3 instanceof ComputedValue) {
          observable3.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable3) {
  checkIfStateReadsAreAllowed(observable3);
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable3.lastAccessedBy_) {
      observable3.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable3;
      if (!observable3.isBeingObserved_ && globalState.trackingContext) {
        observable3.isBeingObserved_ = true;
        observable3.onBO();
      }
    }
    return true;
  } else if (observable3.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable3);
  }
  return false;
}
function propagateChanged(observable3) {
  if (observable3.lowestObserverState_ === IDerivationState_.STALE_)
    return;
  observable3.lowestObserverState_ = IDerivationState_.STALE_;
  observable3.observers_.forEach(function(d8) {
    if (d8.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if (false) {
        logTraceInfo(d8, observable3);
      }
      d8.onBecomeStale_();
    }
    d8.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable3) {
  if (observable3.lowestObserverState_ === IDerivationState_.STALE_)
    return;
  observable3.lowestObserverState_ = IDerivationState_.STALE_;
  observable3.observers_.forEach(function(d8) {
    if (d8.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d8.dependenciesState_ = IDerivationState_.STALE_;
      if (false) {
        logTraceInfo(d8, observable3);
      }
    } else if (d8.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable3.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable3) {
  if (observable3.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_)
    return;
  observable3.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable3.observers_.forEach(function(d8) {
    if (d8.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d8.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d8.onBecomeStale_();
    }
  });
}
var Reaction = /* @__PURE__ */ function() {
  function Reaction3(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = false ? "Reaction@" + getNextId() : "Reaction";
    }
    if (requiresObservable_ === void 0) {
      requiresObservable_ = false;
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction3.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending_ = true;
        try {
          this.onInvalidate_();
          if (false) {
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e12) {
          this.reportExceptionInDerivation_(e12);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return;
    }
    startBatch();
    var notify = isSpyEnabled();
    var startTime;
    if (false) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }
    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;
    if (this.isDisposed_) {
      clearObserving(this);
    }
    if (isCaughtException(result))
      this.reportExceptionInDerivation_(result.cause);
    if (false) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries)
      throw error;
    var message = false ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
    } else if (false)
      console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
    if (false) {
      spyReport({
        type: "error",
        name: this.name_,
        message,
        error: "" + error
      });
    }
    globalState.globalReactionErrorHandlers.forEach(function(f11) {
      return f11(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;
      if (!this.isRunning_) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_() {
    var r13 = this.dispose.bind(this);
    r13[$mobx] = this;
    return r13;
  };
  _proto.toString = function toString3() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }
    trace(this, enterBreakPoint);
  };
  return Reaction3;
}();
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f11) {
  return f11();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions)
    return;
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error(false ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i8 = 0, l9 = remainingReactions.length; i8 < l9; i8++) {
      remainingReactions[i8].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler4(f11) {
    return fn(function() {
      return baseScheduler(f11);
    });
  };
}
function isSpyEnabled() {
  return false;
}
function spy(listener) {
  if (true) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  } else {
    globalState.spyListeners.push(listener);
    return once(function() {
      globalState.spyListeners = globalState.spyListeners.filter(function(l9) {
        return l9 !== listener;
      });
    });
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction3) {
  var res = function action3(arg1, arg2) {
    if (isFunction(arg1))
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction3);
    if (isFunction(arg2))
      return createAction(arg1, arg2, autoAction3);
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction3 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction3 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction3
      }));
    }
    if (false)
      die("Invalid arguments for `action`");
  };
  return res;
}
var action = /* @__PURE__ */ createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (false) {
    if (!isFunction(view))
      die("Autorun expects a function as first argument");
    if (isAction(view))
      die("Autorun does not accept actions since actions are untrackable");
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : false ? view.name || "Autorun@" + getNextId() : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;
  if (runSync) {
    reaction = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction = new Reaction(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction.isDisposed_)
            reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction);
  }
  reaction.schedule_();
  return reaction.getDisposer_();
}
var run = function run2(f11) {
  return f11();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f11) {
    return setTimeout(f11, opts.delay);
  } : run;
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed";
function configure(options2) {
  if (options2.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options2.useProxies, enforceActions = options2.enforceActions;
  if (useProxies !== void 0) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable")
    globalState.verifyProxies = true;
  if (enforceActions !== void 0) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
    if (key in options2)
      globalState[key] = !!options2[key];
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (false) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }
  if (options2.reactionScheduler) {
    setReactionScheduler(options2.reactionScheduler);
  }
}
function extendObservable(target, properties, annotations, options2) {
  if (false) {
    if (arguments.length > 4)
      die("'extendObservable' expected 2-4 arguments");
    if (typeof target !== "object")
      die("'extendObservable' expects an object as first argument");
    if (isObservableMap(target))
      die("'extendObservable' should not be used on maps, use map.merge instead");
    if (!isPlainObject(properties))
      die("'extendObservable' only accepts plain objects as second argument");
    if (isObservable(properties) || isObservable(annotations))
      die("Extending an object with another observable (object) is not supported");
  }
  var descriptors = getOwnPropertyDescriptors(properties);
  var adm = asObservableObject(target, options2)[$mobx];
  startBatch();
  try {
    ownKeys(descriptors).forEach(function(key) {
      adm.extend_(key, descriptors[key], !annotations ? true : key in annotations ? annotations[key] : true);
    });
  } finally {
    endBatch();
  }
  return target;
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0)
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  if (false)
    die("Flow expects single argument with generator function");
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e12) {
          return reject(e12);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e12) {
          return reject(e12);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject);
          return;
        }
        if (ret.done)
          return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise)
          cancelPromise(pendingPromise);
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e12) {
        rejector(e12);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction(promise.cancel))
    promise.cancel();
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}
function _isObservable(value, property) {
  if (!value)
    return false;
  if (property !== void 0) {
    if (false)
      return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (false)
    die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}
function trace() {
  if (true)
    die("trace() is not available in production builds");
  var enterBreakPoint = false;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[args.length - 1] === "boolean")
    enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);
  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }
  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args[0]);
    case 2:
      return getAtom(args[0], args[1]);
  }
}
function transaction(action3, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action3.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has(target, name) {
    if (false)
      warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set2(target, name, value) {
    var _getAdm$set_;
    if (!isStringish(name))
      return false;
    if (false) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    }
    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;
    if (false) {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }
    if (!isStringish(name))
      return false;
    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name, descriptor) {
    var _getAdm$definePropert;
    if (false) {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    }
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys2(target) {
    if (false)
      warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options2) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options2);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1)
      interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i8 = 0, l9 = interceptors.length; i8 < l9; i8++) {
      change = interceptors[i8](change);
      if (change && !change.type)
        die(14);
      if (!change)
        break;
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1)
      listeners.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners)
    return;
  listeners = listeners.slice();
  for (var i8 = 0, l9 = listeners.length; i8 < l9; i8++) {
    listeners[i8](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options2) {
  var adm = asObservableObject(target, options2)[$mobx];
  startBatch();
  try {
    var _annotations;
    if (false) {
      die("makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.");
    }
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys(annotations).forEach(function(key) {
      return adm.make_(key, annotations[key]);
    });
  } finally {
    endBatch();
  }
  return target;
}
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get2(target, name) {
    var adm = target[$mobx];
    if (name === $mobx)
      return adm;
    if (name === "length")
      return adm.getArrayLength_();
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function set3(target, name, value) {
    var adm = target[$mobx];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ObservableArrayAdministration3(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, false ? name + "[..]" : "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration3.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0)
      return this.dehancer(value);
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== void 0 && values.length > 0)
      return values.map(this.dehancer);
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0)
      die("Out of range: " + newLength);
    var currentLength = this.values_.length;
    if (newLength === currentLength)
      return;
    else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i8 = 0; i8 < newLength - currentLength; i8++) {
        newItems[i8] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else
      this.spliceWithArray_(newLength, currentLength - newLength);
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_)
      die(16);
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0)
      reserveArrayBuffer(oldLength + delta + 1);
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index2 === void 0)
      index2 = 0;
    else if (index2 > length)
      index2 = length;
    else if (index2 < 0)
      index2 = Math.max(0, length + index2);
    if (arguments.length === 1)
      deleteCount = length - index2;
    else if (deleteCount === void 0 || deleteCount === null)
      deleteCount = 0;
    else
      deleteCount = Math.max(0, Math.min(deleteCount, length - index2));
    if (newItems === void 0)
      newItems = EMPTY_ARRAY;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index2,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change)
        return EMPTY_ARRAY;
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v6) {
      return _this.enhancer_(v6, void 0);
    });
    if (this.legacyMode_ || false) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0)
      this.notifyArraySplice_(index2, newItems, res);
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index2, index2 + deleteCount);
      var oldItems = this.values_.slice(index2 + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i8 = 0; i8 < newItems.length; i8++) {
        this.values_[index2 + i8] = newItems[i8];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index2 + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index2,
      newValue,
      oldValue
    } : null;
    if (false)
      spyReportStart(change);
    this.atom_.reportChanged();
    if (notify)
      notifyListeners(this, change);
    if (false)
      spyReportEnd();
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index2,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if (false)
      spyReportStart(change);
    this.atom_.reportChanged();
    if (notify)
      notifyListeners(this, change);
    if (false)
      spyReportEnd();
  };
  _proto.get_ = function get_(index2) {
    if (index2 < this.values_.length) {
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index2]);
    }
    console.warn(false ? "[mobx] Out of bounds read: " + index2 : "[mobx.array] Attempt to read an array index (" + index2 + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
  };
  _proto.set_ = function set_(index2, newValue) {
    var values = this.values_;
    if (index2 < values.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index2];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index2,
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index2] = newValue;
        this.notifyArrayChildUpdate_(index2, newValue, oldValue);
      }
    } else if (index2 === values.length) {
      this.spliceWithArray_(index2, 0, [newValue]);
    } else {
      die(17, index2, values.length);
    }
  };
  return ObservableArrayAdministration3;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
  addHiddenFinalProp(adm.values_, $mobx, adm);
  var proxy = new Proxy(adm.values_, arrayTraps);
  adm.proxy_ = proxy;
  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }
  return proxy;
}
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  toJSON: function toJSON() {
    return this.slice();
  },
  splice: function splice(index2, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index2);
      case 2:
        return adm.spliceWithArray_(index2, deleteCount);
    }
    return adm.spliceWithArray_(index2, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index2, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index2, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index2) {
      return callback.call(thisArg, element, index2, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index2) {
      return callback(accumulator, currentValue, index2, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var _Symbol$iterator;
var _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /* @__PURE__ */ function() {
  function ObservableMap3(initialData, enhancer_, name_) {
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = false ? "ObservableMap@" + getNextId() : "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction(Map)) {
      die(18);
    }
    this.keysAtom_ = createAtom(false ? this.name_ + ".keys()" : "ObservableMap.keys()");
    this.data_ = new Map();
    this.hasMap_ = new Map();
    this.merge(initialData);
  }
  var _proto = ObservableMap3.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has3(key) {
    var _this = this;
    if (!globalState.trackingDerivation)
      return this.has_(key);
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, false ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set6(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change)
        return this;
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this2 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change)
        return false;
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      if (false)
        spyReportStart(_change);
      transaction(function() {
        var _this2$hasMap_$get;
        _this2.keysAtom_.reportChanged();
        (_this2$hasMap_$get = _this2.hasMap_.get(key)) == null ? void 0 : _this2$hasMap_$get.setNewValue_(false);
        var observable3 = _this2.data_.get(key);
        observable3.setNewValue_(void 0);
        _this2.data_["delete"](key);
      });
      if (notify)
        notifyListeners(this, _change);
      if (false)
        spyReportEnd();
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable3 = this.data_.get(key);
    newValue = observable3.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable3.value_,
        name: key,
        newValue
      } : null;
      if (false)
        spyReportStart(change);
      observable3.setNewValue_(newValue);
      if (notify)
        notifyListeners(this, change);
      if (false)
        spyReportEnd();
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this3$hasMap_$get;
      var observable3 = new ObservableValue(newValue, _this3.enhancer_, false ? _this3.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
      _this3.data_.set(key, observable3);
      newValue = observable3.value_;
      (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(true);
      _this3.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue
    } : null;
    if (false)
      spyReportStart(change);
    if (notify)
      notifyListeners(this, change);
    if (false)
      spyReportEnd();
  };
  _proto.get = function get5(key) {
    if (this.has(key))
      return this.dehanceValue_(this.data_.get(key).get());
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self2 = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self2 = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[_Symbol$iterator] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge(other) {
    var _this4 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject(other))
        getPlainObjectKeys(other).forEach(function(key) {
          return _this4.set(key, other[key]);
        });
      else if (Array.isArray(other))
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this4.set(key, value);
        });
      else if (isES6Map(other)) {
        if (other.constructor !== Map)
          die(19, other);
        other.forEach(function(value, key) {
          return _this4.set(key, value);
        });
      } else if (other !== null && other !== void 0)
        die(20, other);
    });
    return this;
  };
  _proto.clear = function clear3() {
    var _this5 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this5.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this5["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace3(values) {
    var _this6 = this;
    transaction(function() {
      var replacementMap = convertToMap(values);
      var orderedData = new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this6["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this6.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this6.data_.has(_key);
        _this6.set(_key, _value);
        if (_this6.data_.has(_key)) {
          var _value2 = _this6.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this6.data_.size !== orderedData.size) {
          _this6.keysAtom_.reportChanged();
        } else {
          var iter1 = _this6.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this6.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this6.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString3() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON3() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (false)
      die("`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _createClass(ObservableMap3, [{
    key: "size",
    get: function get5() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get5() {
      return "Map";
    }
  }]);
  return ObservableMap3;
}();
var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map3 = new Map();
    for (var key in dataStructure) {
      map3.set(key, dataStructure[key]);
    }
    return map3;
  } else {
    return die(21, dataStructure);
  }
}
var _Symbol$iterator$1;
var _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /* @__PURE__ */ function() {
  function ObservableSet3(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = false ? "ObservableSet@" + getNextId() : "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction(Set)) {
      die(22);
    }
    this.atom_ = createAtom(this.name_);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    if (initialData) {
      this.replace(initialData);
    }
  }
  var _proto = ObservableSet3.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear3() {
    var _this = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add(value) {
    var _this2 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change)
        return this;
    }
    if (!this.has(value)) {
      transaction(function() {
        _this2.data_.add(_this2.enhancer_(value, void 0));
        _this2.atom_.reportChanged();
      });
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notifySpy && false)
        spyReportStart(_change);
      if (notify)
        notifyListeners(this, _change);
      if (notifySpy && false)
        spyReportEnd();
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this3 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change)
        return false;
    }
    if (this.has(value)) {
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      if (notifySpy && false)
        spyReportStart(_change2);
      transaction(function() {
        _this3.atom_.reportChanged();
        _this3.data_["delete"](value);
      });
      if (notify)
        notifyListeners(this, _change2);
      if (notifySpy && false)
        spyReportEnd();
      return true;
    }
    return false;
  };
  _proto.has = function has3(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index2 = nextIndex;
        nextIndex += 1;
        return index2 < values.length ? {
          value: [keys[index2], values[index2]],
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.keys = function keys() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self2 = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self2.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.replace = function replace3(other) {
    var _this4 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this4.clear();
        other.forEach(function(value) {
          return _this4.add(value);
        });
      } else if (isES6Set(other)) {
        _this4.clear();
        other.forEach(function(value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (false)
      die("`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON3() {
    return Array.from(this);
  };
  _proto.toString = function toString3() {
    return "[object ObservableSet]";
  };
  _proto[_Symbol$iterator$1] = function() {
    return this.values();
  };
  _createClass(ObservableSet3, [{
    key: "size",
    get: function get5() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get5() {
      return "Set";
    }
  }]);
  return ObservableSet3;
}();
var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ObservableObjectAdministration3(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom(false ? this.name_ + ".keys" : "ObservableObject.keys");
    this.isPlainObject_ = isPlainObject(this.target_);
    if (false) {
      die("defaultAnnotation must be valid annotation");
    }
    if (false) {
      this.appliedAnnotations_ = {};
    }
  }
  var _proto = ObservableObjectAdministration3.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable3 = this.values_.get(key);
    if (observable3 instanceof ComputedValue) {
      observable3.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change)
        return null;
      newValue = change.newValue;
    }
    newValue = observable3.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = false;
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable3.value_,
        name: key,
        newValue
      } : null;
      if (false)
        spyReportStart(_change);
      observable3.setNewValue_(newValue);
      if (notify)
        notifyListeners(this, _change);
      if (false)
        spyReportEnd();
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer, false ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    assertAnnotable(this, annotation, key);
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) == null ? void 0 : _this$target_$storedA[key]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0)
          return;
        if (outcome === 1)
          break;
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  };
  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change)
          return null;
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change)
          return null;
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable3 = new ObservableValue(value, enhancer, false ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable3);
      this.notifyPropertyAddition_(key, observable3.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options2, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: void 0
        });
        if (!change)
          return null;
      }
      options2.name || (options2.name = false ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options2.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options2));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (!hasProp(this.target_, key)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      if (!change)
        return null;
    }
    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = false;
      var observable3 = this.values_.get(key);
      var value = void 0;
      if (!observable3 && (notify || notifySpy)) {
        var _getDescriptor3;
        value = (_getDescriptor3 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor3.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (false) {
        delete this.appliedAnnotations_[key];
      }
      if (observable3) {
        this.values_["delete"](key);
        if (observable3 instanceof ObservableValue) {
          value = observable3.value_;
        }
        propagateChanged(observable3);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (false)
          spyReportStart(_change2);
        if (notify)
          notifyListeners(this, _change2);
        if (false)
          spyReportEnd();
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    if (false)
      die("`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;
    var notify = hasListeners(this);
    var notifySpy = false;
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (false)
        spyReportStart(change);
      if (notify)
        notifyListeners(this, change);
      if (false)
        spyReportEnd();
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration3;
}();
function asObservableObject(target, options2) {
  var _options$name;
  if (false) {
    die("Options can't be provided for already observable objects.");
  }
  if (hasProp(target, $mobx)) {
    if (false) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
    }
    return target;
  }
  if (false)
    die("Cannot make the designated object observable; it is not extensible");
  var name = (_options$name = options2 == null ? void 0 : options2.name) != null ? _options$name : false ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options2));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get5() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set6(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  if (false) {
    adm.appliedAnnotations_[key] = annotation;
  }
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}
function assertAnnotable(adm, annotation, key) {
  if (false) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  if (false) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overriden by subclass.");
  }
}
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(_StubArray) {
  _inheritsLoose(LegacyObservableArray3, _StubArray);
  function LegacyObservableArray3(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name = false ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized(_this);
    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true);
      _this.spliceWithArray(0, 0, initialValues);
      allowStateChangesEnd(prev);
    }
    return _this;
  }
  var _proto = LegacyObservableArray3.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(this.slice(), arrays.map(function(a9) {
      return isObservableArray(a9) ? a9.slice() : a9;
    }));
  };
  _proto[Symbol.iterator] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  _createClass(LegacyObservableArray3, [{
    key: "length",
    get: function get5() {
      return this[$mobx].getArrayLength_();
    },
    set: function set6(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get5() {
      return "Array";
    }
  }]);
  return LegacyObservableArray3;
}(StubArray);
Object.entries(arrayExtensions).forEach(function(_ref) {
  var prop = _ref[0], fn = _ref[1];
  if (prop !== "concat")
    addHiddenProp(LegacyObservableArray.prototype, prop, fn);
});
function createArrayEntryDescriptor(index2) {
  return {
    enumerable: false,
    configurable: true,
    get: function get5() {
      return this[$mobx].get_(index2);
    },
    set: function set6(value) {
      this[$mobx].set_(index2, value);
    }
  };
}
function createArrayBufferItem(index2) {
  defineProperty(LegacyObservableArray.prototype, "" + index2, createArrayEntryDescriptor(index2));
}
function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE; index2 < max + 100; index2++) {
      createArrayBufferItem(index2);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0)
        die(23);
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing[$mobx];
    }
    if (isObservableMap(thing)) {
      if (property === void 0)
        return thing.keysAtom_;
      var observable3 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable3)
        die(25, property, getDebugName(thing));
      return observable3;
    }
    if (isObservableObject(thing)) {
      if (!property)
        return die(26);
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable)
        die(27, property, getDebugName(thing));
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing)
    die(29);
  if (property !== void 0)
    return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
    return thing;
  if (isObservableMap(thing) || isObservableSet(thing))
    return thing;
  if (thing[$mobx])
    return thing[$mobx];
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
var toString = objectPrototype.toString;
function deepEqual(a9, b7, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a9, b7, depth);
}
function eq(a9, b7, depth, aStack, bStack) {
  if (a9 === b7)
    return a9 !== 0 || 1 / a9 === 1 / b7;
  if (a9 == null || b7 == null)
    return false;
  if (a9 !== a9)
    return b7 !== b7;
  var type = typeof a9;
  if (!isFunction(type) && type !== "object" && typeof b7 != "object")
    return false;
  var className = toString.call(a9);
  if (className !== toString.call(b7))
    return false;
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a9 === "" + b7;
    case "[object Number]":
      if (+a9 !== +a9)
        return +b7 !== +b7;
      return +a9 === 0 ? 1 / +a9 === 1 / b7 : +a9 === +b7;
    case "[object Date]":
    case "[object Boolean]":
      return +a9 === +b7;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a9) === Symbol.valueOf.call(b7);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a9 = unwrap(a9);
  b7 = unwrap(b7);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a9 != "object" || typeof b7 != "object")
      return false;
    var aCtor = a9.constructor, bCtor = b7.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a9 && "constructor" in b7) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a9)
      return bStack[length] === b7;
  }
  aStack.push(a9);
  bStack.push(b7);
  if (areArrays) {
    length = a9.length;
    if (length !== b7.length)
      return false;
    while (length--) {
      if (!eq(a9[length], b7[length], depth - 1, aStack, bStack))
        return false;
    }
  } else {
    var keys = Object.keys(a9);
    var key;
    length = keys.length;
    if (Object.keys(b7).length !== length)
      return false;
    while (length--) {
      key = keys[length];
      if (!(hasProp(b7, key) && eq(a9[key], b7[key], depth - 1, aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a9) {
  if (isObservableArray(a9))
    return a9.slice();
  if (isES6Map(a9) || isObservableMap(a9))
    return Array.from(a9.entries());
  if (isES6Set(a9) || isObservableSet(a9))
    return Array.from(a9.entries());
  return a9;
}
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}
function getSelf() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(m7) {
  var g5 = getGlobal();
  if (typeof g5[m7] === "undefined") {
    die("MobX requires global '" + m7 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}

// ../../node_modules/mobx-react-lite/es/utils/assertEnvironment.js
var import_react = __toModule(require_react());
if (!import_react.useState) {
  throw new Error("mobx-react-lite requires React with Hooks support");
}
if (!makeObservable) {
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
}

// ../../node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js
var import_react_dom = __toModule(require_react_dom());

// ../../node_modules/mobx-react-lite/es/utils/observerBatching.js
function defaultNoopBatch(callback) {
  callback();
}
function observerBatching(reactionScheduler4) {
  if (!reactionScheduler4) {
    reactionScheduler4 = defaultNoopBatch;
    if (false) {
      console.warn("[MobX] Failed to get unstable_batched updates from react-dom / react-native");
    }
  }
  configure({ reactionScheduler: reactionScheduler4 });
}

// ../../node_modules/mobx-react-lite/es/useObserver.js
var import_react2 = __toModule(require_react());

// ../../node_modules/mobx-react-lite/es/utils/printDebugValue.js
function printDebugValue(v6) {
  return getDependencyTree(v6);
}

// ../../node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js
var FinalizationRegistryLocal = typeof FinalizationRegistry === "undefined" ? void 0 : FinalizationRegistry;

// ../../node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js
function createTrackingData(reaction) {
  var trackingData = {
    reaction,
    mounted: false,
    changedBeforeMount: false,
    cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS
  };
  return trackingData;
}
var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 1e4;
var CLEANUP_TIMER_LOOP_MILLIS = 1e4;

// ../../node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js
function createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistry2) {
  var cleanupTokenToReactionTrackingMap = new Map();
  var globalCleanupTokensCounter = 1;
  var registry = new FinalizationRegistry2(function cleanupFunction(token) {
    var trackedReaction = cleanupTokenToReactionTrackingMap.get(token);
    if (trackedReaction) {
      trackedReaction.reaction.dispose();
      cleanupTokenToReactionTrackingMap.delete(token);
    }
  });
  return {
    addReactionToTrack: function(reactionTrackingRef, reaction, objectRetainedByReact) {
      var token = globalCleanupTokensCounter++;
      registry.register(objectRetainedByReact, token, reactionTrackingRef);
      reactionTrackingRef.current = createTrackingData(reaction);
      reactionTrackingRef.current.finalizationRegistryCleanupToken = token;
      cleanupTokenToReactionTrackingMap.set(token, reactionTrackingRef.current);
      return reactionTrackingRef.current;
    },
    recordReactionAsCommitted: function(reactionRef) {
      registry.unregister(reactionRef);
      if (reactionRef.current && reactionRef.current.finalizationRegistryCleanupToken) {
        cleanupTokenToReactionTrackingMap.delete(reactionRef.current.finalizationRegistryCleanupToken);
      }
    },
    forceCleanupTimerToRunNowForTests: function() {
    },
    resetCleanupScheduleForTests: function() {
    }
  };
}

// ../../node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js
var __values = function(o13) {
  var s8 = typeof Symbol === "function" && Symbol.iterator, m7 = s8 && o13[s8], i8 = 0;
  if (m7)
    return m7.call(o13);
  if (o13 && typeof o13.length === "number")
    return {
      next: function() {
        if (o13 && i8 >= o13.length)
          o13 = void 0;
        return { value: o13 && o13[i8++], done: !o13 };
      }
    };
  throw new TypeError(s8 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function createTimerBasedReactionCleanupTracking() {
  var uncommittedReactionRefs = new Set();
  var reactionCleanupHandle;
  function forceCleanupTimerToRunNowForTests2() {
    if (reactionCleanupHandle) {
      clearTimeout(reactionCleanupHandle);
      cleanUncommittedReactions();
    }
  }
  function resetCleanupScheduleForTests2() {
    var e_1, _a2;
    if (uncommittedReactionRefs.size > 0) {
      try {
        for (var uncommittedReactionRefs_1 = __values(uncommittedReactionRefs), uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next(); !uncommittedReactionRefs_1_1.done; uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next()) {
          var ref = uncommittedReactionRefs_1_1.value;
          var tracking = ref.current;
          if (tracking) {
            tracking.reaction.dispose();
            ref.current = null;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (uncommittedReactionRefs_1_1 && !uncommittedReactionRefs_1_1.done && (_a2 = uncommittedReactionRefs_1.return))
            _a2.call(uncommittedReactionRefs_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      uncommittedReactionRefs.clear();
    }
    if (reactionCleanupHandle) {
      clearTimeout(reactionCleanupHandle);
      reactionCleanupHandle = void 0;
    }
  }
  function ensureCleanupTimerRunning() {
    if (reactionCleanupHandle === void 0) {
      reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);
    }
  }
  function scheduleCleanupOfReactionIfLeaked(ref) {
    uncommittedReactionRefs.add(ref);
    ensureCleanupTimerRunning();
  }
  function recordReactionAsCommitted2(reactionRef) {
    uncommittedReactionRefs.delete(reactionRef);
  }
  function cleanUncommittedReactions() {
    reactionCleanupHandle = void 0;
    var now = Date.now();
    uncommittedReactionRefs.forEach(function(ref) {
      var tracking = ref.current;
      if (tracking) {
        if (now >= tracking.cleanAt) {
          tracking.reaction.dispose();
          ref.current = null;
          uncommittedReactionRefs.delete(ref);
        }
      }
    });
    if (uncommittedReactionRefs.size > 0) {
      ensureCleanupTimerRunning();
    }
  }
  return {
    addReactionToTrack: function(reactionTrackingRef, reaction, objectRetainedByReact) {
      reactionTrackingRef.current = createTrackingData(reaction);
      scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);
      return reactionTrackingRef.current;
    },
    recordReactionAsCommitted: recordReactionAsCommitted2,
    forceCleanupTimerToRunNowForTests: forceCleanupTimerToRunNowForTests2,
    resetCleanupScheduleForTests: resetCleanupScheduleForTests2
  };
}

// ../../node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js
var _a = FinalizationRegistryLocal ? createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistryLocal) : createTimerBasedReactionCleanupTracking();
var addReactionToTrack = _a.addReactionToTrack;
var recordReactionAsCommitted = _a.recordReactionAsCommitted;
var resetCleanupScheduleForTests = _a.resetCleanupScheduleForTests;
var forceCleanupTimerToRunNowForTests = _a.forceCleanupTimerToRunNowForTests;

// ../../node_modules/mobx-react-lite/es/staticRendering.js
var globalIsUsingStaticRendering = false;
function isUsingStaticRendering() {
  return globalIsUsingStaticRendering;
}

// ../../node_modules/mobx-react-lite/es/useObserver.js
var __read = function(o13, n6) {
  var m7 = typeof Symbol === "function" && o13[Symbol.iterator];
  if (!m7)
    return o13;
  var i8 = m7.call(o13), r13, ar = [], e12;
  try {
    while ((n6 === void 0 || n6-- > 0) && !(r13 = i8.next()).done)
      ar.push(r13.value);
  } catch (error) {
    e12 = { error };
  } finally {
    try {
      if (r13 && !r13.done && (m7 = i8["return"]))
        m7.call(i8);
    } finally {
      if (e12)
        throw e12.error;
    }
  }
  return ar;
};
function observerComponentNameFor(baseComponentName) {
  return "observer" + baseComponentName;
}
var ObjectToBeRetainedByReact = function() {
  function ObjectToBeRetainedByReact2() {
  }
  return ObjectToBeRetainedByReact2;
}();
function objectToBeRetainedByReactFactory() {
  return new ObjectToBeRetainedByReact();
}
function useObserver(fn, baseComponentName) {
  if (baseComponentName === void 0) {
    baseComponentName = "observed";
  }
  if (isUsingStaticRendering()) {
    return fn();
  }
  var _a2 = __read(import_react2.default.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a2[0];
  var _b = __read(import_react2.default.useState(), 2), setState = _b[1];
  var forceUpdate = function() {
    return setState([]);
  };
  var reactionTrackingRef = import_react2.default.useRef(null);
  if (!reactionTrackingRef.current) {
    var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
      if (trackingData_1.mounted) {
        forceUpdate();
      } else {
        trackingData_1.changedBeforeMount = true;
      }
    });
    var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);
  }
  var reaction = reactionTrackingRef.current.reaction;
  import_react2.default.useDebugValue(reaction, printDebugValue);
  import_react2.default.useEffect(function() {
    recordReactionAsCommitted(reactionTrackingRef);
    if (reactionTrackingRef.current) {
      reactionTrackingRef.current.mounted = true;
      if (reactionTrackingRef.current.changedBeforeMount) {
        reactionTrackingRef.current.changedBeforeMount = false;
        forceUpdate();
      }
    } else {
      reactionTrackingRef.current = {
        reaction: new Reaction(observerComponentNameFor(baseComponentName), function() {
          forceUpdate();
        }),
        mounted: true,
        changedBeforeMount: false,
        cleanAt: Infinity
      };
      forceUpdate();
    }
    return function() {
      reactionTrackingRef.current.reaction.dispose();
      reactionTrackingRef.current = null;
    };
  }, []);
  var rendering;
  var exception;
  reaction.track(function() {
    try {
      rendering = fn();
    } catch (e12) {
      exception = e12;
    }
  });
  if (exception) {
    throw exception;
  }
  return rendering;
}

// ../../node_modules/mobx-react-lite/es/observer.js
var import_react3 = __toModule(require_react());
var __assign = function() {
  __assign = Object.assign || function(t14) {
    for (var s8, i8 = 1, n6 = arguments.length; i8 < n6; i8++) {
      s8 = arguments[i8];
      for (var p7 in s8)
        if (Object.prototype.hasOwnProperty.call(s8, p7))
          t14[p7] = s8[p7];
    }
    return t14;
  };
  return __assign.apply(this, arguments);
};
function observer(baseComponent, options2) {
  if (isUsingStaticRendering()) {
    return baseComponent;
  }
  var realOptions = __assign({ forwardRef: false }, options2);
  var baseComponentName = baseComponent.displayName || baseComponent.name;
  var wrappedComponent = function(props, ref) {
    return useObserver(function() {
      return baseComponent(props, ref);
    }, baseComponentName);
  };
  wrappedComponent.displayName = baseComponentName;
  if (baseComponent.contextTypes) {
    wrappedComponent.contextTypes = baseComponent.contextTypes;
  }
  var memoComponent;
  if (realOptions.forwardRef) {
    memoComponent = (0, import_react3.memo)((0, import_react3.forwardRef)(wrappedComponent));
  } else {
    memoComponent = (0, import_react3.memo)(wrappedComponent);
  }
  copyStaticProperties(baseComponent, memoComponent);
  memoComponent.displayName = baseComponentName;
  if (false) {
    Object.defineProperty(memoComponent, "contextTypes", {
      set: function() {
        throw new Error("[mobx-react-lite] `" + (this.displayName || "Component") + ".contextTypes` must be set before applying `observer`.");
      }
    });
  }
  return memoComponent;
}
var hoistBlackList = {
  $$typeof: true,
  render: true,
  compare: true,
  type: true
};
function copyStaticProperties(base, target) {
  Object.keys(base).forEach(function(key) {
    if (!hoistBlackList[key]) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
    }
  });
}

// ../../node_modules/mobx-react-lite/es/ObserverComponent.js
function ObserverComponent(_a2) {
  var children = _a2.children, render = _a2.render;
  var component = children || render;
  if (typeof component !== "function") {
    return null;
  }
  return useObserver(component);
}
if (false) {
  ObserverComponent.propTypes = {
    children: ObserverPropsCheck,
    render: ObserverPropsCheck
  };
}
ObserverComponent.displayName = "Observer";

// ../../node_modules/mobx-react-lite/es/useLocalObservable.js
var import_react4 = __toModule(require_react());

// ../../node_modules/mobx-react-lite/es/useLocalStore.js
var import_react6 = __toModule(require_react());

// ../../node_modules/mobx-react-lite/es/useAsObservableSource.js
var import_react5 = __toModule(require_react());

// ../../node_modules/mobx-react-lite/es/index.js
observerBatching(import_react_dom.unstable_batchedUpdates);

// ../../packages/core/dist/esm/index.js
var import_react8 = __toModule(require_react());
var import_react9 = __toModule(require_react());
var import_react10 = __toModule(require_react());
var import_react11 = __toModule(require_react());

// ../../node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js
function clamp(v6, min, max) {
  return Math.max(min, Math.min(v6, max));
}
var V = {
  toVector(v6, fallback) {
    if (v6 === void 0)
      v6 = fallback;
    return Array.isArray(v6) ? v6 : [v6, v6];
  },
  add(v1, v22) {
    return [v1[0] + v22[0], v1[1] + v22[1]];
  },
  sub(v1, v22) {
    return [v1[0] - v22[0], v1[1] - v22[1]];
  },
  addTo(v1, v22) {
    v1[0] += v22[0];
    v1[1] += v22[1];
  },
  subTo(v1, v22) {
    v1[0] -= v22[0];
    v1[1] -= v22[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity)
    return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
  if (constant === 0)
    return clamp(position, min, max);
  if (position < min)
    return -rubberband(min - position, max - min, constant) + min;
  if (position > max)
    return +rubberband(position - max, max - min, constant) + max;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// ../../node_modules/@use-gesture/core/dist/actions-9c309a79.esm.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys3(object3, enumerableOnly) {
  var keys = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i8 = 1; i8 < arguments.length; i8++) {
    var source = arguments[i8] != null ? arguments[i8] : {};
    if (i8 % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string)
    return "";
  return string[0].toUpperCase() + string.slice(1);
}
function toHandlerProp(device, action3 = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action3] || action3 : action3;
  return "on" + capitalize(device) + capitalize(actionKey) + (capture ? "Capture" : "");
}
function toDomEventType(device, action3 = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action3] || action3 : action3;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e12) => {
    var _event$currentTarget, _event$currentTarget$;
    return e12.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e12.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P22) {
  const dx = P22.clientX - P1.clientX;
  const dy = P22.clientY - P1.clientY;
  const cx = (P22.clientX + P1.clientX) / 2;
  const cy = (P22.clientY + P1.clientY) / 2;
  const distance = Math.hypot(dx, dy);
  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
  const origin = [cx, cy];
  return {
    angle,
    distance,
    origin
  };
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P22] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P22);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event)
    payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v6, ...args) {
  if (typeof v6 === "function") {
    return v6(...args);
  } else {
    return v6;
  }
}
function noop3() {
}
function chain(...fns) {
  if (fns.length === 0)
    return noop3;
  if (fns.length === 1)
    return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init)
        this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
    }
    state.startTime = state.timeStamp = event.timeStamp;
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable)
        state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[0] !== false;
    if (!state.intentional)
      return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.intent)
      this.intent(movement);
    if (state._active && !state._blocked || state.active) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config)
            state._bounds = call(config.bounds, state);
          if (this.setup)
            this.setup();
        }
        state.movement = movement;
        const previousOffset = state.offset;
        this.computeOffset();
        if (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY) {
          state.delta = V.sub(state.offset, previousOffset);
          const absoluteDelta = state.delta.map(Math.abs);
          V.addTo(state.distance, absoluteDelta);
          state.direction = state.delta.map(Math.sign);
          if (!state.first && dt > 0) {
            state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
          }
        }
      }
    }
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    this.computeMovement();
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active)
      this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents)
      return;
    const memo9 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo9 !== void 0)
      state.memo = memo9;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy]) {
  const d8 = Math.abs(dx) - Math.abs(dy);
  if (d8 > 0)
    return "x";
  if (d8 < 0)
    return "y";
  return void 0;
}
function restrictVectorToAxis(v6, axis) {
  switch (axis) {
    case "x":
      v6[1] = 0;
      break;
    case "y":
      v6[0] = 0;
      break;
  }
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  intent(v6) {
    this.state.axis = this.state.axis || selectAxis(v6);
    this.state._blocked = (this.config.lockDirection || !!this.config.axis) && !this.state.axis || !!this.config.axis && this.config.axis !== this.state.axis;
    if (this.state._blocked)
      return;
    if (this.config.axis || this.config.lockDirection) {
      restrictVectorToAxis(v6, this.state.axis);
    }
  }
};
var identity = (v6) => v6;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function")
      return value;
    if (value != null)
      return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (false) {
      const originalTransform = transform || identity;
      return (v6) => {
        const r13 = originalTransform(v6);
        if (!isFinite(r13[0]) || !isFinite(r13[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r13[0]},${[1]}]`);
        }
        return r13;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (false) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
    }
  });
}
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection)
      return axis;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top: top2 = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top2, bottom]];
  }
});
var DISPLACEMENT = 10;
var KEYS_DELTA_MAP = {
  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons))
      return;
    this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (state._pointerActive)
      return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScroll) {
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive)
      return;
    if (state.type === event.type && event.timeStamp === state.timeStamp)
      return;
    const id = pointerId(event);
    if (state._pointerId && id !== state._pointerId)
      return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScroll && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (false) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive)
      return;
    const id = pointerId(event);
    if (state._pointerId && id !== state._pointerId)
      return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= 3 && dy <= 3;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [dirx, diry] = state.direction;
      const [vx, vy] = state.velocity;
      const [mx, my] = state.movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx, sy] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        if (Math.abs(vx) > svx && Math.abs(mx) > sx)
          state.swipe[0] = dirx;
        if (Math.abs(vy) > svy && Math.abs(my) > sy)
          state.swipe[1] = diry;
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    let device = config.device;
    if (false) {
      try {
        if (device === "pointer") {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    persistEvent(event);
    this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", this.clean.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", this.clean.bind(this), {
      passive: false
    });
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScroll, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", this.startPointerDrag.bind(this), this.config.delay, event);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      state._delta = deltaFn(factor);
      this.start(event);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP))
      return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
    }
    bindFunction("key", "down", this.keyDown.bind(this));
    bindFunction("key", "up", this.keyUp.bind(this));
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e12) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  pointerLock(_v, _k, {
    pointer: {
      lock = false,
      touch = false
    } = {}
  }) {
    this.useTouch = SUPPORT.touch && touch;
    return SUPPORT.pointerLock && lock;
  },
  device(_v, _k) {
    if (this.useTouch)
      return "touch";
    if (this.pointerLock)
      return "mouse";
    if (SUPPORT.pointer)
      return "pointer";
    if (SUPPORT.touch)
      return "touch";
    return "mouse";
  },
  preventScroll(value = false, _k, {
    preventScrollAxis = "y"
  }) {
    if (preventScrollAxis)
      this.preventScrollAxis = preventScrollAxis;
    if (!SUPPORT.touchscreen)
      return false;
    if (typeof value === "number")
      return value;
    return value ? DEFAULT_PREVENT_SCROLL_DELAY : false;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1
    } = {}
  }) {
    this.pointerButtons = buttons;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? 3 : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  }
});
if (false) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
    }
  });
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 36;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  intent(v6) {
    const state = this.state;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(v6[0]) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(v6[1]);
      if (axisMovementDifference < 0)
        state.axis = "angle";
      else if (axisMovementDifference > 0)
        state.axis = "scale";
    }
    if (this.config.lockDirection) {
      if (state.axis === "scale")
        v6[1] = 0;
      else if (state.axis === "angle")
        v6[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
        return;
    }
    if (ctrlTouchIds.size < 2)
      return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
        return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2)
      return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active)
      return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active)
      return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270)
      delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active)
      return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active)
      return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    if (state._active)
      return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable)
      event.preventDefault();
    if (!this.state._active)
      return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    if (!event.ctrlKey)
      return;
    if (!this.state._active)
      this.wheelStart(event);
    else
      this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (false) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
    } else {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  useTouch(_v, _k, {
    pointer: {
      touch = false
    } = {}
  }) {
    return SUPPORT.touch && touch;
  },
  device(_v, _k, config) {
    const sharedConfig = config.shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
      return "gesture";
    if (this.useTouch)
      return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D7 = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D7.min, D7.max];
    };
    const _angleBounds = (state) => {
      const A4 = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A4.min, A4.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
      return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    if (!this.state._active)
      this.moveStart(event);
    else
      this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active)
      return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active)
      this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active)
      this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(this.state._movement, state._delta);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    const state = this.state;
    if (!state._active)
      return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = new Map();
var ConfigResolverMap = new Map();
function registerAction(action3) {
  EngineMap.set(action3.key, action3.engine);
  ConfigResolverMap.set(action3.key, action3.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// ../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react7 = __toModule(require_react());

// ../../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i8;
  for (i8 = 0; i8 < sourceKeys.length; i8++) {
    key = sourceKeys[i8];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i8;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i8 = 0; i8 < sourceSymbolKeys.length; i8++) {
      key = sourceSymbolKeys[i8];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers))
    switch (typeof resolver) {
      case "function":
        result[key] = resolver.call(result, config[key], key, config);
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver)
          result[key] = config[key];
        break;
    }
  return result;
}
function parse(config, gestureKey) {
  const _ref = config, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  const _config = {
    shared: resolveWith({
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    }, sharedConfigResolver)
  };
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (false) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl) {
    _defineProperty(this, "_listeners", []);
    this._ctrl = ctrl;
  }
  add(element, device, action3, handler, options2) {
    const type = toDomEventType(device, action3);
    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options2);
    element.addEventListener(type, handler, eventOptions);
    this._listeners.push(() => element.removeEventListener(type, handler, eventOptions));
  }
  clean() {
    this._listeners.forEach((remove3) => remove3());
    this._listeners = [];
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout)
      window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers) {
    _defineProperty(this, "gestures", new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", new Set());
    _defineProperty(this, "touchIds", new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
    } else if ("pointerId" in event) {
      if (event.type === "pointerup")
        this.pointerIds.delete(event.pointerId);
      else
        this.pointerIds.add(event.pointerId);
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target)
      this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const eventOptions = sharedConfig.eventOptions;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target)
        return;
    }
    const bindFunction = bindToProps(props, eventOptions, !!target);
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        if (this.config[gestureKey].enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      for (const eventKey in this.nativeHandlers) {
        bindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target)
      return props;
    for (const handlerProp in props) {
      let eventKey = handlerProp.substr(2).toLowerCase();
      const capture = !!~eventKey.indexOf("capture");
      const passive = !!~eventKey.indexOf("passive");
      if (capture || passive)
        eventKey = eventKey.replace(/capture|passive/g, "");
      this._targetEventStore.add(target, eventKey, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag)
    setupGesture(ctrl, "drag");
  if (internalHandlers.wheel)
    setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll)
    setupGesture(ctrl, "scroll");
  if (internalHandlers.move)
    setupGesture(ctrl, "move");
  if (internalHandlers.pinch)
    setupGesture(ctrl, "pinch");
  if (internalHandlers.hover)
    setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action3, handler, options2 = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options2.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options2.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action3, capture);
  if (withPassiveOption && passive)
    handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers2) {
  const native = {};
  const handlers = {};
  const actions = new Set();
  for (let key in _handlers2) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers2[key];
    } else {
      native[key] = _handlers2[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey))
    return;
  if (!EngineMap.has(key)) {
    if (false) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo9 = void 0;
    if (state.first && startKey in handlers)
      handlers[startKey](state);
    if (handlerKey in handlers)
      memo9 = handlers[handlerKey](state);
    if (state.last && endKey in handlers)
      handlers[endKey](state);
    return memo9;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// ../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react7.default.useMemo(() => new Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  import_react7.default.useEffect(ctrl.effect.bind(ctrl));
  import_react7.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers2, _config = {}) {
    const {
      handlers,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers2, _config);
    return useRecognizers(handlers, config, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config = {}) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config);
}

// ../../packages/vec/dist/esm/index.js
var _Vec = class {
  static clamp(n6, min, max) {
    return Math.max(min, typeof max !== "undefined" ? Math.min(n6, max) : n6);
  }
  static clampV(A4, min, max) {
    return A4.map((n6) => max ? _Vec.clamp(n6, min, max) : _Vec.clamp(n6, min));
  }
  static cross(x5, y4, z3) {
    return (y4[0] - x5[0]) * (z3[1] - x5[1]) - (z3[0] - x5[0]) * (y4[1] - x5[1]);
  }
  static snap(a9, step = 1) {
    return [Math.round(a9[0] / step) * step, Math.round(a9[1] / step) * step];
  }
};
var Vec = _Vec;
Vec.neg = (A4) => {
  return [-A4[0], -A4[1]];
};
Vec.add = (A4, B3) => {
  return [A4[0] + B3[0], A4[1] + B3[1]];
};
Vec.addScalar = (A4, n6) => {
  return [A4[0] + n6, A4[1] + n6];
};
Vec.sub = (A4, B3) => {
  return [A4[0] - B3[0], A4[1] - B3[1]];
};
Vec.subScalar = (A4, n6) => {
  return [A4[0] - n6, A4[1] - n6];
};
Vec.vec = (A4, B3) => {
  return [B3[0] - A4[0], B3[1] - A4[1]];
};
Vec.mul = (A4, n6) => {
  return [A4[0] * n6, A4[1] * n6];
};
Vec.mulV = (A4, B3) => {
  return [A4[0] * B3[0], A4[1] * B3[1]];
};
Vec.div = (A4, n6) => {
  return [A4[0] / n6, A4[1] / n6];
};
Vec.divV = (A4, B3) => {
  return [A4[0] / B3[0], A4[1] / B3[1]];
};
Vec.per = (A4) => {
  return [A4[1], -A4[0]];
};
Vec.dpr = (A4, B3) => {
  return A4[0] * B3[0] + A4[1] * B3[1];
};
Vec.cpr = (A4, B3) => {
  return A4[0] * B3[1] - B3[0] * A4[1];
};
Vec.len2 = (A4) => {
  return A4[0] * A4[0] + A4[1] * A4[1];
};
Vec.len = (A4) => {
  return Math.hypot(A4[0], A4[1]);
};
Vec.pry = (A4, B3) => {
  return _Vec.dpr(A4, B3) / _Vec.len(B3);
};
Vec.uni = (A4) => {
  return _Vec.div(A4, _Vec.len(A4));
};
Vec.normalize = (A4) => {
  return _Vec.uni(A4);
};
Vec.tangent = (A4, B3) => {
  return _Vec.uni(_Vec.sub(A4, B3));
};
Vec.dist2 = (A4, B3) => {
  return _Vec.len2(_Vec.sub(A4, B3));
};
Vec.dist = (A4, B3) => {
  return Math.hypot(A4[1] - B3[1], A4[0] - B3[0]);
};
Vec.fastDist = (A4, B3) => {
  const V5 = [B3[0] - A4[0], B3[1] - A4[1]];
  const aV = [Math.abs(V5[0]), Math.abs(V5[1])];
  let r13 = 1 / Math.max(aV[0], aV[1]);
  r13 = r13 * (1.29289 - (aV[0] + aV[1]) * r13 * 0.29289);
  return [V5[0] * r13, V5[1] * r13];
};
Vec.ang = (A4, B3) => {
  return Math.atan2(_Vec.cpr(A4, B3), _Vec.dpr(A4, B3));
};
Vec.angle = (A4, B3) => {
  return Math.atan2(B3[1] - A4[1], B3[0] - A4[0]);
};
Vec.med = (A4, B3) => {
  return _Vec.mul(_Vec.add(A4, B3), 0.5);
};
Vec.rot = (A4, r13 = 0) => {
  return [A4[0] * Math.cos(r13) - A4[1] * Math.sin(r13), A4[0] * Math.sin(r13) + A4[1] * Math.cos(r13)];
};
Vec.rotWith = (A4, C6, r13 = 0) => {
  if (r13 === 0)
    return A4;
  const s8 = Math.sin(r13);
  const c7 = Math.cos(r13);
  const px = A4[0] - C6[0];
  const py = A4[1] - C6[1];
  const nx = px * c7 - py * s8;
  const ny = px * s8 + py * c7;
  return [nx + C6[0], ny + C6[1]];
};
Vec.isEqual = (A4, B3) => {
  return A4[0] === B3[0] && A4[1] === B3[1];
};
Vec.lrp = (A4, B3, t14) => {
  return _Vec.add(A4, _Vec.mul(_Vec.sub(B3, A4), t14));
};
Vec.int = (A4, B3, from, to, s8 = 1) => {
  const t14 = (_Vec.clamp(from, to) - from) / (to - from);
  return _Vec.add(_Vec.mul(A4, 1 - t14), _Vec.mul(B3, s8));
};
Vec.ang3 = (p1, pc, p22) => {
  const v1 = _Vec.vec(pc, p1);
  const v22 = _Vec.vec(pc, p22);
  return _Vec.ang(v1, v22);
};
Vec.abs = (A4) => {
  return [Math.abs(A4[0]), Math.abs(A4[1])];
};
Vec.rescale = (a9, n6) => {
  const l9 = _Vec.len(a9);
  return [n6 * a9[0] / l9, n6 * a9[1] / l9];
};
Vec.isLeft = (p1, pc, p22) => {
  return (pc[0] - p1[0]) * (p22[1] - p1[1]) - (p22[0] - p1[0]) * (pc[1] - p1[1]);
};
Vec.clockwise = (p1, pc, p22) => {
  return _Vec.isLeft(p1, pc, p22) > 0;
};
Vec.toFixed = (a9, d8 = 2) => {
  return a9.map((v6) => +v6.toFixed(d8));
};
Vec.nearestPointOnLineThroughPoint = (A4, u4, P3) => {
  return _Vec.add(A4, _Vec.mul(u4, _Vec.pry(_Vec.sub(P3, A4), u4)));
};
Vec.distanceToLineThroughPoint = (A4, u4, P3) => {
  return _Vec.dist(P3, _Vec.nearestPointOnLineThroughPoint(A4, u4, P3));
};
Vec.nearestPointOnLineSegment = (A4, B3, P3, clamp3 = true) => {
  const u4 = _Vec.uni(_Vec.sub(B3, A4));
  const C6 = _Vec.add(A4, _Vec.mul(u4, _Vec.pry(_Vec.sub(P3, A4), u4)));
  if (clamp3) {
    if (C6[0] < Math.min(A4[0], B3[0]))
      return A4[0] < B3[0] ? A4 : B3;
    if (C6[0] > Math.max(A4[0], B3[0]))
      return A4[0] > B3[0] ? A4 : B3;
    if (C6[1] < Math.min(A4[1], B3[1]))
      return A4[1] < B3[1] ? A4 : B3;
    if (C6[1] > Math.max(A4[1], B3[1]))
      return A4[1] > B3[1] ? A4 : B3;
  }
  return C6;
};
Vec.distanceToLineSegment = (A4, B3, P3, clamp3 = true) => {
  return _Vec.dist(P3, _Vec.nearestPointOnLineSegment(A4, B3, P3, clamp3));
};
Vec.nudge = (A4, B3, d8) => {
  if (_Vec.isEqual(A4, B3))
    return A4;
  return _Vec.add(A4, _Vec.mul(_Vec.uni(_Vec.sub(B3, A4)), d8));
};
Vec.nudgeAtAngle = (A4, a9, d8) => {
  return [Math.cos(a9) * d8 + A4[0], Math.sin(a9) * d8 + A4[1]];
};
Vec.toPrecision = (a9, n6 = 4) => {
  return [+a9[0].toPrecision(n6), +a9[1].toPrecision(n6)];
};
Vec.pointsBetween = (A4, B3, steps = 6) => {
  return Array.from(Array(steps)).map((_18, i8) => {
    const t14 = i8 / (steps - 1);
    const k3 = Math.min(1, 0.5 + Math.abs(0.5 - t14));
    return [..._Vec.lrp(A4, B3, t14), k3];
  });
};
Vec.slope = (A4, B3) => {
  if (A4[0] === B3[0])
    return NaN;
  return (A4[1] - B3[1]) / (A4[0] - B3[0]);
};
var src_default = Vec;

// ../../packages/core/dist/esm/index.js
var import_react13 = __toModule(require_react());
var import_react14 = __toModule(require_react());
var import_react15 = __toModule(require_react());
var import_react16 = __toModule(require_react());
var import_react17 = __toModule(require_react());
var import_react18 = __toModule(require_react());
var import_react19 = __toModule(require_react());
var import_react20 = __toModule(require_react());
var import_react21 = __toModule(require_react());
var import_react22 = __toModule(require_react());
var import_react23 = __toModule(require_react());
var import_react24 = __toModule(require_react());
var import_react25 = __toModule(require_react());
var import_react26 = __toModule(require_react());
var import_react27 = __toModule(require_react());
var import_react28 = __toModule(require_react());
var import_react29 = __toModule(require_react());
var import_react30 = __toModule(require_react());
var import_react31 = __toModule(require_react());
var import_react32 = __toModule(require_react());
var import_react33 = __toModule(require_react());
var import_react34 = __toModule(require_react());
var import_react35 = __toModule(require_react());
var import_react36 = __toModule(require_react());
var import_react37 = __toModule(require_react());
var import_react38 = __toModule(require_react());
var import_react39 = __toModule(require_react());
var import_react40 = __toModule(require_react());
var import_react41 = __toModule(require_react());
var import_react42 = __toModule(require_react());
var import_react43 = __toModule(require_react());
var import_react44 = __toModule(require_react());
var import_react45 = __toModule(require_react());
var import_react46 = __toModule(require_react());
var import_react47 = __toModule(require_react());
var import_react48 = __toModule(require_react());
var import_react49 = __toModule(require_react());
var import_react50 = __toModule(require_react());
var import_react51 = __toModule(require_react());
var import_react52 = __toModule(require_react());
var import_react53 = __toModule(require_react());

// ../../packages/intersect/dist/esm/index.js
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a9, b7) => {
  for (var prop in b7 || (b7 = {}))
    if (__hasOwnProp2.call(b7, prop))
      __defNormalProp2(a9, prop, b7[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b7)) {
      if (__propIsEnum2.call(b7, prop))
        __defNormalProp2(a9, prop, b7[prop]);
    }
  return a9;
};
var __spreadProps2 = (a9, b7) => __defProps2(a9, __getOwnPropDescs2(b7));
function createIntersection(message, ...points) {
  const didIntersect = points.length > 0;
  return { didIntersect, message, points };
}
function getRectangleSides(point, size, rotation = 0) {
  const center = [point[0] + size[0] / 2, point[1] + size[1] / 2];
  const tl = Vec.rotWith(point, center, rotation);
  const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation);
  const br = Vec.rotWith(Vec.add(point, size), center, rotation);
  const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation);
  return [
    ["top", [tl, tr]],
    ["right", [tr, br]],
    ["bottom", [br, bl]],
    ["left", [bl, tl]]
  ];
}
function isAngleBetween(a9, b7, c7) {
  if (c7 === a9 || c7 === b7)
    return true;
  const PI24 = Math.PI * 2;
  const AB = (b7 - a9 + PI24) % PI24;
  const AC = (c7 - a9 + PI24) % PI24;
  return AB <= Math.PI !== AC > AB;
}
function intersectLineLine(AB, PQ) {
  const slopeAB = Vec.slope(AB[0], AB[1]);
  const slopePQ = Vec.slope(PQ[0], PQ[1]);
  if (slopeAB === slopePQ)
    return void 0;
  if (Number.isNaN(slopeAB) && !Number.isNaN(slopePQ)) {
    return [AB[0][0], (AB[0][0] - PQ[0][0]) * slopePQ + PQ[0][1]];
  }
  if (Number.isNaN(slopePQ) && !Number.isNaN(slopeAB)) {
    return [PQ[0][0], (PQ[0][0] - AB[0][0]) * slopeAB + AB[0][1]];
  }
  const x5 = (slopeAB * AB[0][0] - slopePQ * PQ[0][0] + PQ[0][1] - AB[0][1]) / (slopeAB - slopePQ);
  const y4 = slopePQ * (x5 - PQ[0][0]) + PQ[0][1];
  return [x5, y4];
}
function intersectRayLineSegment(origin, direction, a1, a22) {
  const [x5, y4] = origin;
  const [dx, dy] = direction;
  const [x1, y1] = a1;
  const [x22, y22] = a22;
  if (dy / dx !== (y22 - y1) / (x22 - x1)) {
    const d8 = dx * (y22 - y1) - dy * (x22 - x1);
    if (d8 !== 0) {
      const r13 = ((y4 - y1) * (x22 - x1) - (x5 - x1) * (y22 - y1)) / d8;
      const s8 = ((y4 - y1) * dx - (x5 - x1) * dy) / d8;
      if (r13 >= 0 && s8 >= 0 && s8 <= 1) {
        return createIntersection("intersection", [x5 + r13 * dx, y4 + r13 * dy]);
      }
    }
  }
  return createIntersection("no intersection");
}
function intersectRayRectangle(origin, direction, point, size, rotation = 0) {
  return intersectRectangleRay(point, size, rotation, origin, direction);
}
function intersectRayEllipse(origin, direction, center, rx, ry, rotation) {
  const a1 = origin;
  const a22 = Vec.mul(direction, 999999999);
  return intersectLineSegmentEllipse(a1, a22, center, rx, ry, rotation);
}
function intersectRayBounds(origin, direction, bounds, rotation = 0) {
  const { minX, minY, width, height } = bounds;
  return intersectRayRectangle(origin, direction, [minX, minY], [width, height], rotation);
}
function intersectLineSegmentLineSegment(a1, a22, b1, b22) {
  const AB = Vec.sub(a1, b1);
  const BV = Vec.sub(b22, b1);
  const AV = Vec.sub(a22, a1);
  const ua_t = BV[0] * AB[1] - BV[1] * AB[0];
  const ub_t = AV[0] * AB[1] - AV[1] * AB[0];
  const u_b = BV[1] * AV[0] - BV[0] * AV[1];
  if (ua_t === 0 || ub_t === 0) {
    return createIntersection("coincident");
  }
  if (u_b === 0) {
    return createIntersection("parallel");
  }
  if (u_b !== 0) {
    const ua = ua_t / u_b;
    const ub = ub_t / u_b;
    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return createIntersection("intersection", Vec.add(a1, Vec.mul(AV, ua)));
    }
  }
  return createIntersection("no intersection");
}
function intersectLineSegmentRectangle(a1, a22, point, size) {
  return intersectRectangleLineSegment(point, size, a1, a22);
}
function intersectLineSegmentArc(a1, a22, center, radius, start, end) {
  const sa = Vec.angle(center, start);
  const ea = Vec.angle(center, end);
  const ellipseTest = intersectEllipseLineSegment(center, radius, radius, 0, a1, a22);
  if (!ellipseTest.didIntersect)
    return createIntersection("no intersection");
  const points = ellipseTest.points.filter((point) => isAngleBetween(sa, ea, Vec.angle(center, point)));
  if (points.length === 0) {
    return createIntersection("no intersection");
  }
  return createIntersection("intersection", ...points);
}
function intersectLineSegmentCircle(a1, a22, c7, r13) {
  const a9 = (a22[0] - a1[0]) * (a22[0] - a1[0]) + (a22[1] - a1[1]) * (a22[1] - a1[1]);
  const b7 = 2 * ((a22[0] - a1[0]) * (a1[0] - c7[0]) + (a22[1] - a1[1]) * (a1[1] - c7[1]));
  const cc = c7[0] * c7[0] + c7[1] * c7[1] + a1[0] * a1[0] + a1[1] * a1[1] - 2 * (c7[0] * a1[0] + c7[1] * a1[1]) - r13 * r13;
  const deter = b7 * b7 - 4 * a9 * cc;
  if (deter < 0) {
    return createIntersection("outside");
  }
  if (deter === 0) {
    return createIntersection("tangent");
  }
  const e12 = Math.sqrt(deter);
  const u1 = (-b7 + e12) / (2 * a9);
  const u22 = (-b7 - e12) / (2 * a9);
  if ((u1 < 0 || u1 > 1) && (u22 < 0 || u22 > 1)) {
    if (u1 < 0 && u22 < 0 || u1 > 1 && u22 > 1) {
      return createIntersection("outside");
    } else {
      return createIntersection("inside");
    }
  }
  const results = [];
  if (0 <= u1 && u1 <= 1)
    results.push(Vec.lrp(a1, a22, u1));
  if (0 <= u22 && u22 <= 1)
    results.push(Vec.lrp(a1, a22, u22));
  return createIntersection("intersection", ...results);
}
function intersectLineSegmentEllipse(a1, a22, center, rx, ry, rotation = 0) {
  if (rx === 0 || ry === 0 || Vec.isEqual(a1, a22)) {
    return createIntersection("no intersection");
  }
  rx = rx < 0 ? rx : -rx;
  ry = ry < 0 ? ry : -ry;
  a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center);
  a22 = Vec.sub(Vec.rotWith(a22, center, -rotation), center);
  const diff = Vec.sub(a22, a1);
  const A4 = diff[0] * diff[0] / rx / rx + diff[1] * diff[1] / ry / ry;
  const B3 = 2 * a1[0] * diff[0] / rx / rx + 2 * a1[1] * diff[1] / ry / ry;
  const C6 = a1[0] * a1[0] / rx / rx + a1[1] * a1[1] / ry / ry - 1;
  const tValues = [];
  const discriminant = B3 * B3 - 4 * A4 * C6;
  if (discriminant === 0) {
    tValues.push(-B3 / 2 / A4);
  } else if (discriminant > 0) {
    const root = Math.sqrt(discriminant);
    tValues.push((-B3 + root) / 2 / A4);
    tValues.push((-B3 - root) / 2 / A4);
  }
  const points = tValues.filter((t14) => t14 >= 0 && t14 <= 1).map((t14) => Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a22, a1), t14)))).map((p7) => Vec.rotWith(p7, center, rotation));
  return createIntersection("intersection", ...points);
}
function intersectLineSegmentBounds(a1, a22, bounds) {
  return intersectBoundsLineSegment(bounds, a1, a22);
}
function intersectLineSegmentPolyline(a1, a22, points) {
  const pts = [];
  for (let i8 = 1; i8 < points.length; i8++) {
    const int = intersectLineSegmentLineSegment(a1, a22, points[i8 - 1], points[i8]);
    if (int) {
      pts.push(...int.points);
    }
  }
  if (pts.length === 0) {
    return createIntersection("no intersection");
  }
  return createIntersection("intersection", ...points);
}
function intersectLineSegmentPolygon(a1, a22, points) {
  const pts = [];
  for (let i8 = 1; i8 < points.length + 1; i8++) {
    const int = intersectLineSegmentLineSegment(a1, a22, points[i8 - 1], points[i8 % points.length]);
    if (int) {
      pts.push(...int.points);
    }
  }
  if (pts.length === 0) {
    return createIntersection("no intersection");
  }
  return createIntersection("intersection", ...points);
}
function intersectRectangleRay(point, size, rotation, origin, direction) {
  const sideIntersections = getRectangleSides(point, size, rotation).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectRayLineSegment(origin, direction, a1, a22);
    if (intersection) {
      acc.push(createIntersection(message, ...intersection.points));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleLineSegment(point, size, a1, a22) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [b1, b22]]) => {
    const intersection = intersectLineSegmentLineSegment(a1, a22, b1, b22);
    if (intersection) {
      acc.push(createIntersection(message, ...intersection.points));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleRectangle(point1, size1, point2, size2) {
  const sideIntersections = getRectangleSides(point1, size1).reduce((acc, [message, [a1, a22]]) => {
    const intersections = intersectRectangleLineSegment(point2, size2, a1, a22);
    acc.push(...intersections.map((int) => createIntersection(`${message} ${int.message}`, ...int.points)));
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleArc(point, size, center, radius, start, end) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectArcLineSegment(center, radius, start, end, a1, a22);
    if (intersection) {
      acc.push(__spreadProps2(__spreadValues2({}, intersection), { message }));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleCircle(point, size, c7, r13) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectLineSegmentCircle(a1, a22, c7, r13);
    if (intersection) {
      acc.push(__spreadProps2(__spreadValues2({}, intersection), { message }));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectangleEllipse(point, size, c7, rx, ry, rotation = 0) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectLineSegmentEllipse(a1, a22, c7, rx, ry, rotation);
    if (intersection) {
      acc.push(__spreadProps2(__spreadValues2({}, intersection), { message }));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectanglePolyline(point, size, points) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectLineSegmentPolyline(a1, a22, points);
    if (intersection.didIntersect) {
      acc.push(createIntersection(message, ...intersection.points));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectRectanglePolygon(point, size, points) {
  const sideIntersections = getRectangleSides(point, size).reduce((acc, [message, [a1, a22]]) => {
    const intersection = intersectLineSegmentPolygon(a1, a22, points);
    if (intersection.didIntersect) {
      acc.push(createIntersection(message, ...intersection.points));
    }
    return acc;
  }, []);
  return sideIntersections.filter((int) => int.didIntersect);
}
function intersectArcLineSegment(center, radius, start, end, a1, a22) {
  return intersectLineSegmentArc(a1, a22, center, radius, start, end);
}
function intersectArcRectangle(center, radius, start, end, point, size) {
  return intersectRectangleArc(point, size, center, radius, start, end);
}
function intersectArcBounds(center, radius, start, end, bounds) {
  const { minX, minY, width, height } = bounds;
  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height]);
}
function intersectCircleLineSegment(c7, r13, a1, a22) {
  return intersectLineSegmentCircle(a1, a22, c7, r13);
}
function intersectCircleCircle(c1, r1, c22, r22) {
  let dx = c22[0] - c1[0], dy = c22[1] - c1[1];
  const d8 = Math.sqrt(dx * dx + dy * dy), x5 = (d8 * d8 - r22 * r22 + r1 * r1) / (2 * d8), y4 = Math.sqrt(r1 * r1 - x5 * x5);
  dx /= d8;
  dy /= d8;
  return createIntersection("intersection", [c1[0] + dx * x5 - dy * y4, c1[1] + dy * x5 + dx * y4], [c1[0] + dx * x5 + dy * y4, c1[1] + dy * x5 - dx * y4]);
}
function intersectEllipseLineSegment(center, rx, ry, rotation = 0, a1, a22) {
  if (rx === ry) {
    return intersectLineSegmentCircle(a1, a22, center, rx);
  }
  return intersectLineSegmentEllipse(a1, a22, center, rx, ry, rotation);
}
function intersectEllipseRectangle(center, rx, ry, rotation = 0, point, size) {
  if (rx === ry) {
    return intersectRectangleCircle(point, size, center, rx);
  }
  return intersectRectangleEllipse(point, size, center, rx, ry, rotation);
}
function intersectEllipseBounds(c7, rx, ry, rotation, bounds) {
  const { minX, minY, width, height } = bounds;
  return intersectEllipseRectangle(c7, rx, ry, rotation, [minX, minY], [width, height]);
}
function intersectBoundsLineSegment(bounds, a1, a22) {
  const { minX, minY, width, height } = bounds;
  return intersectLineSegmentRectangle(a1, a22, [minX, minY], [width, height]);
}
function intersectBoundsBounds(bounds1, bounds2) {
  return intersectRectangleRectangle([bounds1.minX, bounds1.minY], [bounds1.width, bounds1.height], [bounds2.minX, bounds2.minY], [bounds2.width, bounds2.height]);
}
function intersectBoundsPolyline(bounds, points) {
  return intersectPolylineBounds(points, bounds);
}
function intersectBoundsPolygon(bounds, points) {
  return intersectPolygonBounds(points, bounds);
}
function intersectPolylineBounds(points, bounds) {
  return intersectRectanglePolyline([bounds.minX, bounds.minY], [bounds.width, bounds.height], points);
}
function intersectPolygonBounds(points, bounds) {
  return intersectRectanglePolygon([bounds.minX, bounds.minY], [bounds.width, bounds.height], points);
}

// ../../packages/core/dist/esm/index.js
var __defProp3 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a9, b7) => {
  for (var prop in b7 || (b7 = {}))
    if (__hasOwnProp3.call(b7, prop))
      __defNormalProp3(a9, prop, b7[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b7)) {
      if (__propIsEnum3.call(b7, prop))
        __defNormalProp3(a9, prop, b7[prop]);
    }
  return a9;
};
var __spreadProps3 = (a9, b7) => __defProps3(a9, __getOwnPropDescs3(b7));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var TLContext = (0, import_react10.createContext)({});
function useTLContext() {
  const context2 = (0, import_react10.useContext)(TLContext);
  return context2;
}
function useZoomEvents(zoom, ref) {
  const rOriginPoint = (0, import_react11.useRef)(void 0);
  const rPinchPoint = (0, import_react11.useRef)(void 0);
  const rDelta = (0, import_react11.useRef)([0, 0]);
  const { inputs: inputs2, bounds, callbacks } = useTLContext();
  (0, import_react11.useEffect)(() => {
    const preventGesture = (event) => {
      event.preventDefault();
    };
    document.addEventListener("gesturestart", preventGesture);
    document.addEventListener("gesturechange", preventGesture);
    return () => {
      document.removeEventListener("gesturestart", preventGesture);
      document.removeEventListener("gesturechange", preventGesture);
    };
  }, []);
  useGesture({
    onWheel: ({ delta, event: e12 }) => {
      var _a2, _b, _c, _d;
      e12.preventDefault();
      if (e12.altKey && e12.buttons === 0) {
        const point = (_b = (_a2 = inputs2.pointer) == null ? void 0 : _a2.point) != null ? _b : [bounds.width / 2, bounds.height / 2];
        const info2 = inputs2.pinch(point, point);
        (_c = callbacks.onZoom) == null ? void 0 : _c.call(callbacks, __spreadProps3(__spreadValues3({}, info2), { delta: [...point, -e12.deltaY] }), e12);
        return;
      }
      if (inputs2.isPinching)
        return;
      if (Vec.isEqual(delta, [0, 0]))
        return;
      const info = inputs2.pan(delta, e12);
      (_d = callbacks.onPan) == null ? void 0 : _d.call(callbacks, info, e12);
    },
    onPinchStart: ({ origin, event }) => {
      var _a2;
      const elm = ref.current;
      if (!elm || !(event.target === elm || elm.contains(event.target)))
        return;
      const info = inputs2.pinch(origin, origin);
      inputs2.isPinching = true;
      (_a2 = callbacks.onPinchStart) == null ? void 0 : _a2.call(callbacks, info, event);
      rPinchPoint.current = info.point;
      rOriginPoint.current = info.origin;
      rDelta.current = [0, 0];
    },
    onPinchEnd: ({ origin, event }) => {
      var _a2;
      const elm = ref.current;
      if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
        return;
      const info = inputs2.pinch(origin, origin);
      inputs2.isPinching = false;
      (_a2 = callbacks.onPinchEnd) == null ? void 0 : _a2.call(callbacks, info, event);
      rPinchPoint.current = void 0;
      rOriginPoint.current = void 0;
      rDelta.current = [0, 0];
    },
    onPinch: ({ origin, offset, event }) => {
      var _a2;
      const elm = ref.current;
      if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
        return;
      if (!rOriginPoint.current)
        return;
      const info = inputs2.pinch(origin, rOriginPoint.current);
      const trueDelta = Vec.sub(info.delta, rDelta.current);
      rDelta.current = info.delta;
      (_a2 = callbacks.onPinch) == null ? void 0 : _a2.call(callbacks, __spreadProps3(__spreadValues3({}, info), {
        point: info.point,
        origin: rOriginPoint.current,
        delta: [...trueDelta, offset[0]]
      }), event);
      rPinchPoint.current = origin;
    }
  }, {
    target: ref,
    eventOptions: { passive: false },
    pinch: {
      from: zoom,
      scaleBounds: () => ({ from: inputs2.zoom, max: 5, min: 0.1 })
    }
  });
}
var TLBoundsEdge;
(function(TLBoundsEdge2) {
  TLBoundsEdge2["Top"] = "top_edge";
  TLBoundsEdge2["Right"] = "right_edge";
  TLBoundsEdge2["Bottom"] = "bottom_edge";
  TLBoundsEdge2["Left"] = "left_edge";
})(TLBoundsEdge || (TLBoundsEdge = {}));
var TLBoundsCorner;
(function(TLBoundsCorner2) {
  TLBoundsCorner2["TopLeft"] = "top_left_corner";
  TLBoundsCorner2["TopRight"] = "top_right_corner";
  TLBoundsCorner2["BottomRight"] = "bottom_right_corner";
  TLBoundsCorner2["BottomLeft"] = "bottom_left_corner";
})(TLBoundsCorner || (TLBoundsCorner = {}));
var SnapPoints;
(function(SnapPoints2) {
  SnapPoints2["minX"] = "minX";
  SnapPoints2["midX"] = "midX";
  SnapPoints2["maxX"] = "maxX";
  SnapPoints2["minY"] = "minY";
  SnapPoints2["midY"] = "midY";
  SnapPoints2["maxY"] = "maxY";
})(SnapPoints || (SnapPoints = {}));
if (!String.prototype.replaceAll) {
  String.prototype.replaceAll = function(str, newStr) {
    if (Object.prototype.toString.call(str).toLowerCase() === "[object regexp]") {
      return this.replace(str, newStr);
    }
    return this.replace(new RegExp(str, "g"), newStr);
  };
}
var TAU = Math.PI * 2;
var _Utils = class {
  static lerp(y1, y22, mu) {
    mu = _Utils.clamp(mu, 0, 1);
    return y1 * (1 - mu) + y22 * mu;
  }
  static lerpColor(color1, color2, factor = 0.5) {
    function h2r(hex) {
      const result2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return [parseInt(result2[1], 16), parseInt(result2[2], 16), parseInt(result2[3], 16)];
    }
    function r2h(rgb) {
      return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
    }
    const c1 = h2r(color1) || [0, 0, 0];
    const c22 = h2r(color2) || [0, 0, 0];
    const result = c1.slice();
    for (let i8 = 0; i8 < 3; i8++) {
      result[i8] = Math.round(result[i8] + factor * (c22[i8] - c1[i8]));
    }
    return r2h(result);
  }
  static modulate(value, rangeA, rangeB, clamp3 = false) {
    const [fromLow, fromHigh] = rangeA;
    const [v0, v1] = rangeB;
    const result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);
    return clamp3 ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;
  }
  static clamp(n6, min, max) {
    return Math.max(min, typeof max !== "undefined" ? Math.min(n6, max) : n6);
  }
  static deepClone(obj) {
    if (obj === null)
      return obj;
    if (Array.isArray(obj)) {
      return [...obj];
    }
    if (typeof obj === "object") {
      const clone = __spreadValues3({}, obj);
      Object.keys(clone).forEach((key) => clone[key] = typeof obj[key] === "object" ? _Utils.deepClone(obj[key]) : obj[key]);
      return clone;
    }
    return obj;
  }
  static rng(seed = "") {
    let x5 = 0;
    let y4 = 0;
    let z3 = 0;
    let w6 = 0;
    function next() {
      const t14 = x5 ^ x5 << 11;
      x5 = y4;
      y4 = z3;
      z3 = w6;
      w6 ^= (w6 >>> 19 ^ t14 ^ t14 >>> 8) >>> 0;
      return w6 / 4294967296;
    }
    for (let k3 = 0; k3 < seed.length + 64; k3++) {
      x5 ^= seed.charCodeAt(k3) | 0;
      next();
    }
    return next;
  }
  static pointsToLineSegments(points, closed = false) {
    const segments = [];
    for (let i8 = 1; i8 < points.length; i8++)
      segments.push([points[i8 - 1], points[i8]]);
    if (closed)
      segments.push([points[points.length - 1], points[0]]);
    return segments;
  }
  static getRectangleSides(point, size, rotation = 0) {
    const center = [point[0] + size[0] / 2, point[1] + size[1] / 2];
    const tl = Vec.rotWith(point, center, rotation);
    const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation);
    const br = Vec.rotWith(Vec.add(point, size), center, rotation);
    const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation);
    return [
      ["top", [tl, tr]],
      ["right", [tr, br]],
      ["bottom", [br, bl]],
      ["left", [bl, tl]]
    ];
  }
  static circleFromThreePoints(A4, B3, C6) {
    const [x1, y1] = A4;
    const [x22, y22] = B3;
    const [x32, y32] = C6;
    const a9 = x1 * (y22 - y32) - y1 * (x22 - x32) + x22 * y32 - x32 * y22;
    const b7 = (x1 * x1 + y1 * y1) * (y32 - y22) + (x22 * x22 + y22 * y22) * (y1 - y32) + (x32 * x32 + y32 * y32) * (y22 - y1);
    const c7 = (x1 * x1 + y1 * y1) * (x22 - x32) + (x22 * x22 + y22 * y22) * (x32 - x1) + (x32 * x32 + y32 * y32) * (x1 - x22);
    const x5 = -b7 / (2 * a9);
    const y4 = -c7 / (2 * a9);
    return [x5, y4, Math.hypot(x5 - x1, y4 - y1)];
  }
  static perimeterOfEllipse(rx, ry) {
    const h3 = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
    const p7 = Math.PI * (rx + ry) * (1 + 3 * h3 / (10 + Math.sqrt(4 - 3 * h3)));
    return p7;
  }
  static shortAngleDist(a0, a1) {
    const max = Math.PI * 2;
    const da = (a1 - a0) % max;
    return 2 * da % max - da;
  }
  static longAngleDist(a0, a1) {
    return Math.PI * 2 - _Utils.shortAngleDist(a0, a1);
  }
  static lerpAngles(a0, a1, t14) {
    return a0 + _Utils.shortAngleDist(a0, a1) * t14;
  }
  static angleDelta(a0, a1) {
    return _Utils.shortAngleDist(a0, a1);
  }
  static getSweep(C6, A4, B3) {
    return _Utils.angleDelta(Vec.angle(C6, A4), Vec.angle(C6, B3));
  }
  static clampRadians(r13) {
    return (Math.PI * 2 + r13) % (Math.PI * 2);
  }
  static snapAngleToSegments(r13, segments) {
    const seg = Math.PI * 2 / segments;
    return Math.floor((_Utils.clampRadians(r13) + seg / 2) / seg) * seg;
  }
  static isAngleBetween(a9, b7, c7) {
    if (c7 === a9 || c7 === b7)
      return true;
    const AB = (b7 - a9 + TAU) % TAU;
    const AC = (c7 - a9 + TAU) % TAU;
    return AB <= Math.PI !== AC > AB;
  }
  static degreesToRadians(d8) {
    return d8 * Math.PI / 180;
  }
  static radiansToDegrees(r13) {
    return r13 * 180 / Math.PI;
  }
  static getArcLength(C6, r13, A4, B3) {
    const sweep = _Utils.getSweep(C6, A4, B3);
    return r13 * (2 * Math.PI) * (sweep / (2 * Math.PI));
  }
  static getSweepFlag(A4, B3, C6) {
    const angleAC = Vec.angle(A4, C6);
    const angleAB = Vec.angle(A4, B3);
    const angleCAB = (angleAB - angleAC + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return angleCAB > 0 ? 0 : 1;
  }
  static getLargeArcFlag(A4, C6, P3) {
    const anglePA = Vec.angle(P3, A4);
    const anglePC = Vec.angle(P3, C6);
    const angleAPC = (anglePC - anglePA + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return Math.abs(angleAPC) > Math.PI / 2 ? 0 : 1;
  }
  static getArcDashOffset(C6, r13, A4, B3, step) {
    const del0 = _Utils.getSweepFlag(C6, A4, B3);
    const len0 = _Utils.getArcLength(C6, r13, A4, B3);
    const off0 = del0 < 0 ? len0 : 2 * Math.PI * C6[2] - len0;
    return -off0 / 2 + step;
  }
  static getEllipseDashOffset(A4, step) {
    const c7 = 2 * Math.PI * A4[2];
    return -c7 / 2 + -step;
  }
  static pointInCircle(A4, C6, r13) {
    return Vec.dist(A4, C6) <= r13;
  }
  static pointInEllipse(A4, C6, rx, ry, rotation = 0) {
    rotation = rotation || 0;
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    const delta = Vec.sub(A4, C6);
    const tdx = cos * delta[0] + sin * delta[1];
    const tdy = sin * delta[0] - cos * delta[1];
    return tdx * tdx / (rx * rx) + tdy * tdy / (ry * ry) <= 1;
  }
  static pointInRect(point, size) {
    return !(point[0] < size[0] || point[0] > point[0] + size[0] || point[1] < size[1] || point[1] > point[1] + size[1]);
  }
  static pointInPolygon(p7, points) {
    let wn = 0;
    points.forEach((a9, i8) => {
      const b7 = points[(i8 + 1) % points.length];
      if (a9[1] <= p7[1]) {
        if (b7[1] > p7[1] && Vec.cross(a9, b7, p7) > 0) {
          wn += 1;
        }
      } else if (b7[1] <= p7[1] && Vec.cross(a9, b7, p7) < 0) {
        wn -= 1;
      }
    });
    return wn !== 0;
  }
  static pointInBounds(A4, b7) {
    return !(A4[0] < b7.minX || A4[0] > b7.maxX || A4[1] < b7.minY || A4[1] > b7.maxY);
  }
  static pointInPolyline(A4, points, distance = 3) {
    for (let i8 = 1; i8 < points.length; i8++) {
      if (Vec.distanceToLineSegment(points[i8 - 1], points[i8], A4) < distance) {
        return true;
      }
    }
    return false;
  }
  static getBoundsSides(bounds) {
    return this.getRectangleSides([bounds.minX, bounds.minY], [bounds.width, bounds.height]);
  }
  static expandBounds(bounds, delta) {
    return {
      minX: bounds.minX - delta,
      minY: bounds.minY - delta,
      maxX: bounds.maxX + delta,
      maxY: bounds.maxY + delta,
      width: bounds.width + delta * 2,
      height: bounds.height + delta * 2
    };
  }
  static boundsCollide(a9, b7) {
    return !(a9.maxX < b7.minX || a9.minX > b7.maxX || a9.maxY < b7.minY || a9.minY > b7.maxY);
  }
  static boundsContain(a9, b7) {
    return a9.minX < b7.minX && a9.minY < b7.minY && a9.maxY > b7.maxY && a9.maxX > b7.maxX;
  }
  static boundsContained(a9, b7) {
    return _Utils.boundsContain(b7, a9);
  }
  static boundsAreEqual(a9, b7) {
    return !(b7.maxX !== a9.maxX || b7.minX !== a9.minX || b7.maxY !== a9.maxY || b7.minY !== a9.minY);
  }
  static getBoundsFromPoints(points, rotation = 0) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    if (points.length < 2) {
      minX = 0;
      minY = 0;
      maxX = 1;
      maxY = 1;
    } else {
      for (const [x5, y4] of points) {
        minX = Math.min(x5, minX);
        minY = Math.min(y4, minY);
        maxX = Math.max(x5, maxX);
        maxY = Math.max(y4, maxY);
      }
    }
    if (rotation !== 0) {
      return _Utils.getBoundsFromPoints(points.map((pt) => Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], rotation)));
    }
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: Math.max(1, maxX - minX),
      height: Math.max(1, maxY - minY)
    };
  }
  static centerBounds(bounds, point) {
    const boundsCenter = this.getBoundsCenter(bounds);
    const dx = point[0] - boundsCenter[0];
    const dy = point[1] - boundsCenter[1];
    return this.translateBounds(bounds, [dx, dy]);
  }
  static snapBoundsToGrid(bounds, gridSize) {
    const minX = Math.round(bounds.minX / gridSize) * gridSize;
    const minY = Math.round(bounds.minY / gridSize) * gridSize;
    const maxX = Math.round(bounds.maxX / gridSize) * gridSize;
    const maxY = Math.round(bounds.maxY / gridSize) * gridSize;
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: Math.max(1, maxX - minX),
      height: Math.max(1, maxY - minY)
    };
  }
  static translateBounds(bounds, delta) {
    return {
      minX: bounds.minX + delta[0],
      minY: bounds.minY + delta[1],
      maxX: bounds.maxX + delta[0],
      maxY: bounds.maxY + delta[1],
      width: bounds.width,
      height: bounds.height
    };
  }
  static rotateBounds(bounds, center, rotation) {
    const [minX, minY] = Vec.rotWith([bounds.minX, bounds.minY], center, rotation);
    const [maxX, maxY] = Vec.rotWith([bounds.maxX, bounds.maxY], center, rotation);
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: bounds.width,
      height: bounds.height
    };
  }
  static getRotatedEllipseBounds(x5, y4, rx, ry, rotation = 0) {
    const c7 = Math.cos(rotation);
    const s8 = Math.sin(rotation);
    const w6 = Math.hypot(rx * c7, ry * s8);
    const h3 = Math.hypot(rx * s8, ry * c7);
    return {
      minX: x5 + rx - w6,
      minY: y4 + ry - h3,
      maxX: x5 + rx + w6,
      maxY: y4 + ry + h3,
      width: w6 * 2,
      height: h3 * 2
    };
  }
  static getExpandedBounds(a9, b7) {
    const minX = Math.min(a9.minX, b7.minX);
    const minY = Math.min(a9.minY, b7.minY);
    const maxX = Math.max(a9.maxX, b7.maxX);
    const maxY = Math.max(a9.maxY, b7.maxY);
    const width = Math.abs(maxX - minX);
    const height = Math.abs(maxY - minY);
    return { minX, minY, maxX, maxY, width, height };
  }
  static getCommonBounds(bounds) {
    if (bounds.length < 2)
      return bounds[0];
    let result = bounds[0];
    for (let i8 = 1; i8 < bounds.length; i8++) {
      result = _Utils.getExpandedBounds(result, bounds[i8]);
    }
    return result;
  }
  static getRotatedCorners(b7, rotation = 0) {
    const center = [b7.minX + b7.width / 2, b7.minY + b7.height / 2];
    return [
      [b7.minX, b7.minY],
      [b7.maxX, b7.minY],
      [b7.maxX, b7.maxY],
      [b7.minX, b7.maxY]
    ].map((point) => Vec.rotWith(point, center, rotation));
  }
  static getTransformedBoundingBox(bounds, handle, delta, rotation = 0, isAspectRatioLocked = false) {
    const [ax0, ay0] = [bounds.minX, bounds.minY];
    const [ax1, ay1] = [bounds.maxX, bounds.maxY];
    let [bx0, by0] = [bounds.minX, bounds.minY];
    let [bx1, by1] = [bounds.maxX, bounds.maxY];
    if (handle === "center") {
      return {
        minX: bx0 + delta[0],
        minY: by0 + delta[1],
        maxX: bx1 + delta[0],
        maxY: by1 + delta[1],
        width: bx1 - bx0,
        height: by1 - by0,
        scaleX: 1,
        scaleY: 1
      };
    }
    const [dx, dy] = Vec.rot(delta, -rotation);
    switch (handle) {
      case TLBoundsEdge.Top:
      case TLBoundsCorner.TopLeft:
      case TLBoundsCorner.TopRight: {
        by0 += dy;
        break;
      }
      case TLBoundsEdge.Bottom:
      case TLBoundsCorner.BottomLeft:
      case TLBoundsCorner.BottomRight: {
        by1 += dy;
        break;
      }
    }
    switch (handle) {
      case TLBoundsEdge.Left:
      case TLBoundsCorner.TopLeft:
      case TLBoundsCorner.BottomLeft: {
        bx0 += dx;
        break;
      }
      case TLBoundsEdge.Right:
      case TLBoundsCorner.TopRight:
      case TLBoundsCorner.BottomRight: {
        bx1 += dx;
        break;
      }
    }
    const aw = ax1 - ax0;
    const ah = ay1 - ay0;
    const scaleX = (bx1 - bx0) / aw;
    const scaleY = (by1 - by0) / ah;
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    const bw = Math.abs(bx1 - bx0);
    const bh = Math.abs(by1 - by0);
    if (isAspectRatioLocked) {
      const ar = aw / ah;
      const isTall = ar < bw / bh;
      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / ar);
      const th = bh * (scaleX < 0 ? 1 : -1) * ar;
      switch (handle) {
        case TLBoundsCorner.TopLeft: {
          if (isTall)
            by0 = by1 + tw;
          else
            bx0 = bx1 + th;
          break;
        }
        case TLBoundsCorner.TopRight: {
          if (isTall)
            by0 = by1 + tw;
          else
            bx1 = bx0 - th;
          break;
        }
        case TLBoundsCorner.BottomRight: {
          if (isTall)
            by1 = by0 - tw;
          else
            bx1 = bx0 - th;
          break;
        }
        case TLBoundsCorner.BottomLeft: {
          if (isTall)
            by1 = by0 - tw;
          else
            bx0 = bx1 + th;
          break;
        }
        case TLBoundsEdge.Bottom:
        case TLBoundsEdge.Top: {
          const m7 = (bx0 + bx1) / 2;
          const w6 = bh * ar;
          bx0 = m7 - w6 / 2;
          bx1 = m7 + w6 / 2;
          break;
        }
        case TLBoundsEdge.Left:
        case TLBoundsEdge.Right: {
          const m7 = (by0 + by1) / 2;
          const h3 = bw / ar;
          by0 = m7 - h3 / 2;
          by1 = m7 + h3 / 2;
          break;
        }
      }
    }
    if (rotation % (Math.PI * 2) !== 0) {
      let cv = [0, 0];
      const c0 = Vec.med([ax0, ay0], [ax1, ay1]);
      const c1 = Vec.med([bx0, by0], [bx1, by1]);
      switch (handle) {
        case TLBoundsCorner.TopLeft: {
          cv = Vec.sub(Vec.rotWith([bx1, by1], c1, rotation), Vec.rotWith([ax1, ay1], c0, rotation));
          break;
        }
        case TLBoundsCorner.TopRight: {
          cv = Vec.sub(Vec.rotWith([bx0, by1], c1, rotation), Vec.rotWith([ax0, ay1], c0, rotation));
          break;
        }
        case TLBoundsCorner.BottomRight: {
          cv = Vec.sub(Vec.rotWith([bx0, by0], c1, rotation), Vec.rotWith([ax0, ay0], c0, rotation));
          break;
        }
        case TLBoundsCorner.BottomLeft: {
          cv = Vec.sub(Vec.rotWith([bx1, by0], c1, rotation), Vec.rotWith([ax1, ay0], c0, rotation));
          break;
        }
        case TLBoundsEdge.Top: {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by1], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay1], [ax1, ay1]), c0, rotation));
          break;
        }
        case TLBoundsEdge.Left: {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx1, by0], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax1, ay0], [ax1, ay1]), c0, rotation));
          break;
        }
        case TLBoundsEdge.Bottom: {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx1, by0]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax1, ay0]), c0, rotation));
          break;
        }
        case TLBoundsEdge.Right: {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx0, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax0, ay1]), c0, rotation));
          break;
        }
      }
      ;
      [bx0, by0] = Vec.sub([bx0, by0], cv);
      [bx1, by1] = Vec.sub([bx1, by1], cv);
    }
    if (bx1 < bx0) {
      ;
      [bx1, bx0] = [bx0, bx1];
    }
    if (by1 < by0) {
      ;
      [by1, by0] = [by0, by1];
    }
    return {
      minX: bx0,
      minY: by0,
      maxX: bx1,
      maxY: by1,
      width: bx1 - bx0,
      height: by1 - by0,
      scaleX: (bx1 - bx0) / (ax1 - ax0 || 1) * (flipX ? -1 : 1),
      scaleY: (by1 - by0) / (ay1 - ay0 || 1) * (flipY ? -1 : 1)
    };
  }
  static getTransformAnchor(type, isFlippedX, isFlippedY) {
    let anchor = type;
    switch (type) {
      case TLBoundsCorner.TopLeft: {
        if (isFlippedX && isFlippedY) {
          anchor = TLBoundsCorner.BottomRight;
        } else if (isFlippedX) {
          anchor = TLBoundsCorner.TopRight;
        } else if (isFlippedY) {
          anchor = TLBoundsCorner.BottomLeft;
        } else {
          anchor = TLBoundsCorner.BottomRight;
        }
        break;
      }
      case TLBoundsCorner.TopRight: {
        if (isFlippedX && isFlippedY) {
          anchor = TLBoundsCorner.BottomLeft;
        } else if (isFlippedX) {
          anchor = TLBoundsCorner.TopLeft;
        } else if (isFlippedY) {
          anchor = TLBoundsCorner.BottomRight;
        } else {
          anchor = TLBoundsCorner.BottomLeft;
        }
        break;
      }
      case TLBoundsCorner.BottomRight: {
        if (isFlippedX && isFlippedY) {
          anchor = TLBoundsCorner.TopLeft;
        } else if (isFlippedX) {
          anchor = TLBoundsCorner.BottomLeft;
        } else if (isFlippedY) {
          anchor = TLBoundsCorner.TopRight;
        } else {
          anchor = TLBoundsCorner.TopLeft;
        }
        break;
      }
      case TLBoundsCorner.BottomLeft: {
        if (isFlippedX && isFlippedY) {
          anchor = TLBoundsCorner.TopRight;
        } else if (isFlippedX) {
          anchor = TLBoundsCorner.BottomRight;
        } else if (isFlippedY) {
          anchor = TLBoundsCorner.TopLeft;
        } else {
          anchor = TLBoundsCorner.TopRight;
        }
        break;
      }
    }
    return anchor;
  }
  static getRelativeTransformedBoundingBox(bounds, initialBounds, initialShapeBounds, isFlippedX, isFlippedY) {
    const nx = (isFlippedX ? initialBounds.maxX - initialShapeBounds.maxX : initialShapeBounds.minX - initialBounds.minX) / initialBounds.width;
    const ny = (isFlippedY ? initialBounds.maxY - initialShapeBounds.maxY : initialShapeBounds.minY - initialBounds.minY) / initialBounds.height;
    const nw = initialShapeBounds.width / initialBounds.width;
    const nh = initialShapeBounds.height / initialBounds.height;
    const minX = bounds.minX + bounds.width * nx;
    const minY = bounds.minY + bounds.height * ny;
    const width = bounds.width * nw;
    const height = bounds.height * nh;
    return {
      minX,
      minY,
      maxX: minX + width,
      maxY: minY + height,
      width,
      height
    };
  }
  static getRotatedSize(size, rotation) {
    const center = Vec.div(size, 2);
    const points = [[0, 0], [size[0], 0], size, [0, size[1]]].map((point) => Vec.rotWith(point, center, rotation));
    const bounds = _Utils.getBoundsFromPoints(points);
    return [bounds.width, bounds.height];
  }
  static getBoundsCenter(bounds) {
    return [bounds.minX + bounds.width / 2, bounds.minY + bounds.height / 2];
  }
  static getBoundsWithCenter(bounds) {
    const center = _Utils.getBoundsCenter(bounds);
    return __spreadProps3(__spreadValues3({}, bounds), {
      midX: center[0],
      midY: center[1]
    });
  }
  static getCommonTopLeft(points) {
    const min = [Infinity, Infinity];
    points.forEach((point) => {
      min[0] = Math.min(min[0], point[0]);
      min[1] = Math.min(min[1], point[1]);
    });
    return min;
  }
  static getFromCache(cache, item, getNext) {
    let value = cache.get(item);
    if (value === void 0) {
      cache.set(item, getNext());
      value = cache.get(item);
      if (value === void 0) {
        throw Error("Cache did not include item!");
      }
    }
    return value;
  }
  static uniqueId(a9 = "") {
    return a9 ? ((Number(a9) ^ Math.random() * 16) >> Number(a9) / 4).toString(16) : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, _Utils.uniqueId);
  }
  static rotateArray(arr, offset) {
    return arr.map((_142, i8) => arr[(i8 + offset) % arr.length]);
  }
  static debounce(fn, ms = 0) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(args), ms);
    };
  }
  static getSvgPathFromStroke(points, closed = true) {
    if (!points.length) {
      return "";
    }
    const max = points.length - 1;
    return points.reduce((acc, point, i8, arr) => {
      if (i8 === max) {
        if (closed) {
          acc.push("Z");
        }
      } else {
        acc.push(point, Vec.med(point, arr[i8 + 1]));
      }
      return acc;
    }, ["M", points[0], "Q"]).join(" ").replaceAll(this.TRIM_NUMBERS, "$1");
  }
  static getPerfectDashProps(length, strokeWidth, style, snap = 1, outset = true) {
    let dashLength;
    let strokeDashoffset;
    let ratio;
    if (style.toLowerCase() === "dashed") {
      dashLength = strokeWidth * 2;
      ratio = 1;
      strokeDashoffset = outset ? (dashLength / 2).toString() : "0";
    } else if (style.toLowerCase() === "dotted") {
      dashLength = strokeWidth / 100;
      ratio = 100;
      strokeDashoffset = "0";
    } else {
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
    }
    let dashes = Math.floor(length / dashLength / (2 * ratio));
    dashes -= dashes % snap;
    dashes = Math.max(dashes, 4);
    const gapLength = Math.max(dashLength, (length - dashes * dashLength) / (outset ? dashes : dashes - 1));
    return {
      strokeDasharray: [dashLength, gapLength].join(" "),
      strokeDashoffset
    };
  }
  static isMobileSize() {
    if (typeof window === "undefined")
      return false;
    return window.innerWidth < 768;
  }
  static isMobileSafari() {
    if (typeof window === "undefined")
      return false;
    const ua = window.navigator.userAgent;
    const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
    const webkit = !!ua.match(/WebKit/i);
    return iOS && webkit && !ua.match(/CriOS/i);
  }
  static throttle(func, limit) {
    let inThrottle;
    let lastResult;
    return function(...args) {
      if (!inThrottle) {
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
        lastResult = func(...args);
      }
      return lastResult;
    };
  }
  static isDarwin() {
    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  }
  static metaKey(e12) {
    return _Utils.isDarwin() ? e12.metaKey : e12.ctrlKey;
  }
};
var Utils = _Utils;
__publicField(Utils, "getSnapPoints", (bounds, others, snapDistance) => {
  const A4 = __spreadValues3({}, bounds);
  const offset = [0, 0];
  const snapLines = [];
  const snaps = {
    [SnapPoints.minX]: { id: SnapPoints.minX, isSnapped: false },
    [SnapPoints.midX]: { id: SnapPoints.midX, isSnapped: false },
    [SnapPoints.maxX]: { id: SnapPoints.maxX, isSnapped: false },
    [SnapPoints.minY]: { id: SnapPoints.minY, isSnapped: false },
    [SnapPoints.midY]: { id: SnapPoints.midY, isSnapped: false },
    [SnapPoints.maxY]: { id: SnapPoints.maxY, isSnapped: false }
  };
  const xs = [SnapPoints.midX, SnapPoints.minX, SnapPoints.maxX];
  const ys = [SnapPoints.midY, SnapPoints.minY, SnapPoints.maxY];
  const snapResults = others.map((B3) => {
    const rx = xs.flatMap((f11, i8) => xs.map((t14, k3) => {
      const gap = A4[f11] - B3[t14];
      const distance = Math.abs(gap);
      return {
        f: f11,
        t: t14,
        gap,
        distance,
        isCareful: i8 === 0 || i8 + k3 === 3
      };
    }));
    const ry = ys.flatMap((f11, i8) => ys.map((t14, k3) => {
      const gap = A4[f11] - B3[t14];
      const distance = Math.abs(gap);
      return {
        f: f11,
        t: t14,
        gap,
        distance,
        isCareful: i8 === 0 || i8 + k3 === 3
      };
    }));
    return [B3, rx, ry];
  });
  let gapX = Infinity;
  let gapY = Infinity;
  let minX = Infinity;
  let minY = Infinity;
  snapResults.forEach(([_142, rx, ry]) => {
    rx.forEach((r13) => {
      if (r13.distance < snapDistance && r13.distance < minX) {
        minX = r13.distance;
        gapX = r13.gap;
      }
    });
    ry.forEach((r13) => {
      if (r13.distance < snapDistance && r13.distance < minY) {
        minY = r13.distance;
        gapY = r13.gap;
      }
    });
  });
  snapResults.forEach(([B3, rx, ry]) => {
    if (gapX !== Infinity) {
      rx.forEach((r13) => {
        if (Math.abs(r13.gap - gapX) < 2) {
          snaps[r13.f] = __spreadProps3(__spreadValues3({}, snaps[r13.f]), {
            isSnapped: true,
            to: B3[r13.t],
            B: B3,
            distance: r13.distance
          });
        }
      });
    }
    if (gapY !== Infinity) {
      ry.forEach((r13) => {
        if (Math.abs(r13.gap - gapY) < 2) {
          snaps[r13.f] = __spreadProps3(__spreadValues3({}, snaps[r13.f]), {
            isSnapped: true,
            to: B3[r13.t],
            B: B3,
            distance: r13.distance
          });
        }
      });
    }
  });
  offset[0] = gapX === Infinity ? 0 : gapX;
  offset[1] = gapY === Infinity ? 0 : gapY;
  A4.minX -= offset[0];
  A4.midX -= offset[0];
  A4.maxX -= offset[0];
  A4.minY -= offset[1];
  A4.midY -= offset[1];
  A4.maxY -= offset[1];
  xs.forEach((from) => {
    const snap = snaps[from];
    if (!snap.isSnapped)
      return;
    const { id, B: B3 } = snap;
    const x5 = A4[id];
    snapLines.push(id === SnapPoints.minX ? [
      [x5, A4.midY],
      [x5, B3.minY],
      [x5, B3.maxY]
    ] : [
      [x5, A4.minY],
      [x5, A4.maxY],
      [x5, B3.minY],
      [x5, B3.maxY]
    ]);
  });
  ys.forEach((from) => {
    const snap = snaps[from];
    if (!snap.isSnapped)
      return;
    const { id, B: B3 } = snap;
    const y4 = A4[id];
    snapLines.push(id === SnapPoints.midY ? [
      [A4.midX, y4],
      [B3.minX, y4],
      [B3.maxX, y4]
    ] : [
      [A4.minX, y4],
      [A4.maxX, y4],
      [B3.minX, y4],
      [B3.maxX, y4]
    ]);
  });
  return { offset, snapLines };
});
__publicField(Utils, "deepMerge", (target, patch) => {
  const result = __spreadValues3({}, target);
  const entries = Object.entries(patch);
  for (const [key, value] of entries)
    result[key] = value === Object(value) && !Array.isArray(value) ? _Utils.deepMerge(result[key], value) : value;
  return result;
});
__publicField(Utils, "TRIM_NUMBERS", /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g);
var utils_default = Utils;
function useSafariFocusOutFix() {
  const { callbacks } = useTLContext();
  (0, import_react13.useEffect)(() => {
    function handleFocusOut() {
      var _a2;
      (_a2 = callbacks.onShapeBlur) == null ? void 0 : _a2.call(callbacks);
    }
    if (utils_default.isMobileSafari()) {
      document.addEventListener("focusout", handleFocusOut);
      return () => document.removeEventListener("focusout", handleFocusOut);
    }
    return () => null;
  }, [callbacks]);
}
function useCanvasEvents() {
  const { callbacks, inputs: inputs2 } = useTLContext();
  const onPointerDown = (0, import_react14.useCallback)((e12) => {
    var _a2, _b;
    if (e12.button !== 0 && e12.button !== 1)
      return;
    if (!inputs2.pointerIsValid(e12))
      return;
    e12.currentTarget.setPointerCapture(e12.pointerId);
    const info = inputs2.pointerDown(e12, "canvas");
    if (e12.button === 0 || e12.button === 1) {
      (_a2 = callbacks.onPointCanvas) == null ? void 0 : _a2.call(callbacks, info, e12);
      (_b = callbacks.onPointerDown) == null ? void 0 : _b.call(callbacks, info, e12);
    }
  }, [callbacks, inputs2]);
  const onPointerMove = (0, import_react14.useCallback)((e12) => {
    var _a2, _b;
    if (!inputs2.pointerIsValid(e12))
      return;
    const info = inputs2.pointerMove(e12, "canvas");
    if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
      (_a2 = callbacks.onDragCanvas) == null ? void 0 : _a2.call(callbacks, info, e12);
    }
    (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e12);
  }, [callbacks, inputs2]);
  const onPointerUp = (0, import_react14.useCallback)((e12) => {
    var _a2, _b, _c, _d;
    if (e12.button !== 0 && e12.button !== 1)
      return;
    inputs2.activePointer = void 0;
    if (!inputs2.pointerIsValid(e12))
      return;
    const isDoubleClick = inputs2.isDoubleClick();
    const info = inputs2.pointerUp(e12, "canvas");
    if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
      (_a2 = e12.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e12.pointerId);
    }
    if (isDoubleClick && !(info.altKey || info.metaKey)) {
      (_b = callbacks.onDoubleClickCanvas) == null ? void 0 : _b.call(callbacks, info, e12);
    }
    (_c = callbacks.onReleaseCanvas) == null ? void 0 : _c.call(callbacks, info, e12);
    (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e12);
  }, [callbacks, inputs2]);
  return {
    onPointerDown,
    onPointerMove,
    onPointerUp
  };
}
function useShapeEvents(id) {
  const { rPageState, rSelectionBounds, callbacks, inputs: inputs2 } = (0, import_react15.useContext)(TLContext);
  return (0, import_react15.useMemo)(() => ({
    onPointerDown: (e12) => {
      var _a2, _b, _c, _d, _e, _f;
      if (!inputs2.pointerIsValid(e12))
        return;
      if (e12.button === 2) {
        (_a2 = callbacks.onRightPointShape) == null ? void 0 : _a2.call(callbacks, inputs2.pointerDown(e12, id), e12);
        return;
      }
      if (e12.button !== 0)
        return;
      const info = inputs2.pointerDown(e12, id);
      e12.stopPropagation();
      (_b = e12.currentTarget) == null ? void 0 : _b.setPointerCapture(e12.pointerId);
      if (rSelectionBounds.current && Utils.pointInBounds(info.point, rSelectionBounds.current) && !rPageState.current.selectedIds.includes(id)) {
        (_c = callbacks.onPointBounds) == null ? void 0 : _c.call(callbacks, inputs2.pointerDown(e12, "bounds"), e12);
        (_d = callbacks.onPointShape) == null ? void 0 : _d.call(callbacks, info, e12);
        return;
      }
      (_e = callbacks.onPointShape) == null ? void 0 : _e.call(callbacks, info, e12);
      (_f = callbacks.onPointerDown) == null ? void 0 : _f.call(callbacks, info, e12);
    },
    onPointerUp: (e12) => {
      var _a2, _b, _c, _d;
      if (e12.button !== 0)
        return;
      inputs2.activePointer = void 0;
      if (!inputs2.pointerIsValid(e12))
        return;
      e12.stopPropagation();
      const isDoubleClick = inputs2.isDoubleClick();
      const info = inputs2.pointerUp(e12, id);
      if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
        (_a2 = e12.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e12.pointerId);
      }
      if (isDoubleClick && !(info.altKey || info.metaKey)) {
        (_b = callbacks.onDoubleClickShape) == null ? void 0 : _b.call(callbacks, info, e12);
      }
      (_c = callbacks.onReleaseShape) == null ? void 0 : _c.call(callbacks, info, e12);
      (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e12);
    },
    onPointerEnter: (e12) => {
      var _a2, _b;
      if (!inputs2.pointerIsValid(e12))
        return;
      e12.stopPropagation();
      if (inputs2.pointer && e12.pointerId !== inputs2.pointer.pointerId)
        return;
      const info = inputs2.pointerMove(e12, id);
      if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
        (_a2 = callbacks.onDragShape) == null ? void 0 : _a2.call(callbacks, info, e12);
      }
      (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e12);
    },
    onPointerMove: (e12) => {
      var _a2;
      if (!inputs2.pointerIsValid(e12))
        return;
      const info = inputs2.pointerEnter(e12, id);
      (_a2 = callbacks.onHoverShape) == null ? void 0 : _a2.call(callbacks, info, e12);
    },
    onPointerLeave: (e12) => {
      var _a2;
      if (!inputs2.pointerIsValid(e12))
        return;
      const info = inputs2.pointerEnter(e12, id);
      (_a2 = callbacks.onUnhoverShape) == null ? void 0 : _a2.call(callbacks, info, e12);
    }
  }), [inputs2, callbacks, id]);
}
function addToShapeTree(shape, branch, shapes, pageState, isChildOfGhost = false, isChildOfSelected = false, meta) {
  const node = {
    shape,
    meta,
    isChildOfSelected,
    isGhost: shape.isGhost || isChildOfGhost,
    isEditing: pageState.editingId === shape.id,
    isBinding: pageState.bindingTargetId === shape.id,
    isSelected: pageState.selectedIds.includes(shape.id),
    isHovered: pageState.hoveredId === shape.id || shape.children !== void 0 && (pageState.hoveredId && shape.children.includes(pageState.hoveredId) || shape.children.some((childId) => pageState.selectedIds.includes(childId)))
  };
  branch.push(node);
  if (shape.children) {
    node.children = [];
    shape.children.map((id) => shapes[id]).sort((a9, b7) => a9.childIndex - b7.childIndex).forEach((childShape) => addToShapeTree(childShape, node.children, shapes, pageState, node.isGhost, node.isSelected || node.isChildOfSelected, meta));
  }
}
function shapeIsInViewport(bounds, viewport) {
  return Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds);
}
function useShapeTree(page, pageState, meta) {
  const { callbacks, shapeUtils: shapeUtils2, bounds } = useTLContext();
  const rTimeout = (0, import_react16.useRef)();
  const rPreviousCount = (0, import_react16.useRef)(0);
  const rShapesIdsToRender = (0, import_react16.useRef)(new Set());
  const rShapesToRender = (0, import_react16.useRef)(new Set());
  const { selectedIds, camera } = pageState;
  const [minX, minY] = Vec.sub(Vec.div([0, 0], camera.zoom), camera.point);
  const [maxX, maxY] = Vec.sub(Vec.div([bounds.width, bounds.height], camera.zoom), camera.point);
  const viewport = {
    minX,
    minY,
    maxX,
    maxY,
    height: maxX - minX,
    width: maxY - minY
  };
  const shapesToRender = rShapesToRender.current;
  const shapesIdsToRender = rShapesIdsToRender.current;
  shapesToRender.clear();
  shapesIdsToRender.clear();
  Object.values(page.shapes).filter((shape) => shapeUtils2[shape.type].isStateful || selectedIds.includes(shape.id) || shapeIsInViewport(shapeUtils2[shape.type].getBounds(shape), viewport)).forEach((shape) => {
    if (shape.parentId === page.id) {
      shapesIdsToRender.add(shape.id);
      shapesToRender.add(shape);
      return;
    }
    shapesIdsToRender.add(shape.parentId);
    shapesToRender.add(page.shapes[shape.parentId]);
  });
  if (shapesToRender.size !== rPreviousCount.current) {
    if (rTimeout.current) {
      clearTimeout(rTimeout.current);
    }
    rTimeout.current = requestAnimationFrame(() => {
      var _a2;
      (_a2 = callbacks.onRenderCountChange) == null ? void 0 : _a2.call(callbacks, Array.from(shapesIdsToRender.values()));
    });
    rPreviousCount.current = shapesToRender.size;
  }
  const bindingTargetId = pageState.bindingId ? page.bindings[pageState.bindingId].toId : void 0;
  const tree = [];
  shapesToRender.forEach((shape) => addToShapeTree(shape, tree, page.shapes, __spreadProps3(__spreadValues3({}, pageState), { bindingTargetId }), shape.isGhost, false, meta));
  tree.sort((a9, b7) => a9.shape.childIndex - b7.shape.childIndex);
  return tree;
}
var styles = new Map();
function makeCssTheme(prefix2, theme) {
  return Object.keys(theme).reduce((acc, key) => {
    const value = theme[key];
    if (value) {
      return acc + `${`--${prefix2}-${key}`}: ${value};
`;
    }
    return acc;
  }, "");
}
function useTheme(prefix2, theme, selector = ":root") {
  (0, import_react17.useLayoutEffect)(() => {
    const style = document.createElement("style");
    const cssTheme = makeCssTheme(prefix2, theme);
    style.setAttribute("id", `${prefix2}-theme`);
    style.setAttribute("data-selector", selector);
    style.innerHTML = `
        ${selector} {
          ${cssTheme}
        }
      `;
    document.head.appendChild(style);
    return () => {
      if (style && document.head.contains(style)) {
        document.head.removeChild(style);
      }
    };
  }, [prefix2, theme, selector]);
}
function useStyle(uid, rules) {
  (0, import_react17.useLayoutEffect)(() => {
    if (styles.get(uid)) {
      return () => void 0;
    }
    const style = document.createElement("style");
    style.innerHTML = rules;
    style.setAttribute("id", uid);
    document.head.appendChild(style);
    styles.set(uid, style);
    return () => {
      if (style && document.head.contains(style)) {
        document.head.removeChild(style);
        styles.delete(uid);
      }
    };
  }, [uid, rules]);
}
var css = (strings, ...args) => strings.reduce((acc, string, index2) => acc + string + (index2 < args.length ? args[index2] : ""), "");
var defaultTheme = {
  accent: "rgb(255, 0, 0)",
  brushFill: "rgba(0,0,0,.05)",
  brushStroke: "rgba(0,0,0,.25)",
  selectStroke: "rgb(66, 133, 244)",
  selectFill: "rgba(65, 132, 244, 0.05)",
  binding: "rgba(65, 132, 244, 0.12)",
  background: "rgb(248, 249, 250)",
  foreground: "rgb(51, 51, 51)",
  grid: "rgba(144, 144, 144, 1)"
};
var tlcss = css`
  @font-face {
    font-family: 'Recursive';
    font-style: normal;
    font-weight: 500;
    font-display: swap;
    src: url(https://fonts.gstatic.com/s/recursive/v23/8vI-7wMr0mhh-RQChyHEH06TlXhq_gukbYrFMk1QuAIcyEwG_X-dpEfaE5YaERmK-CImKsvxvU-MXGX2fSqasNfUlTGZnI14ZeY.woff2)
      format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC,
      U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  }

  @font-face {
    font-family: 'Recursive';
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url(https://fonts.gstatic.com/s/recursive/v23/8vI-7wMr0mhh-RQChyHEH06TlXhq_gukbYrFMk1QuAIcyEwG_X-dpEfaE5YaERmK-CImKsvxvU-MXGX2fSqasNfUlTGZnI14ZeY.woff2)
      format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC,
      U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  }

  @font-face {
    font-family: 'Recursive Mono';
    font-style: normal;
    font-weight: 420;
    font-display: swap;
    src: url(https://fonts.gstatic.com/s/recursive/v23/8vI-7wMr0mhh-RQChyHEH06TlXhq_gukbYrFMk1QuAIcyEwG_X-dpEfaE5YaERmK-CImqvTxvU-MXGX2fSqasNfUlTGZnI14ZeY.woff2)
      format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC,
      U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
  }

  .tl-container {
    --tl-zoom: 1;
    --tl-scale: calc(1 / var(--tl-zoom));
    --tl-padding: calc(64px * max(1, var(--tl-scale)));
    position: relative;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    box-sizing: border-box;
    padding: 0px;
    margin: 0px;
    z-index: 100;
    overflow: hidden;
    touch-action: none;
    overscroll-behavior: none;
    background-color: var(--tl-background);
  }

  .tl-container * {
    box-sizing: border-box;
  }

  .tl-overlay {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
  }

  .tl-grid {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
    user-select: none;
  }

  .tl-snap-line {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }

  .tl-snap-point {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }

  .tl-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: all;
    overflow: clip;
  }

  .tl-layer {
    position: absolute;
    top: 0px;
    left: 0px;
    height: 0px;
    width: 0px;
    contain: layout style size;
  }

  .tl-absolute {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    contain: layout style size;
  }

  .tl-positioned {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    contain: layout style size;
  }

  .tl-positioned-svg {
    width: 100%;
    height: 100%;
    overflow: hidden;
    contain: layout style size;
  }

  .tl-positioned-div {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding: var(--tl-padding);
    overflow: hidden;
    contain: layout style size;
  }

  .tl-stroke-hitarea {
    cursor: pointer;
    fill: none;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: stroke;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .tl-fill-hitarea {
    cursor: pointer;
    fill: transparent;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: all;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .tl-counter-scaled {
    transform: scale(var(--tl-scale));
  }

  .tl-dashed {
    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));
  }

  .tl-transparent {
    fill: transparent;
    stroke: transparent;
  }

  .tl-cursor-ns {
    cursor: ns-resize;
  }

  .tl-cursor-ew {
    cursor: ew-resize;
  }

  .tl-cursor-nesw {
    cursor: nesw-resize;
  }

  .tl-cursor-nwse {
    cursor: nwse-resize;
  }

  .tl-corner-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
  }

  .tl-rotate-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
    cursor: grab;
  }

  .tl-binding {
    fill: var(--tl-selectFill);
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }

  .tl-user {
    left: -4px;
    top: -4px;
    height: 8px;
    width: 8px;
    border-radius: 100%;
    pointer-events: none;
  }

  .tl-indicator {
    fill: transparent;
    stroke-width: calc(1.5px * var(--tl-scale));
    pointer-events: none;
  }

  .tl-user-indicator-bounds {
    border-style: solid;
    border-width: calc(1px * var(--tl-scale));
  }

  .tl-selected {
    stroke: var(--tl-selectStroke);
  }

  .tl-hovered {
    stroke: var(--tl-selectStroke);
  }

  .tl-clone-target {
    pointer-events: all;
  }

  .tl-clone-target:hover .tl-clone-button {
    opacity: 1;
  }

  .tl-clone-button-target {
    cursor: pointer;
    pointer-events: all;
  }

  .tl-clone-button-target:hover .tl-clone-button {
    fill: var(--tl-selectStroke);
  }

  .tl-clone-button {
    opacity: 0;
    r: calc(8px * var(--tl-scale));
    stroke-width: calc(1.5px * var(--tl-scale));
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
  }

  .tl-bounds {
    pointer-events: none;
    contain: layout style size;
  }

  .tl-bounds-bg {
    stroke: none;
    fill: var(--tl-selectFill);
    pointer-events: all;
    contain: layout style size;
  }

  .tl-bounds-center {
    fill: transparent;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1.5px * var(--tl-scale));
  }

  .tl-brush {
    fill: var(--tl-brushFill);
    stroke: var(--tl-brushStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
    contain: layout style size;
  }

  .tl-dot {
    fill: var(--tl-background);
    stroke: var(--tl-foreground);
    stroke-width: 2px;
  }

  .tl-handle {
    pointer-events: all;
    cursor: grab;
  }

  .tl-handle:hover .tl-handle-bg {
    fill: var(--tl-selectFill);
  }

  .tl-handle:hover .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }

  .tl-handle:active .tl-handle-bg {
    cursor: grabbing;
    fill: var(--tl-selectFill);
  }

  .tl-handle:active .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }

  .tl-handle {
    fill: var(--tl-background);
    stroke: var(--tl-selectStroke);
    stroke-width: 1.5px;
  }

  .tl-handle-bg {
    fill: transparent;
    stroke: none;
    pointer-events: all;
    r: calc(16px / max(1, var(--tl-zoom)));
  }

  .tl-binding-indicator {
    fill: transparent;
    stroke: var(--tl-binding);
  }

  .tl-centered-g {
    transform: translate(var(--tl-padding), var(--tl-padding));
  }

  .tl-current-parent > *[data-shy='true'] {
    opacity: 1;
  }

  .tl-binding {
    fill: none;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(2px * var(--tl-scale));
  }

  .tl-grid-dot {
    fill: var(--tl-grid);
  }
`;
function useTLTheme(theme, selector) {
  const tltheme = (0, import_react17.useMemo)(() => __spreadValues3(__spreadValues3({}, defaultTheme), theme), [theme]);
  useTheme("tl", tltheme, selector);
  useStyle("tl-canvas", tlcss);
}
function useBoundsHandleEvents(id) {
  const { callbacks, inputs: inputs2 } = useTLContext();
  const onPointerDown = (0, import_react18.useCallback)((e12) => {
    var _a2, _b, _c;
    if (e12.button !== 0)
      return;
    if (!inputs2.pointerIsValid(e12))
      return;
    e12.stopPropagation();
    (_a2 = e12.currentTarget) == null ? void 0 : _a2.setPointerCapture(e12.pointerId);
    const info = inputs2.pointerDown(e12, id);
    (_b = callbacks.onPointBoundsHandle) == null ? void 0 : _b.call(callbacks, info, e12);
    (_c = callbacks.onPointerDown) == null ? void 0 : _c.call(callbacks, info, e12);
  }, [inputs2, callbacks, id]);
  const onPointerUp = (0, import_react18.useCallback)((e12) => {
    var _a2, _b, _c, _d;
    if (e12.button !== 0)
      return;
    if (!inputs2.pointerIsValid(e12))
      return;
    e12.stopPropagation();
    const isDoubleClick = inputs2.isDoubleClick();
    const info = inputs2.pointerUp(e12, id);
    if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
      (_a2 = e12.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e12.pointerId);
    }
    if (isDoubleClick && !(info.altKey || info.metaKey)) {
      (_b = callbacks.onDoubleClickBoundsHandle) == null ? void 0 : _b.call(callbacks, info, e12);
    }
    (_c = callbacks.onReleaseBoundsHandle) == null ? void 0 : _c.call(callbacks, info, e12);
    (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e12);
  }, [inputs2, callbacks, id]);
  const onPointerMove = (0, import_react18.useCallback)((e12) => {
    var _a2, _b;
    if (!inputs2.pointerIsValid(e12))
      return;
    e12.stopPropagation();
    if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
      (_a2 = callbacks.onDragBoundsHandle) == null ? void 0 : _a2.call(callbacks, inputs2.pointerMove(e12, id), e12);
    }
    const info = inputs2.pointerMove(e12, id);
    (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e12);
  }, [inputs2, callbacks, id]);
  const onPointerEnter = (0, import_react18.useCallback)((e12) => {
    var _a2;
    if (!inputs2.pointerIsValid(e12))
      return;
    (_a2 = callbacks.onHoverBoundsHandle) == null ? void 0 : _a2.call(callbacks, inputs2.pointerEnter(e12, id), e12);
  }, [inputs2, callbacks, id]);
  const onPointerLeave = (0, import_react18.useCallback)((e12) => {
    var _a2;
    if (!inputs2.pointerIsValid(e12))
      return;
    (_a2 = callbacks.onUnhoverBoundsHandle) == null ? void 0 : _a2.call(callbacks, inputs2.pointerEnter(e12, id), e12);
  }, [inputs2, callbacks, id]);
  return {
    onPointerDown,
    onPointerUp,
    onPointerEnter,
    onPointerMove,
    onPointerLeave
  };
}
var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _2(index2, length) {
    return "[mobx.array] Index out of bounds, " + index2 + " is larger than " + length;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _3(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _4(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _5(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _6(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _7(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _8(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _9(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _10(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _11(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _12(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _13(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
};
var errors = true ? niceErrors : {};
function die2(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (true) {
    var e12 = typeof error === "string" ? error : errors[error];
    if (typeof e12 === "function")
      e12 = e12.apply(null, args);
    throw new Error("[MobX] " + e12);
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal2 = {};
function getGlobal2() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal2;
}
var assign2 = Object.assign;
var getDescriptor2 = Object.getOwnPropertyDescriptor;
var defineProperty3 = Object.defineProperty;
var objectPrototype2 = Object.prototype;
var EMPTY_ARRAY2 = [];
Object.freeze(EMPTY_ARRAY2);
var EMPTY_OBJECT2 = {};
Object.freeze(EMPTY_OBJECT2);
var hasProxy2 = typeof Proxy !== "undefined";
var plainObjectString2 = /* @__PURE__ */ Object.toString();
function assertProxies2() {
  if (!hasProxy2) {
    die2(true ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
  }
}
function warnAboutProxyRequirement(msg) {
  if (globalState2.verifyProxies) {
    die2("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}
function getNextId() {
  return ++globalState2.mobxGuid;
}
function once2(func) {
  var invoked = false;
  return function() {
    if (invoked)
      return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop4 = function noop22() {
};
function isFunction2(fn) {
  return typeof fn === "function";
}
function isStringish2(value) {
  var t14 = typeof value;
  switch (t14) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject2(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject2(value) {
  var _proto$constructor;
  if (!isObject2(value))
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null)
    return true;
  return ((_proto$constructor = proto.constructor) == null ? void 0 : _proto$constructor.toString()) === plainObjectString2;
}
function isGenerator2(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor)
    return false;
  if (constructor.name === "GeneratorFunction" || constructor.displayName === "GeneratorFunction")
    return true;
  return false;
}
function addHiddenProp2(object22, propName, value) {
  defineProperty3(object22, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp2(object22, propName, value) {
  defineProperty3(object22, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate2(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x5) {
    return isObject2(x5) && x5[propName] === true;
  };
}
function isES6Map2(thing) {
  return thing instanceof Map;
}
function isES6Set2(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols2 = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys2(object22) {
  var keys = Object.keys(object22);
  if (!hasGetOwnPropertySymbols2)
    return keys;
  var symbols = Object.getOwnPropertySymbols(object22);
  if (!symbols.length)
    return keys;
  return [].concat(keys, symbols.filter(function(s8) {
    return objectPrototype2.propertyIsEnumerable.call(object22, s8);
  }));
}
var ownKeys4 = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols2 ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : Object.getOwnPropertyNames;
function stringifyKey(key) {
  if (typeof key === "string")
    return key;
  if (typeof key === "symbol")
    return key.toString();
  return new String(key).toString();
}
function toPrimitive2(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp2(target, prop) {
  return objectPrototype2.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors3 = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors22(target) {
  var res = {};
  ownKeys4(target).forEach(function(key) {
    res[key] = getDescriptor2(target, key);
  });
  return res;
};
function _defineProperties2(target, props) {
  for (var i8 = 0; i8 < props.length; i8++) {
    var descriptor = props[i8];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i8 = 1; i8 < arguments.length; i8++) {
      var source = arguments[i8];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray2(o13, minLen) {
  if (!o13)
    return;
  if (typeof o13 === "string")
    return _arrayLikeToArray2(o13, minLen);
  var n6 = Object.prototype.toString.call(o13).slice(8, -1);
  if (n6 === "Object" && o13.constructor)
    n6 = o13.constructor.name;
  if (n6 === "Map" || n6 === "Set")
    return Array.from(o13);
  if (n6 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n6))
    return _arrayLikeToArray2(o13, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i8 = 0, arr2 = new Array(len); i8 < len; i8++)
    arr2[i8] = arr[i8];
  return arr2;
}
function _createForOfIteratorHelperLoose2(o13, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o13[Symbol.iterator] == null) {
    if (Array.isArray(o13) || (it = _unsupportedIterableToArray2(o13)) || allowArrayLike && o13 && typeof o13.length === "number") {
      if (it)
        o13 = it;
      var i8 = 0;
      return function() {
        if (i8 >= o13.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o13[i8++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o13[Symbol.iterator]();
  return it.next.bind(it);
}
var storedAnnotationsSymbol2 = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation2(annotation) {
  function decorator(target, property) {
    storeAnnotation2(target, property, annotation);
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation2(prototype, key, annotation) {
  if (!hasProp2(prototype, storedAnnotationsSymbol2)) {
    addHiddenProp2(prototype, storedAnnotationsSymbol2, _extends2({}, prototype[storedAnnotationsSymbol2]));
  }
  if (isOverride2(annotation) && !hasProp2(prototype[storedAnnotationsSymbol2], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die2("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated2(prototype, annotation, key);
  if (!isOverride2(annotation)) {
    prototype[storedAnnotationsSymbol2][key] = annotation;
  }
}
function assertNotDecorated2(prototype, annotation, key) {
  if (!isOverride2(annotation) && hasProp2(prototype[storedAnnotationsSymbol2], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol2][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die2("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overriden by subclass.");
  }
}
var $mobx2 = /* @__PURE__ */ Symbol("mobx administration");
var Atom2 = /* @__PURE__ */ function() {
  function Atom22(name_) {
    if (name_ === void 0) {
      name_ = true ? "Atom@" + getNextId() : "Atom";
    }
    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_2.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  var _proto = Atom22.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved2(this);
  };
  _proto.reportChanged = function reportChanged() {
    startBatch2();
    propagateChanged2(this);
    endBatch2();
  };
  _proto.toString = function toString22() {
    return this.name_;
  };
  return Atom22;
}();
var isAtom2 = /* @__PURE__ */ createInstanceofPredicate2("Atom", Atom2);
function createAtom2(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop4;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop4;
  }
  var atom = new Atom2(name);
  if (onBecomeObservedHandler !== noop4) {
    onBecomeObserved2(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop4) {
    onBecomeUnobserved2(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer2(a9, b7) {
  return a9 === b7;
}
function structuralComparer2(a9, b7) {
  return deepEqual2(a9, b7);
}
function shallowComparer2(a9, b7) {
  return deepEqual2(a9, b7, 1);
}
function defaultComparer2(a9, b7) {
  if (Object.is)
    return Object.is(a9, b7);
  return a9 === b7 ? a9 !== 0 || 1 / a9 === 1 / b7 : a9 !== a9 && b7 !== b7;
}
var comparer2 = {
  identity: identityComparer2,
  structural: structuralComparer2,
  "default": defaultComparer2,
  shallow: shallowComparer2
};
function deepEnhancer2(v6, _142, name) {
  if (isObservable2(v6))
    return v6;
  if (Array.isArray(v6))
    return observable2.array(v6, {
      name
    });
  if (isPlainObject2(v6))
    return observable2.object(v6, void 0, {
      name
    });
  if (isES6Map2(v6))
    return observable2.map(v6, {
      name
    });
  if (isES6Set2(v6))
    return observable2.set(v6, {
      name
    });
  if (typeof v6 === "function" && !isAction2(v6) && !isFlow2(v6)) {
    if (isGenerator2(v6)) {
      return flow3(v6);
    } else {
      return autoAction2(name, v6);
    }
  }
  return v6;
}
function shallowEnhancer2(v6, _142, name) {
  if (v6 === void 0 || v6 === null)
    return v6;
  if (isObservableObject2(v6) || isObservableArray2(v6) || isObservableMap2(v6) || isObservableSet2(v6))
    return v6;
  if (Array.isArray(v6))
    return observable2.array(v6, {
      name,
      deep: false
    });
  if (isPlainObject2(v6))
    return observable2.object(v6, void 0, {
      name,
      deep: false
    });
  if (isES6Map2(v6))
    return observable2.map(v6, {
      name,
      deep: false
    });
  if (isES6Set2(v6))
    return observable2.set(v6, {
      name,
      deep: false
    });
  if (true)
    die2("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer2(newValue) {
  return newValue;
}
function refStructEnhancer2(v6, oldValue) {
  if (isObservable2(v6))
    die2("observable.struct should not be used with observable values");
  if (deepEqual2(v6, oldValue))
    return oldValue;
  return v6;
}
var OVERRIDE2 = "override";
function isOverride2(annotation) {
  return annotation.annotationType_ === OVERRIDE2;
}
function createActionAnnotation2(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$12,
    extend_: extend_$12
  };
}
function make_$12(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction2(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor2(adm, this, key, descriptor, false);
  defineProperty3(source, key, actionDescriptor);
  return 2;
}
function extend_$12(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor2(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function assertActionDescriptor2(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (!isFunction2(value)) {
    die2("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}
function createActionDescriptor2(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState2.safeDescriptors;
  }
  assertActionDescriptor2(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction2((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, ((_annotation$options_4 = annotation.options_) == null ? void 0 : _annotation$options_4.bound) ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0),
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    enumerable: false,
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation2(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$22,
    extend_: extend_$22
  };
}
function make_$22(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) && !isFlow2(adm.target_[key])) {
    if (this.extend_(adm, key, descriptor, false) === null)
      return 0;
  }
  if (isFlow2(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor2(adm, this, key, descriptor, false, false);
  defineProperty3(source, key, flowDescriptor);
  return 2;
}
function extend_$22(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor2(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function assertFlowDescriptor2(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (!isFunction2(value)) {
    die2("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}
function createFlowDescriptor2(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState2.safeDescriptors;
  }
  assertFlowDescriptor2(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: flow3(value),
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    enumerable: false,
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation2(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$32,
    extend_: extend_$32
  };
}
function make_$32(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$32(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor2(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends2({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function assertComputedDescriptor2(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get32 = _ref2.get;
  if (!get32) {
    die2("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}
function createObservableAnnotation2(name, options2) {
  return {
    annotationType_: name,
    options_: options2,
    make_: make_$42,
    extend_: extend_$42
  };
}
function make_$42(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$42(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor2(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer2, proxyTrap);
}
function assertObservableDescriptor2(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;
  if (!("value" in descriptor)) {
    die2("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}
var AUTO2 = "true";
var autoAnnotation2 = /* @__PURE__ */ createAutoAnnotation2();
function createAutoAnnotation2(options2) {
  return {
    annotationType_: AUTO2,
    options_: options2,
    make_: make_$52,
    extend_: extend_$52
  };
}
function make_$52(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed3.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set42 = createAction2(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState2.safeDescriptors ? adm.isPlainObject_ : true,
        set: set42
      }) === null ? 0 : 2;
    }
    defineProperty3(source, key, {
      configurable: true,
      set: set42
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator2(descriptor.value)) {
      var _this$options_;
      var flowAnnotation22 = ((_this$options_ = this.options_) == null ? void 0 : _this$options_.autoBind) ? flow3.bound : flow3;
      return flowAnnotation22.make_(adm, key, descriptor, source);
    }
    var actionAnnotation22 = ((_this$options_2 = this.options_) == null ? void 0 : _this$options_2.autoBind) ? autoAction2.bound : autoAction2;
    return actionAnnotation22.make_(adm, key, descriptor, source);
  }
  var observableAnnotation22 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable2.ref : observable2;
  if (typeof descriptor.value === "function" && ((_this$options_4 = this.options_) == null ? void 0 : _this$options_4.autoBind)) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation22.make_(adm, key, descriptor, source);
}
function extend_$52(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed3.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState2.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction2(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && ((_this$options_5 = this.options_) == null ? void 0 : _this$options_5.autoBind)) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation22 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable2.ref : observable2;
  return observableAnnotation22.extend_(adm, key, descriptor, proxyTrap);
}
var OBSERVABLE2 = "observable";
var OBSERVABLE_REF2 = "observable.ref";
var OBSERVABLE_SHALLOW2 = "observable.shallow";
var OBSERVABLE_STRUCT2 = "observable.struct";
var defaultCreateObservableOptions2 = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions2);
function asCreateObservableOptions2(thing) {
  return thing || defaultCreateObservableOptions2;
}
var observableAnnotation2 = /* @__PURE__ */ createObservableAnnotation2(OBSERVABLE2);
var observableRefAnnotation2 = /* @__PURE__ */ createObservableAnnotation2(OBSERVABLE_REF2, {
  enhancer: referenceEnhancer2
});
var observableShallowAnnotation2 = /* @__PURE__ */ createObservableAnnotation2(OBSERVABLE_SHALLOW2, {
  enhancer: shallowEnhancer2
});
var observableStructAnnotation2 = /* @__PURE__ */ createObservableAnnotation2(OBSERVABLE_STRUCT2, {
  enhancer: refStructEnhancer2
});
var observableDecoratorAnnotation2 = /* @__PURE__ */ createDecoratorAnnotation2(observableAnnotation2);
function getEnhancerFromOptions2(options2) {
  return options2.deep === true ? deepEnhancer2 : options2.deep === false ? referenceEnhancer2 : getEnhancerFromAnnotation2(options2.defaultDecorator);
}
function getAnnotationFromOptions2(options2) {
  var _options$defaultDecor;
  return options2 ? (_options$defaultDecor = options2.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation2(options2) : void 0;
}
function getEnhancerFromAnnotation2(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer2 : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer2;
}
function createObservable2(v6, arg2, arg3) {
  if (isStringish2(arg2)) {
    storeAnnotation2(v6, arg2, observableAnnotation2);
    return;
  }
  if (isObservable2(v6))
    return v6;
  if (isPlainObject2(v6))
    return observable2.object(v6, arg2, arg3);
  if (Array.isArray(v6))
    return observable2.array(v6, arg2);
  if (isES6Map2(v6))
    return observable2.map(v6, arg2);
  if (isES6Set2(v6))
    return observable2.set(v6, arg2);
  if (typeof v6 === "object" && v6 !== null)
    return v6;
  return observable2.box(v6, arg2);
}
Object.assign(createObservable2, observableDecoratorAnnotation2);
var observableFactories2 = {
  box: function box2(value, options2) {
    var o13 = asCreateObservableOptions2(options2);
    return new ObservableValue2(value, getEnhancerFromOptions2(o13), o13.name, true, o13.equals);
  },
  array: function array2(initialValues, options2) {
    var o13 = asCreateObservableOptions2(options2);
    return (globalState2.useProxies === false || o13.proxy === false ? createLegacyArray2 : createObservableArray2)(initialValues, getEnhancerFromOptions2(o13), o13.name);
  },
  map: function map2(initialValues, options2) {
    var o13 = asCreateObservableOptions2(options2);
    return new ObservableMap2(initialValues, getEnhancerFromOptions2(o13), o13.name);
  },
  set: function set4(initialValues, options2) {
    var o13 = asCreateObservableOptions2(options2);
    return new ObservableSet2(initialValues, getEnhancerFromOptions2(o13), o13.name);
  },
  object: function object2(props, decorators, options2) {
    return extendObservable2(globalState2.useProxies === false || (options2 == null ? void 0 : options2.proxy) === false ? asObservableObject2({}, options2) : asDynamicObservableObject2({}, options2), props, decorators);
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation2(observableRefAnnotation2),
  shallow: /* @__PURE__ */ createDecoratorAnnotation2(observableShallowAnnotation2),
  deep: observableDecoratorAnnotation2,
  struct: /* @__PURE__ */ createDecoratorAnnotation2(observableStructAnnotation2)
};
var observable2 = /* @__PURE__ */ assign2(createObservable2, observableFactories2);
var COMPUTED2 = "computed";
var COMPUTED_STRUCT2 = "computed.struct";
var computedAnnotation2 = /* @__PURE__ */ createComputedAnnotation2(COMPUTED2);
var computedStructAnnotation2 = /* @__PURE__ */ createComputedAnnotation2(COMPUTED_STRUCT2, {
  equals: comparer2.structural
});
var computed3 = function computed22(arg1, arg2) {
  if (isStringish2(arg2)) {
    return storeAnnotation2(arg1, arg2, computedAnnotation2);
  }
  if (isPlainObject2(arg1)) {
    return createDecoratorAnnotation2(createComputedAnnotation2(COMPUTED2, arg1));
  }
  if (true) {
    if (!isFunction2(arg1))
      die2("First argument to `computed` should be an expression.");
    if (isFunction2(arg2))
      die2("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  }
  var opts = isPlainObject2(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue2(opts);
};
Object.assign(computed3, computedAnnotation2);
computed3.struct = /* @__PURE__ */ createDecoratorAnnotation2(computedStructAnnotation2);
var _getDescriptor$config2;
var _getDescriptor2;
var currentActionId2 = 0;
var nextActionId2 = 1;
var isFunctionNameConfigurable2 = (_getDescriptor$config2 = (_getDescriptor2 = /* @__PURE__ */ getDescriptor2(function() {
}, "name")) == null ? void 0 : _getDescriptor2.configurable) != null ? _getDescriptor$config2 : false;
var tmpNameDescriptor2 = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction2(actionName, fn, autoAction22, ref) {
  if (autoAction22 === void 0) {
    autoAction22 = false;
  }
  if (true) {
    if (!isFunction2(fn))
      die2("`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName)
      die2("actions should have valid names, got: '" + actionName + "'");
  }
  function res() {
    return executeAction2(actionName, autoAction22, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  if (isFunctionNameConfigurable2) {
    tmpNameDescriptor2.value = actionName;
    Object.defineProperty(res, "name", tmpNameDescriptor2);
  }
  return res;
}
function executeAction2(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction2(actionName, canRunAsDerivation, scope, args);
  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction2(runInfo);
  }
}
function _startAction2(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = isSpyEnabled2() && !!actionName;
  var startTime_ = 0;
  if (notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY2;
    spyReportStart({
      type: ACTION2,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }
  var prevDerivation_ = globalState2.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch2();
  var prevAllowStateChanges_ = globalState2.allowStateChanges;
  if (runAsAction) {
    untrackedStart2();
    prevAllowStateChanges_ = allowStateChangesStart2(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart2(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId2++,
    parentActionId_: currentActionId2
  };
  currentActionId2 = runInfo.actionId_;
  return runInfo;
}
function _endAction2(runInfo) {
  if (currentActionId2 !== runInfo.actionId_) {
    die2(30);
  }
  currentActionId2 = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState2.suppressReactionErrors = true;
  }
  allowStateChangesEnd2(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd2(runInfo.prevAllowStateReads_);
  endBatch2();
  if (runInfo.runAsAction_)
    untrackedEnd2(runInfo.prevDerivation_);
  if (runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }
  globalState2.suppressReactionErrors = false;
}
function allowStateChangesStart2(allowStateChanges) {
  var prev = globalState2.allowStateChanges;
  globalState2.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd2(prev) {
  globalState2.allowStateChanges = prev;
}
var _Symbol$toPrimitive2;
var CREATE = "create";
_Symbol$toPrimitive2 = Symbol.toPrimitive;
var ObservableValue2 = /* @__PURE__ */ function(_Atom) {
  _inheritsLoose2(ObservableValue22, _Atom);
  function ObservableValue22(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = true ? "ObservableValue@" + getNextId() : "ObservableValue";
    }
    if (notifySpy === void 0) {
      notifySpy = true;
    }
    if (equals === void 0) {
      equals = comparer2["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    if (notifySpy && isSpyEnabled2()) {
      spyReport({
        type: CREATE,
        object: _assertThisInitialized2(_this),
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }
    return _this;
  }
  var _proto = ObservableValue22.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0)
      return this.dehancer(value);
    return value;
  };
  _proto.set = function set42(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState2.UNCHANGED) {
      var notifySpy = isSpyEnabled2();
      if (notifySpy) {
        spyReportStart({
          type: UPDATE2,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue,
          oldValue
        });
      }
      this.setNewValue_(newValue);
      if (notifySpy)
        spyReportEnd();
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed2(this);
    if (hasInterceptors2(this)) {
      var change = interceptChange2(this, {
        object: this,
        type: UPDATE2,
        newValue
      });
      if (!change)
        return globalState2.UNCHANGED;
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState2.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners2(this)) {
      notifyListeners2(this, {
        type: UPDATE2,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get32() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor2(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately)
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE2,
        newValue: this.value_,
        oldValue: void 0
      });
    return registerListener2(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON22() {
    return this.get();
  };
  _proto.toString = function toString22() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive2(this.get());
  };
  _proto[_Symbol$toPrimitive2] = function() {
    return this.valueOf();
  };
  return ObservableValue22;
}(Atom2);
var _Symbol$toPrimitive$12;
_Symbol$toPrimitive$12 = Symbol.toPrimitive;
var ComputedValue2 = /* @__PURE__ */ function() {
  function ComputedValue22(options2) {
    this.dependenciesState_ = IDerivationState_2.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_2.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException3(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode2.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options2.get)
      die2(31);
    this.derivation = options2.get;
    this.name_ = options2.name || (true ? "ComputedValue@" + getNextId() : "ComputedValue");
    if (options2.set) {
      this.setter_ = createAction2(true ? this.name_ + "-setter" : "ComputedValue-setter", options2.set);
    }
    this.equals_ = options2.equals || (options2.compareStructural || options2.struct ? comparer2.structural : comparer2["default"]);
    this.scope_ = options2.context;
    this.requiresReaction_ = !!options2.requiresReaction;
    this.keepAlive_ = !!options2.keepAlive;
  }
  var _proto = ComputedValue22.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged2(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get32() {
    if (this.isComputing_)
      die2(32, this.name_, this.derivation);
    if (globalState2.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute2(this)) {
        this.warnAboutUntrackedRead_();
        startBatch2();
        this.value_ = this.computeValue_(false);
        endBatch2();
      }
    } else {
      reportObserved2(this);
      if (shouldCompute2(this)) {
        var prevTrackingContext = globalState2.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext)
          globalState2.trackingContext = this;
        if (this.trackAndCompute())
          propagateChangeConfirmed2(this);
        globalState2.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException2(result))
      throw result.cause;
    return result;
  };
  _proto.set = function set42(value) {
    if (this.setter_) {
      if (this.isRunningSetter_)
        die2(33, this.name_);
      this.isRunningSetter_ = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else
      die2(34, this.name_);
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = this.dependenciesState_ === IDerivationState_2.NOT_TRACKING_;
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException2(oldValue) || isCaughtException2(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
      if (isSpyEnabled2()) {
        spyReport({
          observableKind: "computed",
          debugObjectName: this.name_,
          object: this.scope_,
          type: "update",
          oldValue,
          newValue
        });
      }
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true;
    var prev = allowStateChangesStart2(false);
    var res;
    if (track) {
      res = trackDerivedFunction2(this, this.derivation, this.scope_);
    } else {
      if (globalState2.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e12) {
          res = new CaughtException3(e12);
        }
      }
    }
    allowStateChangesEnd2(prev);
    this.isComputing_ = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving2(this);
      this.value_ = void 0;
      if (this.isTracing_ !== TraceMode2.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun2(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart2();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE2,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd2(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    if (false)
      return;
    if (this.isTracing_ !== TraceMode2.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
    if (globalState2.computedRequiresReaction || this.requiresReaction_) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };
  _proto.toString = function toString22() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive2(this.get());
  };
  _proto[_Symbol$toPrimitive$12] = function() {
    return this.valueOf();
  };
  return ComputedValue22;
}();
var isComputedValue2 = /* @__PURE__ */ createInstanceofPredicate2("ComputedValue", ComputedValue2);
var IDerivationState_2;
(function(IDerivationState_22) {
  IDerivationState_22[IDerivationState_22["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_22[IDerivationState_22["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_22[IDerivationState_22["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_22[IDerivationState_22["STALE_"] = 2] = "STALE_";
})(IDerivationState_2 || (IDerivationState_2 = {}));
var TraceMode2;
(function(TraceMode22) {
  TraceMode22[TraceMode22["NONE"] = 0] = "NONE";
  TraceMode22[TraceMode22["LOG"] = 1] = "LOG";
  TraceMode22[TraceMode22["BREAK"] = 2] = "BREAK";
})(TraceMode2 || (TraceMode2 = {}));
var CaughtException3 = function CaughtException22(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException2(e12) {
  return e12 instanceof CaughtException3;
}
function shouldCompute2(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_2.UP_TO_DATE_:
      return false;
    case IDerivationState_2.NOT_TRACKING_:
    case IDerivationState_2.STALE_:
      return true;
    case IDerivationState_2.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart2(true);
      var prevUntracked = untrackedStart2();
      var obs = derivation.observing_, l9 = obs.length;
      for (var i8 = 0; i8 < l9; i8++) {
        var obj = obs[i8];
        if (isComputedValue2(obj)) {
          if (globalState2.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e12) {
              untrackedEnd2(prevUntracked);
              allowStateReadsEnd2(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_2.STALE_) {
            untrackedEnd2(prevUntracked);
            allowStateReadsEnd2(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo02(derivation);
      untrackedEnd2(prevUntracked);
      allowStateReadsEnd2(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed2(atom) {
  if (false) {
    return;
  }
  var hasObservers = atom.observers_.size > 0;
  if (!globalState2.allowStateChanges && (hasObservers || globalState2.enforceActions === "always"))
    console.warn("[MobX] " + (globalState2.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
}
function checkIfStateReadsAreAllowed2(observable22) {
  if (!globalState2.allowStateReads && globalState2.observableRequiresReaction) {
    console.warn("[mobx] Observable '" + observable22.name_ + "' being read outside a reactive context.");
  }
}
function trackDerivedFunction2(derivation, f11, context2) {
  var prevAllowStateReads = allowStateReadsStart2(true);
  changeDependenciesStateTo02(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState2.runId;
  var prevTracking = globalState2.trackingDerivation;
  globalState2.trackingDerivation = derivation;
  globalState2.inBatch++;
  var result;
  if (globalState2.disableErrorBoundaries === true) {
    result = f11.call(context2);
  } else {
    try {
      result = f11.call(context2);
    } catch (e12) {
      result = new CaughtException3(e12);
    }
  }
  globalState2.inBatch--;
  globalState2.trackingDerivation = prevTracking;
  bindDependencies2(derivation);
  warnAboutDerivationWithoutDependencies2(derivation);
  allowStateReadsEnd2(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies2(derivation) {
  if (false)
    return;
  if (derivation.observing_.length !== 0)
    return;
  if (globalState2.reactionRequiresObservable || derivation.requiresObservable_) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
function bindDependencies2(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_2.UP_TO_DATE_;
  var i0 = 0, l9 = derivation.unboundDepsCount_;
  for (var i8 = 0; i8 < l9; i8++) {
    var dep = observing[i8];
    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i8)
        observing[i0] = dep;
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l9 = prevObserving.length;
  while (l9--) {
    var _dep = prevObserving[l9];
    if (_dep.diffValue_ === 0) {
      removeObserver2(_dep, derivation);
    }
    _dep.diffValue_ = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver2(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_2.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving2(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i8 = obs.length;
  while (i8--) {
    removeObserver2(obs[i8], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_2.NOT_TRACKING_;
}
function untracked2(action22) {
  var prev = untrackedStart2();
  try {
    return action22();
  } finally {
    untrackedEnd2(prev);
  }
}
function untrackedStart2() {
  var prev = globalState2.trackingDerivation;
  globalState2.trackingDerivation = null;
  return prev;
}
function untrackedEnd2(prev) {
  globalState2.trackingDerivation = prev;
}
function allowStateReadsStart2(allowStateReads) {
  var prev = globalState2.allowStateReads;
  globalState2.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd2(prev) {
  globalState2.allowStateReads = prev;
}
function changeDependenciesStateTo02(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_2.UP_TO_DATE_)
    return;
  derivation.dependenciesState_ = IDerivationState_2.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i8 = obs.length;
  while (i8--) {
    obs[i8].lowestObserverState_ = IDerivationState_2.UP_TO_DATE_;
  }
}
var MobXGlobals3 = function MobXGlobals22() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState2 = true;
var isolateCalled2 = false;
var globalState2 = /* @__PURE__ */ function() {
  var global2 = /* @__PURE__ */ getGlobal2();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals)
    canMergeGlobalState2 = false;
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals3().version)
    canMergeGlobalState2 = false;
  if (!canMergeGlobalState2) {
    setTimeout(function() {
      if (!isolateCalled2) {
        die2(35);
      }
    }, 1);
    return new MobXGlobals3();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED)
      global2.__mobxGlobals.UNCHANGED = {};
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals3();
  }
}();
function addObserver2(observable22, node) {
  observable22.observers_.add(node);
  if (observable22.lowestObserverState_ > node.dependenciesState_)
    observable22.lowestObserverState_ = node.dependenciesState_;
}
function removeObserver2(observable22, node) {
  observable22.observers_["delete"](node);
  if (observable22.observers_.size === 0) {
    queueForUnobservation2(observable22);
  }
}
function queueForUnobservation2(observable22) {
  if (observable22.isPendingUnobservation_ === false) {
    observable22.isPendingUnobservation_ = true;
    globalState2.pendingUnobservations.push(observable22);
  }
}
function startBatch2() {
  globalState2.inBatch++;
}
function endBatch2() {
  if (--globalState2.inBatch === 0) {
    runReactions2();
    var list = globalState2.pendingUnobservations;
    for (var i8 = 0; i8 < list.length; i8++) {
      var observable22 = list[i8];
      observable22.isPendingUnobservation_ = false;
      if (observable22.observers_.size === 0) {
        if (observable22.isBeingObserved_) {
          observable22.isBeingObserved_ = false;
          observable22.onBUO();
        }
        if (observable22 instanceof ComputedValue2) {
          observable22.suspend_();
        }
      }
    }
    globalState2.pendingUnobservations = [];
  }
}
function reportObserved2(observable22) {
  checkIfStateReadsAreAllowed2(observable22);
  var derivation = globalState2.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable22.lastAccessedBy_) {
      observable22.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable22;
      if (!observable22.isBeingObserved_ && globalState2.trackingContext) {
        observable22.isBeingObserved_ = true;
        observable22.onBO();
      }
    }
    return true;
  } else if (observable22.observers_.size === 0 && globalState2.inBatch > 0) {
    queueForUnobservation2(observable22);
  }
  return false;
}
function propagateChanged2(observable22) {
  if (observable22.lowestObserverState_ === IDerivationState_2.STALE_)
    return;
  observable22.lowestObserverState_ = IDerivationState_2.STALE_;
  observable22.observers_.forEach(function(d8) {
    if (d8.dependenciesState_ === IDerivationState_2.UP_TO_DATE_) {
      if (d8.isTracing_ !== TraceMode2.NONE) {
        logTraceInfo(d8, observable22);
      }
      d8.onBecomeStale_();
    }
    d8.dependenciesState_ = IDerivationState_2.STALE_;
  });
}
function propagateChangeConfirmed2(observable22) {
  if (observable22.lowestObserverState_ === IDerivationState_2.STALE_)
    return;
  observable22.lowestObserverState_ = IDerivationState_2.STALE_;
  observable22.observers_.forEach(function(d8) {
    if (d8.dependenciesState_ === IDerivationState_2.POSSIBLY_STALE_) {
      d8.dependenciesState_ = IDerivationState_2.STALE_;
      if (d8.isTracing_ !== TraceMode2.NONE) {
        logTraceInfo(d8, observable22);
      }
    } else if (d8.dependenciesState_ === IDerivationState_2.UP_TO_DATE_) {
      observable22.lowestObserverState_ = IDerivationState_2.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged2(observable22) {
  if (observable22.lowestObserverState_ !== IDerivationState_2.UP_TO_DATE_)
    return;
  observable22.lowestObserverState_ = IDerivationState_2.POSSIBLY_STALE_;
  observable22.observers_.forEach(function(d8) {
    if (d8.dependenciesState_ === IDerivationState_2.UP_TO_DATE_) {
      d8.dependenciesState_ = IDerivationState_2.POSSIBLY_STALE_;
      d8.onBecomeStale_();
    }
  });
}
function logTraceInfo(derivation, observable22) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable22.name_ + "'");
  if (derivation.isTracing_ === TraceMode2.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree2(derivation), lines, 1);
    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable22.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue2 ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}
function printDepTree(tree, lines, depth) {
  if (lines.length >= 1e3) {
    lines.push("(and many more)");
    return;
  }
  lines.push("" + "	".repeat(depth - 1) + tree.name);
  if (tree.dependencies)
    tree.dependencies.forEach(function(child) {
      return printDepTree(child, lines, depth + 1);
    });
}
var Reaction2 = /* @__PURE__ */ function() {
  function Reaction22(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = true ? "Reaction@" + getNextId() : "Reaction";
    }
    if (requiresObservable_ === void 0) {
      requiresObservable_ = false;
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_2.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode2.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction22.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState2.pendingReactions.push(this);
      runReactions2();
    }
  };
  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch2();
      this.isScheduled_ = false;
      var prev = globalState2.trackingContext;
      globalState2.trackingContext = this;
      if (shouldCompute2(this)) {
        this.isTrackPending_ = true;
        try {
          this.onInvalidate_();
          if (this.isTrackPending_ && isSpyEnabled2()) {
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e12) {
          this.reportExceptionInDerivation_(e12);
        }
      }
      globalState2.trackingContext = prev;
      endBatch2();
    }
  };
  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return;
    }
    startBatch2();
    var notify = isSpyEnabled2();
    var startTime;
    if (notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }
    this.isRunning_ = true;
    var prevReaction = globalState2.trackingContext;
    globalState2.trackingContext = this;
    var result = trackDerivedFunction2(this, fn, void 0);
    globalState2.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;
    if (this.isDisposed_) {
      clearObserving2(this);
    }
    if (isCaughtException2(result))
      this.reportExceptionInDerivation_(result.cause);
    if (notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }
    endBatch2();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState2.disableErrorBoundaries)
      throw error;
    var message = true ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    if (!globalState2.suppressReactionErrors) {
      console.error(message, error);
    } else if (true)
      console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
    if (isSpyEnabled2()) {
      spyReport({
        type: "error",
        name: this.name_,
        message,
        error: "" + error
      });
    }
    globalState2.globalReactionErrorHandlers.forEach(function(f11) {
      return f11(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;
      if (!this.isRunning_) {
        startBatch2();
        clearObserving2(this);
        endBatch2();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_() {
    var r13 = this.dispose.bind(this);
    r13[$mobx2] = this;
    return r13;
  };
  _proto.toString = function toString22() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }
    trace2(this, enterBreakPoint);
  };
  return Reaction22;
}();
var MAX_REACTION_ITERATIONS2 = 100;
var reactionScheduler3 = function reactionScheduler22(f11) {
  return f11();
};
function runReactions2() {
  if (globalState2.inBatch > 0 || globalState2.isRunningReactions)
    return;
  reactionScheduler3(runReactionsHelper2);
}
function runReactionsHelper2() {
  globalState2.isRunningReactions = true;
  var allReactions = globalState2.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS2) {
      console.error(true ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS2 + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i8 = 0, l9 = remainingReactions.length; i8 < l9; i8++) {
      remainingReactions[i8].runReaction_();
    }
  }
  globalState2.isRunningReactions = false;
}
var isReaction2 = /* @__PURE__ */ createInstanceofPredicate2("Reaction", Reaction2);
function isSpyEnabled2() {
  return !!globalState2.spyListeners.length;
}
function spyReport(event) {
  if (false)
    return;
  if (!globalState2.spyListeners.length)
    return;
  var listeners = globalState2.spyListeners;
  for (var i8 = 0, l9 = listeners.length; i8 < l9; i8++) {
    listeners[i8](event);
  }
}
function spyReportStart(event) {
  if (false)
    return;
  var change = _extends2({}, event, {
    spyReportStart: true
  });
  spyReport(change);
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};
function spyReportEnd(change) {
  if (false)
    return;
  if (change)
    spyReport(_extends2({}, change, {
      type: "report-end",
      spyReportEnd: true
    }));
  else
    spyReport(END_EVENT);
}
function spy2(listener) {
  if (false) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  } else {
    globalState2.spyListeners.push(listener);
    return once2(function() {
      globalState2.spyListeners = globalState2.spyListeners.filter(function(l9) {
        return l9 !== listener;
      });
    });
  }
}
var ACTION2 = "action";
var ACTION_BOUND2 = "action.bound";
var AUTOACTION2 = "autoAction";
var AUTOACTION_BOUND2 = "autoAction.bound";
var DEFAULT_ACTION_NAME2 = "<unnamed action>";
var actionAnnotation2 = /* @__PURE__ */ createActionAnnotation2(ACTION2);
var actionBoundAnnotation2 = /* @__PURE__ */ createActionAnnotation2(ACTION_BOUND2, {
  bound: true
});
var autoActionAnnotation2 = /* @__PURE__ */ createActionAnnotation2(AUTOACTION2, {
  autoAction: true
});
var autoActionBoundAnnotation2 = /* @__PURE__ */ createActionAnnotation2(AUTOACTION_BOUND2, {
  autoAction: true,
  bound: true
});
function createActionFactory2(autoAction22) {
  var res = function action22(arg1, arg2) {
    if (isFunction2(arg1))
      return createAction2(arg1.name || DEFAULT_ACTION_NAME2, arg1, autoAction22);
    if (isFunction2(arg2))
      return createAction2(arg1, arg2, autoAction22);
    if (isStringish2(arg2)) {
      return storeAnnotation2(arg1, arg2, autoAction22 ? autoActionAnnotation2 : actionAnnotation2);
    }
    if (isStringish2(arg1)) {
      return createDecoratorAnnotation2(createActionAnnotation2(autoAction22 ? AUTOACTION2 : ACTION2, {
        name: arg1,
        autoAction: autoAction22
      }));
    }
    if (true)
      die2("Invalid arguments for `action`");
  };
  return res;
}
var action2 = /* @__PURE__ */ createActionFactory2(false);
Object.assign(action2, actionAnnotation2);
var autoAction2 = /* @__PURE__ */ createActionFactory2(true);
Object.assign(autoAction2, autoActionAnnotation2);
action2.bound = /* @__PURE__ */ createDecoratorAnnotation2(actionBoundAnnotation2);
autoAction2.bound = /* @__PURE__ */ createDecoratorAnnotation2(autoActionBoundAnnotation2);
function isAction2(thing) {
  return isFunction2(thing) && thing.isMobxAction === true;
}
function autorun2(view, opts) {
  var _opts$name, _opts;
  if (opts === void 0) {
    opts = EMPTY_OBJECT2;
  }
  if (true) {
    if (!isFunction2(view))
      die2("Autorun expects a function as first argument");
    if (isAction2(view))
      die2("Autorun does not accept actions since actions are untrackable");
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : true ? view.name || "Autorun@" + getNextId() : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;
  if (runSync) {
    reaction = new Reaction2(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions2(opts);
    var isScheduled = false;
    reaction = new Reaction2(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction.isDisposed_)
            reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction);
  }
  reaction.schedule_();
  return reaction.getDisposer_();
}
var run3 = function run22(f11) {
  return f11();
};
function createSchedulerFromOptions2(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f11) {
    return setTimeout(f11, opts.delay);
  } : run3;
}
var ON_BECOME_OBSERVED2 = "onBO";
var ON_BECOME_UNOBSERVED2 = "onBUO";
function onBecomeObserved2(thing, arg2, arg3) {
  return interceptHook2(ON_BECOME_OBSERVED2, thing, arg2, arg3);
}
function onBecomeUnobserved2(thing, arg2, arg3) {
  return interceptHook2(ON_BECOME_UNOBSERVED2, thing, arg2, arg3);
}
function interceptHook2(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom2(thing, arg2) : getAtom2(thing);
  var cb = isFunction2(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
function extendObservable2(target, properties, annotations, options2) {
  if (true) {
    if (arguments.length > 4)
      die2("'extendObservable' expected 2-4 arguments");
    if (typeof target !== "object")
      die2("'extendObservable' expects an object as first argument");
    if (isObservableMap2(target))
      die2("'extendObservable' should not be used on maps, use map.merge instead");
    if (!isPlainObject2(properties))
      die2("'extendObservable' only accepts plain objects as second argument");
    if (isObservable2(properties) || isObservable2(annotations))
      die2("Extending an object with another observable (object) is not supported");
  }
  var descriptors = getOwnPropertyDescriptors3(properties);
  var adm = asObservableObject2(target, options2)[$mobx2];
  startBatch2();
  try {
    ownKeys4(descriptors).forEach(function(key) {
      adm.extend_(key, descriptors[key], !annotations ? true : key in annotations ? annotations[key] : true);
    });
  } finally {
    endBatch2();
  }
  return target;
}
function getDependencyTree2(thing, property) {
  return nodeToDependencyTree2(getAtom2(thing, property));
}
function nodeToDependencyTree2(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0)
    result.dependencies = unique2(node.observing_).map(nodeToDependencyTree2);
  return result;
}
function unique2(list) {
  return Array.from(new Set(list));
}
var generatorId2 = 0;
function FlowCancellationError2() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation2 = /* @__PURE__ */ createFlowAnnotation2("flow");
var flowBoundAnnotation2 = /* @__PURE__ */ createFlowAnnotation2("flow.bound", {
  bound: true
});
var flow3 = /* @__PURE__ */ Object.assign(function flow22(arg1, arg2) {
  if (isStringish2(arg2)) {
    return storeAnnotation2(arg1, arg2, flowAnnotation2);
  }
  if (arguments.length !== 1)
    die2("Flow expects single argument with generator function");
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId2;
    var gen = action2(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action2(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e12) {
          return reject(e12);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action2(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e12) {
          return reject(e12);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction2(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject);
          return;
        }
        if (ret.done)
          return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action2(name + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise)
          cancelPromise2(pendingPromise);
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop4, noop4);
        cancelPromise2(yieldedPromise);
        rejector(new FlowCancellationError2());
      } catch (e12) {
        rejector(e12);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation2);
flow3.bound = /* @__PURE__ */ createDecoratorAnnotation2(flowBoundAnnotation2);
function cancelPromise2(promise) {
  if (isFunction2(promise.cancel))
    promise.cancel();
}
function isFlow2(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}
function _isObservable2(value, property) {
  if (!value)
    return false;
  if (property !== void 0) {
    if (isObservableMap2(value) || isObservableArray2(value))
      return die2("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
    if (isObservableObject2(value)) {
      return value[$mobx2].values_.has(property);
    }
    return false;
  }
  return isObservableObject2(value) || !!value[$mobx2] || isAtom2(value) || isReaction2(value) || isComputedValue2(value);
}
function isObservable2(value) {
  if (arguments.length !== 1)
    die2("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable2(value);
}
function trace2() {
  if (false)
    die2("trace() is not available in production builds");
  var enterBreakPoint = false;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[args.length - 1] === "boolean")
    enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs2(args);
  if (!derivation) {
    return die2("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing_ === TraceMode2.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }
  derivation.isTracing_ = enterBreakPoint ? TraceMode2.BREAK : TraceMode2.LOG;
}
function getAtomFromArgs2(args) {
  switch (args.length) {
    case 0:
      return globalState2.trackingDerivation;
    case 1:
      return getAtom2(args[0]);
    case 2:
      return getAtom2(args[0], args[1]);
  }
}
function transaction2(action22, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch2();
  try {
    return action22.apply(thisArg);
  } finally {
    endBatch2();
  }
}
function getAdm2(target) {
  return target[$mobx2];
}
var objectProxyTraps2 = {
  has: function has2(target, name) {
    if (globalState2.trackingDerivation)
      warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    return getAdm2(target).has_(name);
  },
  get: function get3(target, name) {
    return getAdm2(target).get_(name);
  },
  set: function set22(target, name, value) {
    var _getAdm$set_;
    if (!isStringish2(name))
      return false;
    if (!getAdm2(target).values_.has(name)) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    }
    return (_getAdm$set_ = getAdm2(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty2(target, name) {
    var _getAdm$delete_;
    if (true) {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }
    if (!isStringish2(name))
      return false;
    return (_getAdm$delete_ = getAdm2(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty22(target, name, descriptor) {
    var _getAdm$definePropert;
    if (true) {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    }
    return (_getAdm$definePropert = getAdm2(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys22(target) {
    if (globalState2.trackingDerivation)
      warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    return getAdm2(target).ownKeys_();
  },
  preventExtensions: function preventExtensions3(target) {
    die2(13);
  }
};
function asDynamicObservableObject2(target, options2) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies2();
  target = asObservableObject2(target, options2);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx2]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps2);
}
function hasInterceptors2(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor2(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once2(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1)
      interceptors.splice(idx, 1);
  });
}
function interceptChange2(interceptable, change) {
  var prevU = untrackedStart2();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i8 = 0, l9 = interceptors.length; i8 < l9; i8++) {
      change = interceptors[i8](change);
      if (change && !change.type)
        die2(14);
      if (!change)
        break;
    }
    return change;
  } finally {
    untrackedEnd2(prevU);
  }
}
function hasListeners2(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener2(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once2(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1)
      listeners.splice(idx, 1);
  });
}
function notifyListeners2(listenable, change) {
  var prevU = untrackedStart2();
  var listeners = listenable.changeListeners_;
  if (!listeners)
    return;
  listeners = listeners.slice();
  for (var i8 = 0, l9 = listeners.length; i8 < l9; i8++) {
    listeners[i8](change);
  }
  untrackedEnd2(prevU);
}
var SPLICE2 = "splice";
var UPDATE2 = "update";
var MAX_SPLICE_SIZE2 = 1e4;
var arrayTraps2 = {
  get: function get22(target, name) {
    var adm = target[$mobx2];
    if (name === $mobx2)
      return adm;
    if (name === "length")
      return adm.getArrayLength_();
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp2(arrayExtensions2, name)) {
      return arrayExtensions2[name];
    }
    return target[name];
  },
  set: function set32(target, name, value) {
    var adm = target[$mobx2];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions22() {
    die2(15);
  }
};
var ObservableArrayAdministration2 = /* @__PURE__ */ function() {
  function ObservableArrayAdministration22(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom2(name);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, true ? name + "[..]" : "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration22.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0)
      return this.dehancer(value);
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== void 0 && values.length > 0)
      return values.map(this.dehancer);
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor2(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener2(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0)
      die2("Out of range: " + newLength);
    var currentLength = this.values_.length;
    if (newLength === currentLength)
      return;
    else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i8 = 0; i8 < newLength - currentLength; i8++) {
        newItems[i8] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else
      this.spliceWithArray_(newLength, currentLength - newLength);
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_)
      die2(16);
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0)
      reserveArrayBuffer2(oldLength + delta + 1);
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed2(this.atom_);
    var length = this.values_.length;
    if (index2 === void 0)
      index2 = 0;
    else if (index2 > length)
      index2 = length;
    else if (index2 < 0)
      index2 = Math.max(0, length + index2);
    if (arguments.length === 1)
      deleteCount = length - index2;
    else if (deleteCount === void 0 || deleteCount === null)
      deleteCount = 0;
    else
      deleteCount = Math.max(0, Math.min(deleteCount, length - index2));
    if (newItems === void 0)
      newItems = EMPTY_ARRAY2;
    if (hasInterceptors2(this)) {
      var change = interceptChange2(this, {
        object: this.proxy_,
        type: SPLICE2,
        index: index2,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change)
        return EMPTY_ARRAY2;
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v6) {
      return _this.enhancer_(v6, void 0);
    });
    if (this.legacyMode_ || true) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0)
      this.notifyArraySplice_(index2, newItems, res);
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE2) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index2, index2 + deleteCount);
      var oldItems = this.values_.slice(index2 + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i8 = 0; i8 < newItems.length; i8++) {
        this.values_[index2 + i8] = newItems[i8];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index2 + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled2();
    var notify = hasListeners2(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE2,
      debugObjectName: this.atom_.name_,
      index: index2,
      newValue,
      oldValue
    } : null;
    if (notifySpy)
      spyReportStart(change);
    this.atom_.reportChanged();
    if (notify)
      notifyListeners2(this, change);
    if (notifySpy)
      spyReportEnd();
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled2();
    var notify = hasListeners2(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE2,
      index: index2,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if (notifySpy)
      spyReportStart(change);
    this.atom_.reportChanged();
    if (notify)
      notifyListeners2(this, change);
    if (notifySpy)
      spyReportEnd();
  };
  _proto.get_ = function get_(index2) {
    if (index2 < this.values_.length) {
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index2]);
    }
    console.warn(true ? "[mobx] Out of bounds read: " + index2 : "[mobx.array] Attempt to read an array index (" + index2 + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
  };
  _proto.set_ = function set_(index2, newValue) {
    var values = this.values_;
    if (index2 < values.length) {
      checkIfStateModificationsAreAllowed2(this.atom_);
      var oldValue = values[index2];
      if (hasInterceptors2(this)) {
        var change = interceptChange2(this, {
          type: UPDATE2,
          object: this.proxy_,
          index: index2,
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index2] = newValue;
        this.notifyArrayChildUpdate_(index2, newValue, oldValue);
      }
    } else if (index2 === values.length) {
      this.spliceWithArray_(index2, 0, [newValue]);
    } else {
      die2(17, index2, values.length);
    }
  };
  return ObservableArrayAdministration22;
}();
function createObservableArray2(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies2();
  var adm = new ObservableArrayAdministration2(name, enhancer, owned, false);
  addHiddenFinalProp2(adm.values_, $mobx2, adm);
  var proxy = new Proxy(adm.values_, arrayTraps2);
  adm.proxy_ = proxy;
  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart2(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd2(prev);
  }
  return proxy;
}
var arrayExtensions2 = {
  clear: function clear2() {
    return this.splice(0);
  },
  replace: function replace2(newItems) {
    var adm = this[$mobx2];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  toJSON: function toJSON2() {
    return this.slice();
  },
  splice: function splice2(index2, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx2];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index2);
      case 2:
        return adm.spliceWithArray_(index2, deleteCount);
    }
    return adm.spliceWithArray_(index2, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray2(index2, deleteCount, newItems) {
    return this[$mobx2].spliceWithArray_(index2, deleteCount, newItems);
  },
  push: function push2() {
    var adm = this[$mobx2];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop2() {
    return this.splice(Math.max(this[$mobx2].values_.length - 1, 0), 1)[0];
  },
  shift: function shift2() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift2() {
    var adm = this[$mobx2];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse2() {
    if (globalState2.trackingDerivation) {
      die2(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort2() {
    if (globalState2.trackingDerivation) {
      die2(37, "sort");
    }
    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove2(value) {
    var adm = this[$mobx2];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension2("concat", simpleFunc2);
addArrayExtension2("flat", simpleFunc2);
addArrayExtension2("includes", simpleFunc2);
addArrayExtension2("indexOf", simpleFunc2);
addArrayExtension2("join", simpleFunc2);
addArrayExtension2("lastIndexOf", simpleFunc2);
addArrayExtension2("slice", simpleFunc2);
addArrayExtension2("toString", simpleFunc2);
addArrayExtension2("toLocaleString", simpleFunc2);
addArrayExtension2("every", mapLikeFunc2);
addArrayExtension2("filter", mapLikeFunc2);
addArrayExtension2("find", mapLikeFunc2);
addArrayExtension2("findIndex", mapLikeFunc2);
addArrayExtension2("flatMap", mapLikeFunc2);
addArrayExtension2("forEach", mapLikeFunc2);
addArrayExtension2("map", mapLikeFunc2);
addArrayExtension2("some", mapLikeFunc2);
addArrayExtension2("reduce", reduceLikeFunc2);
addArrayExtension2("reduceRight", reduceLikeFunc2);
function addArrayExtension2(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions2[funcName] = funcFactory(funcName);
  }
}
function simpleFunc2(funcName) {
  return function() {
    var adm = this[$mobx2];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc2(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx2];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index2) {
      return callback.call(thisArg, element, index2, _this2);
    });
  };
}
function reduceLikeFunc2(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx2];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index2) {
      return callback(accumulator, currentValue, index2, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration2 = /* @__PURE__ */ createInstanceofPredicate2("ObservableArrayAdministration", ObservableArrayAdministration2);
function isObservableArray2(thing) {
  return isObject2(thing) && isObservableArrayAdministration2(thing[$mobx2]);
}
var _Symbol$iterator2;
var _Symbol$toStringTag2;
var ObservableMapMarker2 = {};
var ADD2 = "add";
var DELETE2 = "delete";
_Symbol$iterator2 = Symbol.iterator;
_Symbol$toStringTag2 = Symbol.toStringTag;
var ObservableMap2 = /* @__PURE__ */ function() {
  function ObservableMap22(initialData, enhancer_, name_) {
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer2;
    }
    if (name_ === void 0) {
      name_ = true ? "ObservableMap@" + getNextId() : "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx2] = ObservableMapMarker2;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction2(Map)) {
      die2(18);
    }
    this.keysAtom_ = createAtom2(true ? this.name_ + ".keys()" : "ObservableMap.keys()");
    this.data_ = new Map();
    this.hasMap_ = new Map();
    this.merge(initialData);
  }
  var _proto = ObservableMap22.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has22(key) {
    var _this = this;
    if (!globalState2.trackingDerivation)
      return this.has_(key);
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue2(this.has_(key), referenceEnhancer2, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved2(newEntry, function() {
        return _this.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set42(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors2(this)) {
      var change = interceptChange2(this, {
        type: hasKey ? UPDATE2 : ADD2,
        object: this,
        newValue: value,
        name: key
      });
      if (!change)
        return this;
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this2 = this;
    checkIfStateModificationsAreAllowed2(this.keysAtom_);
    if (hasInterceptors2(this)) {
      var change = interceptChange2(this, {
        type: DELETE2,
        object: this,
        name: key
      });
      if (!change)
        return false;
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled2();
      var notify = hasListeners2(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE2,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      if (notifySpy)
        spyReportStart(_change);
      transaction2(function() {
        var _this2$hasMap_$get;
        _this2.keysAtom_.reportChanged();
        (_this2$hasMap_$get = _this2.hasMap_.get(key)) == null ? void 0 : _this2$hasMap_$get.setNewValue_(false);
        var observable22 = _this2.data_.get(key);
        observable22.setNewValue_(void 0);
        _this2.data_["delete"](key);
      });
      if (notify)
        notifyListeners2(this, _change);
      if (notifySpy)
        spyReportEnd();
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable22 = this.data_.get(key);
    newValue = observable22.prepareNewValue_(newValue);
    if (newValue !== globalState2.UNCHANGED) {
      var notifySpy = isSpyEnabled2();
      var notify = hasListeners2(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE2,
        object: this,
        oldValue: observable22.value_,
        name: key,
        newValue
      } : null;
      if (notifySpy)
        spyReportStart(change);
      observable22.setNewValue_(newValue);
      if (notify)
        notifyListeners2(this, change);
      if (notifySpy)
        spyReportEnd();
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed2(this.keysAtom_);
    transaction2(function() {
      var _this3$hasMap_$get;
      var observable22 = new ObservableValue2(newValue, _this3.enhancer_, true ? _this3.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
      _this3.data_.set(key, observable22);
      newValue = observable22.value_;
      (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(true);
      _this3.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled2();
    var notify = hasListeners2(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD2,
      object: this,
      name: key,
      newValue
    } : null;
    if (notifySpy)
      spyReportStart(change);
    if (notify)
      notifyListeners2(this, change);
    if (notifySpy)
      spyReportEnd();
  };
  _proto.get = function get32(key) {
    if (this.has(key))
      return this.dehanceValue_(this.data_.get(key).get());
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self2 = this;
    var keys = this.keys();
    return makeIterable2({
      next: function next() {
        var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self2 = this;
    var keys = this.keys();
    return makeIterable2({
      next: function next() {
        var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[_Symbol$iterator2] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose2(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge(other) {
    var _this4 = this;
    if (isObservableMap2(other)) {
      other = new Map(other);
    }
    transaction2(function() {
      if (isPlainObject2(other))
        getPlainObjectKeys2(other).forEach(function(key) {
          return _this4.set(key, other[key]);
        });
      else if (Array.isArray(other))
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this4.set(key, value);
        });
      else if (isES6Map2(other)) {
        if (other.constructor !== Map)
          die2(19, other);
        other.forEach(function(value, key) {
          return _this4.set(key, value);
        });
      } else if (other !== null && other !== void 0)
        die2(20, other);
    });
    return this;
  };
  _proto.clear = function clear22() {
    var _this5 = this;
    transaction2(function() {
      untracked2(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose2(_this5.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this5["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace22(values) {
    var _this6 = this;
    transaction2(function() {
      var replacementMap = convertToMap2(values);
      var orderedData = new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose2(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this6["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this6.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose2(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this6.data_.has(_key);
        _this6.set(_key, _value);
        if (_this6.data_.has(_key)) {
          var _value2 = _this6.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this6.data_.size !== orderedData.size) {
          _this6.keysAtom_.reportChanged();
        } else {
          var iter1 = _this6.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this6.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this6.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString22() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON22() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === true)
      die2("`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener2(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor2(this, handler);
  };
  _createClass2(ObservableMap22, [{
    key: "size",
    get: function get32() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get32() {
      return "Map";
    }
  }]);
  return ObservableMap22;
}();
var isObservableMap2 = /* @__PURE__ */ createInstanceofPredicate2("ObservableMap", ObservableMap2);
function convertToMap2(dataStructure) {
  if (isES6Map2(dataStructure) || isObservableMap2(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject2(dataStructure)) {
    var map22 = new Map();
    for (var key in dataStructure) {
      map22.set(key, dataStructure[key]);
    }
    return map22;
  } else {
    return die2(21, dataStructure);
  }
}
var _Symbol$iterator$12;
var _Symbol$toStringTag$12;
var ObservableSetMarker2 = {};
_Symbol$iterator$12 = Symbol.iterator;
_Symbol$toStringTag$12 = Symbol.toStringTag;
var ObservableSet2 = /* @__PURE__ */ function() {
  function ObservableSet22(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer2;
    }
    if (name_ === void 0) {
      name_ = true ? "ObservableSet@" + getNextId() : "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx2] = ObservableSetMarker2;
    this.data_ = new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction2(Set)) {
      die2(22);
    }
    this.atom_ = createAtom2(this.name_);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    if (initialData) {
      this.replace(initialData);
    }
  }
  var _proto = ObservableSet22.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear22() {
    var _this = this;
    transaction2(function() {
      untracked2(function() {
        for (var _iterator = _createForOfIteratorHelperLoose2(_this.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose2(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add(value) {
    var _this2 = this;
    checkIfStateModificationsAreAllowed2(this.atom_);
    if (hasInterceptors2(this)) {
      var change = interceptChange2(this, {
        type: ADD2,
        object: this,
        newValue: value
      });
      if (!change)
        return this;
    }
    if (!this.has(value)) {
      transaction2(function() {
        _this2.data_.add(_this2.enhancer_(value, void 0));
        _this2.atom_.reportChanged();
      });
      var notifySpy = isSpyEnabled2();
      var notify = hasListeners2(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD2,
        object: this,
        newValue: value
      } : null;
      if (notifySpy && true)
        spyReportStart(_change);
      if (notify)
        notifyListeners2(this, _change);
      if (notifySpy && true)
        spyReportEnd();
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this3 = this;
    if (hasInterceptors2(this)) {
      var change = interceptChange2(this, {
        type: DELETE2,
        object: this,
        oldValue: value
      });
      if (!change)
        return false;
    }
    if (this.has(value)) {
      var notifySpy = isSpyEnabled2();
      var notify = hasListeners2(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE2,
        object: this,
        oldValue: value
      } : null;
      if (notifySpy && true)
        spyReportStart(_change2);
      transaction2(function() {
        _this3.atom_.reportChanged();
        _this3.data_["delete"](value);
      });
      if (notify)
        notifyListeners2(this, _change2);
      if (notifySpy && true)
        spyReportEnd();
      return true;
    }
    return false;
  };
  _proto.has = function has22(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable2({
      next: function next() {
        var index2 = nextIndex;
        nextIndex += 1;
        return index2 < values.length ? {
          value: [keys[index2], values[index2]],
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.keys = function keys() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self2 = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable2({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self2.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.replace = function replace22(other) {
    var _this4 = this;
    if (isObservableSet2(other)) {
      other = new Set(other);
    }
    transaction2(function() {
      if (Array.isArray(other)) {
        _this4.clear();
        other.forEach(function(value) {
          return _this4.add(value);
        });
      } else if (isES6Set2(other)) {
        _this4.clear();
        other.forEach(function(value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die2("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === true)
      die2("`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener2(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor2(this, handler);
  };
  _proto.toJSON = function toJSON22() {
    return Array.from(this);
  };
  _proto.toString = function toString22() {
    return "[object ObservableSet]";
  };
  _proto[_Symbol$iterator$12] = function() {
    return this.values();
  };
  _createClass2(ObservableSet22, [{
    key: "size",
    get: function get32() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$12,
    get: function get32() {
      return "Set";
    }
  }]);
  return ObservableSet22;
}();
var isObservableSet2 = /* @__PURE__ */ createInstanceofPredicate2("ObservableSet", ObservableSet2);
var descriptorCache2 = /* @__PURE__ */ Object.create(null);
var REMOVE2 = "remove";
var ObservableObjectAdministration2 = /* @__PURE__ */ function() {
  function ObservableObjectAdministration22(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation2;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom2(true ? this.name_ + ".keys" : "ObservableObject.keys");
    this.isPlainObject_ = isPlainObject2(this.target_);
    if (!isAnnotation(this.defaultAnnotation_)) {
      die2("defaultAnnotation must be valid annotation");
    }
    if (true) {
      this.appliedAnnotations_ = {};
    }
  }
  var _proto = ObservableObjectAdministration22.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable22 = this.values_.get(key);
    if (observable22 instanceof ComputedValue2) {
      observable22.set(newValue);
      return true;
    }
    if (hasInterceptors2(this)) {
      var change = interceptChange2(this, {
        type: UPDATE2,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change)
        return null;
      newValue = change.newValue;
    }
    newValue = observable22.prepareNewValue_(newValue);
    if (newValue !== globalState2.UNCHANGED) {
      var notify = hasListeners2(this);
      var notifySpy = isSpyEnabled2();
      var _change = notify || notifySpy ? {
        type: UPDATE2,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable22.value_,
        name: key,
        newValue
      } : null;
      if (notifySpy)
        spyReportStart(_change);
      observable22.setNewValue_(newValue);
      if (notify)
        notifyListeners2(this, _change);
      if (notifySpy)
        spyReportEnd();
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState2.trackingDerivation && !hasProp2(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp2(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState2.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue2(key in this.target_, referenceEnhancer2, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    assertAnnotable2(this, annotation, key);
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol2]) == null ? void 0 : _this$target_$storedA[key]) {
        return;
      } else {
        die2(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype2) {
      var descriptor = getDescriptor2(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0)
          return;
        if (outcome === 1)
          break;
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied2(this, annotation, key);
  };
  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    assertAnnotable2(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied2(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch2();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors2(this)) {
        var change = interceptChange2(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD2,
          newValue: descriptor.value
        });
        if (!change)
          return null;
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends2({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty3(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch2();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch2();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors2(this)) {
        var change = interceptChange2(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD2,
          newValue: value
        });
        if (!change)
          return null;
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor2(key);
      var descriptor = {
        configurable: globalState2.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty3(this.target_, key, descriptor);
      }
      var observable22 = new ObservableValue2(value, enhancer, true ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable22);
      this.notifyPropertyAddition_(key, observable22.value_);
    } finally {
      endBatch2();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options2, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch2();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors2(this)) {
        var change = interceptChange2(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD2,
          newValue: void 0
        });
        if (!change)
          return null;
      }
      options2.name || (options2.name = true ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options2.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor2(key);
      var descriptor = {
        configurable: globalState2.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty3(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue2(options2));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch2();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (!hasProp2(this.target_, key)) {
      return true;
    }
    if (hasInterceptors2(this)) {
      var change = interceptChange2(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE2
      });
      if (!change)
        return null;
    }
    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;
      startBatch2();
      var notify = hasListeners2(this);
      var notifySpy = isSpyEnabled2();
      var observable22 = this.values_.get(key);
      var value = void 0;
      if (!observable22 && (notify || notifySpy)) {
        var _getDescriptor22;
        value = (_getDescriptor22 = getDescriptor2(this.target_, key)) == null ? void 0 : _getDescriptor22.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (true) {
        delete this.appliedAnnotations_[key];
      }
      if (observable22) {
        this.values_["delete"](key);
        if (observable22 instanceof ObservableValue2) {
          value = observable22.value_;
        }
        propagateChanged2(observable22);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE2,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (notifySpy)
          spyReportStart(_change2);
        if (notify)
          notifyListeners2(this, _change2);
        if (notifySpy)
          spyReportEnd();
      }
    } finally {
      endBatch2();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    if (fireImmediately === true)
      die2("`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener2(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor2(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;
    var notify = hasListeners2(this);
    var notifySpy = isSpyEnabled2();
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD2,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (notifySpy)
        spyReportStart(change);
      if (notify)
        notifyListeners2(this, change);
      if (notifySpy)
        spyReportEnd();
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys4(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration22;
}();
function asObservableObject2(target, options2) {
  var _options$name;
  if (options2 && isObservableObject2(target)) {
    die2("Options can't be provided for already observable objects.");
  }
  if (hasProp2(target, $mobx2)) {
    if (!(getAdministration2(target) instanceof ObservableObjectAdministration2)) {
      die2("Cannot convert '" + getDebugName2(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
    }
    return target;
  }
  if (!Object.isExtensible(target))
    die2("Cannot make the designated object observable; it is not extensible");
  var name = (_options$name = options2 == null ? void 0 : options2.name) != null ? _options$name : true ? (isPlainObject2(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
  var adm = new ObservableObjectAdministration2(target, new Map(), String(name), getAnnotationFromOptions2(options2));
  addHiddenProp2(target, $mobx2, adm);
  return target;
}
var isObservableObjectAdministration2 = /* @__PURE__ */ createInstanceofPredicate2("ObservableObjectAdministration", ObservableObjectAdministration2);
function getCachedObservablePropDescriptor2(key) {
  return descriptorCache2[key] || (descriptorCache2[key] = {
    get: function get32() {
      return this[$mobx2].getObservablePropValue_(key);
    },
    set: function set42(value) {
      return this[$mobx2].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject2(thing) {
  if (isObject2(thing)) {
    return isObservableObjectAdministration2(thing[$mobx2]);
  }
  return false;
}
function recordAnnotationApplied2(adm, annotation, key) {
  var _adm$target_$storedAn;
  if (true) {
    adm.appliedAnnotations_[key] = annotation;
  }
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol2]) == null ? true : delete _adm$target_$storedAn[key];
}
function assertAnnotable2(adm, annotation, key) {
  if (!isAnnotation(annotation)) {
    die2("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  if (!isOverride2(annotation) && hasProp2(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die2("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overriden by subclass.");
  }
}
var OBSERVABLE_ARRAY_BUFFER_SIZE2 = 0;
var StubArray3 = function StubArray22() {
};
function inherit2(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit2(StubArray3, Array.prototype);
var LegacyObservableArray2 = /* @__PURE__ */ function(_StubArray) {
  _inheritsLoose2(LegacyObservableArray22, _StubArray);
  function LegacyObservableArray22(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration2(name, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized2(_this);
    addHiddenFinalProp2(_assertThisInitialized2(_this), $mobx2, adm);
    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart2(true);
      _this.spliceWithArray(0, 0, initialValues);
      allowStateChangesEnd2(prev);
    }
    return _this;
  }
  var _proto = LegacyObservableArray22.prototype;
  _proto.concat = function concat() {
    this[$mobx2].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(this.slice(), arrays.map(function(a9) {
      return isObservableArray2(a9) ? a9.slice() : a9;
    }));
  };
  _proto[Symbol.iterator] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable2({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  _createClass2(LegacyObservableArray22, [{
    key: "length",
    get: function get32() {
      return this[$mobx2].getArrayLength_();
    },
    set: function set42(newLength) {
      this[$mobx2].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get32() {
      return "Array";
    }
  }]);
  return LegacyObservableArray22;
}(StubArray3);
Object.entries(arrayExtensions2).forEach(function(_ref) {
  var prop = _ref[0], fn = _ref[1];
  if (prop !== "concat")
    addHiddenProp2(LegacyObservableArray2.prototype, prop, fn);
});
function createArrayEntryDescriptor2(index2) {
  return {
    enumerable: false,
    configurable: true,
    get: function get32() {
      return this[$mobx2].get_(index2);
    },
    set: function set42(value) {
      this[$mobx2].set_(index2, value);
    }
  };
}
function createArrayBufferItem2(index2) {
  defineProperty3(LegacyObservableArray2.prototype, "" + index2, createArrayEntryDescriptor2(index2));
}
function reserveArrayBuffer2(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE2) {
    for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE2; index2 < max + 100; index2++) {
      createArrayBufferItem2(index2);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE2 = max;
  }
}
reserveArrayBuffer2(1e3);
function createLegacyArray2(initialValues, enhancer, name) {
  return new LegacyObservableArray2(initialValues, enhancer, name);
}
function getAtom2(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray2(thing)) {
      if (property !== void 0)
        die2(23);
      return thing[$mobx2].atom_;
    }
    if (isObservableSet2(thing)) {
      return thing[$mobx2];
    }
    if (isObservableMap2(thing)) {
      if (property === void 0)
        return thing.keysAtom_;
      var observable22 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable22)
        die2(25, property, getDebugName2(thing));
      return observable22;
    }
    if (isObservableObject2(thing)) {
      if (!property)
        return die2(26);
      var _observable = thing[$mobx2].values_.get(property);
      if (!_observable)
        die2(27, property, getDebugName2(thing));
      return _observable;
    }
    if (isAtom2(thing) || isComputedValue2(thing) || isReaction2(thing)) {
      return thing;
    }
  } else if (isFunction2(thing)) {
    if (isReaction2(thing[$mobx2])) {
      return thing[$mobx2];
    }
  }
  die2(28);
}
function getAdministration2(thing, property) {
  if (!thing)
    die2(29);
  if (property !== void 0)
    return getAdministration2(getAtom2(thing, property));
  if (isAtom2(thing) || isComputedValue2(thing) || isReaction2(thing))
    return thing;
  if (isObservableMap2(thing) || isObservableSet2(thing))
    return thing;
  if (thing[$mobx2])
    return thing[$mobx2];
  die2(24, thing);
}
function getDebugName2(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom2(thing, property);
  } else if (isAction2(thing)) {
    return thing.name;
  } else if (isObservableObject2(thing) || isObservableMap2(thing) || isObservableSet2(thing)) {
    named = getAdministration2(thing);
  } else {
    named = getAtom2(thing);
  }
  return named.name_;
}
var toString2 = objectPrototype2.toString;
function deepEqual2(a9, b7, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq2(a9, b7, depth);
}
function eq2(a9, b7, depth, aStack, bStack) {
  if (a9 === b7)
    return a9 !== 0 || 1 / a9 === 1 / b7;
  if (a9 == null || b7 == null)
    return false;
  if (a9 !== a9)
    return b7 !== b7;
  var type = typeof a9;
  if (!isFunction2(type) && type !== "object" && typeof b7 != "object")
    return false;
  var className = toString2.call(a9);
  if (className !== toString2.call(b7))
    return false;
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a9 === "" + b7;
    case "[object Number]":
      if (+a9 !== +a9)
        return +b7 !== +b7;
      return +a9 === 0 ? 1 / +a9 === 1 / b7 : +a9 === +b7;
    case "[object Date]":
    case "[object Boolean]":
      return +a9 === +b7;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a9) === Symbol.valueOf.call(b7);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a9 = unwrap2(a9);
  b7 = unwrap2(b7);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a9 != "object" || typeof b7 != "object")
      return false;
    var aCtor = a9.constructor, bCtor = b7.constructor;
    if (aCtor !== bCtor && !(isFunction2(aCtor) && aCtor instanceof aCtor && isFunction2(bCtor) && bCtor instanceof bCtor) && "constructor" in a9 && "constructor" in b7) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a9)
      return bStack[length] === b7;
  }
  aStack.push(a9);
  bStack.push(b7);
  if (areArrays) {
    length = a9.length;
    if (length !== b7.length)
      return false;
    while (length--) {
      if (!eq2(a9[length], b7[length], depth - 1, aStack, bStack))
        return false;
    }
  } else {
    var keys = Object.keys(a9);
    var key;
    length = keys.length;
    if (Object.keys(b7).length !== length)
      return false;
    while (length--) {
      key = keys[length];
      if (!(hasProp2(b7, key) && eq2(a9[key], b7[key], depth - 1, aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap2(a9) {
  if (isObservableArray2(a9))
    return a9.slice();
  if (isES6Map2(a9) || isObservableMap2(a9))
    return Array.from(a9.entries());
  if (isES6Set2(a9) || isObservableSet2(a9))
    return Array.from(a9.entries());
  return a9;
}
function makeIterable2(iterator) {
  iterator[Symbol.iterator] = getSelf2;
  return iterator;
}
function getSelf2() {
  return this;
}
function isAnnotation(thing) {
  return thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction2(thing.make_) && isFunction2(thing.extend_);
}
["Symbol", "Map", "Set"].forEach(function(m7) {
  var g5 = getGlobal2();
  if (typeof g5[m7] === "undefined") {
    die2("MobX requires global '" + m7 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: spy2,
    extras: {
      getDebugName: getDebugName2
    },
    $mobx: $mobx2
  });
}
function useCameraCss(layerRef, containerRef, pageState) {
  const rZoom = (0, import_react19.useRef)();
  const rPoint = (0, import_react19.useRef)();
  (0, import_react19.useLayoutEffect)(() => {
    return autorun2(() => {
      const { zoom, point } = pageState.camera;
      const didZoom = zoom !== rZoom.current;
      const didPan = point !== rPoint.current;
      rZoom.current = zoom;
      rPoint.current = point;
      if (didZoom || didPan) {
        const layer = layerRef.current;
        if (containerRef && "current" in containerRef) {
          const container = containerRef.current;
          if (didZoom) {
            if (container) {
              container.style.setProperty("--tl-zoom", zoom.toString());
            }
          }
          if (layer) {
            layer.style.setProperty("transform", `scale(${zoom}) translateX(${point[0]}px) translateY(${point[1]}px)`);
          }
        }
      }
    });
  }, [pageState]);
}
function canvasToScreen(point, camera) {
  return [(point[0] + camera.point[0]) * camera.zoom, (point[1] + camera.point[1]) * camera.zoom];
}
function getShapeUtils(shapeUtils2, shape) {
  return shapeUtils2[shape.type];
}
function useSelection(page, pageState, shapeUtils2) {
  const { rSelectionBounds } = useTLContext();
  const { selectedIds } = pageState;
  const rPrevBounds = (0, import_react20.useRef)();
  let bounds = void 0;
  let rotation = 0;
  let isLocked = false;
  let isLinked = false;
  if (selectedIds.length === 1) {
    const id = selectedIds[0];
    const shape = page.shapes[id];
    rotation = shape.rotation || 0;
    isLocked = shape.isLocked || false;
    const utils = getShapeUtils(shapeUtils2, shape);
    bounds = utils.hideBounds ? void 0 : utils.getBounds(shape);
  } else if (selectedIds.length > 1) {
    const selectedShapes = selectedIds.map((id) => page.shapes[id]);
    rotation = 0;
    isLocked = selectedShapes.every((shape) => shape.isLocked);
    bounds = selectedShapes.reduce((acc, shape, i8) => {
      if (i8 === 0) {
        return getShapeUtils(shapeUtils2, shape).getRotatedBounds(shape);
      }
      return utils_default.getExpandedBounds(acc, getShapeUtils(shapeUtils2, shape).getRotatedBounds(shape));
    }, {});
  }
  if (bounds) {
    const [minX, minY] = canvasToScreen([bounds.minX, bounds.minY], pageState.camera);
    const [maxX, maxY] = canvasToScreen([bounds.maxX, bounds.maxY], pageState.camera);
    isLinked = !!Object.values(page.bindings).find((binding) => selectedIds.includes(binding.toId) || selectedIds.includes(binding.fromId));
    rSelectionBounds.current = {
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  } else {
    rSelectionBounds.current = null;
  }
  const prevBounds = rPrevBounds.current;
  if (!prevBounds || !bounds) {
    rPrevBounds.current = bounds;
  } else if (bounds) {
    if (prevBounds.minX === bounds.minX && prevBounds.minY === bounds.minY && prevBounds.maxX === bounds.maxX && prevBounds.maxY === bounds.maxY) {
      bounds = rPrevBounds.current;
    }
  }
  return { bounds, rotation, isLocked, isLinked };
}
function useHandleEvents(id) {
  const { inputs: inputs2, callbacks } = useTLContext();
  const onPointerDown = (0, import_react21.useCallback)((e12) => {
    var _a2, _b, _c;
    if (e12.button !== 0)
      return;
    if (!inputs2.pointerIsValid(e12))
      return;
    e12.stopPropagation();
    (_a2 = e12.currentTarget) == null ? void 0 : _a2.setPointerCapture(e12.pointerId);
    const info = inputs2.pointerDown(e12, id);
    (_b = callbacks.onPointHandle) == null ? void 0 : _b.call(callbacks, info, e12);
    (_c = callbacks.onPointerDown) == null ? void 0 : _c.call(callbacks, info, e12);
  }, [inputs2, callbacks, id]);
  const onPointerUp = (0, import_react21.useCallback)((e12) => {
    var _a2, _b, _c, _d;
    if (e12.button !== 0)
      return;
    if (!inputs2.pointerIsValid(e12))
      return;
    e12.stopPropagation();
    const isDoubleClick = inputs2.isDoubleClick();
    const info = inputs2.pointerUp(e12, id);
    if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
      (_a2 = e12.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e12.pointerId);
      if (isDoubleClick && !(info.altKey || info.metaKey)) {
        (_b = callbacks.onDoubleClickHandle) == null ? void 0 : _b.call(callbacks, info, e12);
      }
      (_c = callbacks.onReleaseHandle) == null ? void 0 : _c.call(callbacks, info, e12);
    }
    (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e12);
  }, [inputs2, callbacks]);
  const onPointerMove = (0, import_react21.useCallback)((e12) => {
    var _a2, _b;
    if (!inputs2.pointerIsValid(e12))
      return;
    e12.stopPropagation();
    const info = inputs2.pointerMove(e12, id);
    if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
      (_a2 = callbacks.onDragHandle) == null ? void 0 : _a2.call(callbacks, info, e12);
    }
    (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e12);
  }, [inputs2, callbacks, id]);
  const onPointerEnter = (0, import_react21.useCallback)((e12) => {
    var _a2;
    if (!inputs2.pointerIsValid(e12))
      return;
    const info = inputs2.pointerEnter(e12, id);
    (_a2 = callbacks.onHoverHandle) == null ? void 0 : _a2.call(callbacks, info, e12);
  }, [inputs2, callbacks, id]);
  const onPointerLeave = (0, import_react21.useCallback)((e12) => {
    var _a2;
    if (!inputs2.pointerIsValid(e12))
      return;
    const info = inputs2.pointerEnter(e12, id);
    (_a2 = callbacks.onUnhoverHandle) == null ? void 0 : _a2.call(callbacks, info, e12);
  }, [inputs2, callbacks, id]);
  return {
    onPointerDown,
    onPointerUp,
    onPointerEnter,
    onPointerMove,
    onPointerLeave
  };
}
function usePreventNavigation(rCanvas) {
  const { bounds } = useTLContext();
  (0, import_react22.useEffect)(() => {
    const preventGestureNavigation = (event) => {
      event.preventDefault();
    };
    const preventNavigation = (event) => {
      const touchXPosition = event.touches[0].pageX;
      const touchXRadius = event.touches[0].radiusX || 0;
      if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > bounds.width - 10) {
        event.preventDefault();
      }
    };
    const elm = rCanvas.current;
    if (!elm)
      return () => void 0;
    elm.addEventListener("touchstart", preventGestureNavigation);
    elm.addEventListener("gestureend", preventGestureNavigation);
    elm.addEventListener("gesturechange", preventGestureNavigation);
    elm.addEventListener("gesturestart", preventGestureNavigation);
    elm.addEventListener("touchstart", preventNavigation);
    return () => {
      if (elm) {
        elm.removeEventListener("touchstart", preventGestureNavigation);
        elm.removeEventListener("gestureend", preventGestureNavigation);
        elm.removeEventListener("gesturechange", preventGestureNavigation);
        elm.removeEventListener("gesturestart", preventGestureNavigation);
        elm.removeEventListener("touchstart", preventNavigation);
      }
    };
  }, [rCanvas, bounds.width]);
}
function useBoundsEvents() {
  const { callbacks, inputs: inputs2 } = useTLContext();
  const onPointerDown = (0, import_react23.useCallback)((e12) => {
    var _a2, _b, _c, _d;
    if (!inputs2.pointerIsValid(e12))
      return;
    if (e12.button === 2) {
      (_a2 = callbacks.onRightPointBounds) == null ? void 0 : _a2.call(callbacks, inputs2.pointerDown(e12, "bounds"), e12);
      return;
    }
    if (e12.button !== 0)
      return;
    e12.stopPropagation();
    (_b = e12.currentTarget) == null ? void 0 : _b.setPointerCapture(e12.pointerId);
    const info = inputs2.pointerDown(e12, "bounds");
    (_c = callbacks.onPointBounds) == null ? void 0 : _c.call(callbacks, info, e12);
    (_d = callbacks.onPointerDown) == null ? void 0 : _d.call(callbacks, info, e12);
  }, [callbacks, inputs2]);
  const onPointerUp = (0, import_react23.useCallback)((e12) => {
    var _a2, _b, _c, _d;
    if (e12.button !== 0)
      return;
    inputs2.activePointer = void 0;
    if (!inputs2.pointerIsValid(e12))
      return;
    e12.stopPropagation();
    const isDoubleClick = inputs2.isDoubleClick();
    const info = inputs2.pointerUp(e12, "bounds");
    if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
      (_a2 = e12.currentTarget) == null ? void 0 : _a2.releasePointerCapture(e12.pointerId);
    }
    if (isDoubleClick && !(info.altKey || info.metaKey)) {
      (_b = callbacks.onDoubleClickBounds) == null ? void 0 : _b.call(callbacks, info, e12);
    }
    (_c = callbacks.onReleaseBounds) == null ? void 0 : _c.call(callbacks, info, e12);
    (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e12);
  }, [callbacks, inputs2]);
  const onPointerMove = (0, import_react23.useCallback)((e12) => {
    var _a2, _b;
    if (!inputs2.pointerIsValid(e12))
      return;
    if (e12.currentTarget.hasPointerCapture(e12.pointerId)) {
      (_a2 = callbacks.onDragBounds) == null ? void 0 : _a2.call(callbacks, inputs2.pointerMove(e12, "bounds"), e12);
    }
    const info = inputs2.pointerMove(e12, "bounds");
    (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e12);
  }, [callbacks, inputs2]);
  const onPointerEnter = (0, import_react23.useCallback)((e12) => {
    var _a2;
    if (!inputs2.pointerIsValid(e12))
      return;
    (_a2 = callbacks.onHoverBounds) == null ? void 0 : _a2.call(callbacks, inputs2.pointerEnter(e12, "bounds"), e12);
  }, [callbacks, inputs2]);
  const onPointerLeave = (0, import_react23.useCallback)((e12) => {
    var _a2;
    if (!inputs2.pointerIsValid(e12))
      return;
    (_a2 = callbacks.onUnhoverBounds) == null ? void 0 : _a2.call(callbacks, inputs2.pointerEnter(e12, "bounds"), e12);
  }, [callbacks, inputs2]);
  return {
    onPointerDown,
    onPointerUp,
    onPointerEnter,
    onPointerMove,
    onPointerLeave
  };
}
function usePosition(bounds, rotation = 0) {
  const rBounds = (0, import_react24.useRef)(null);
  (0, import_react24.useLayoutEffect)(() => {
    return autorun2(() => {
      const elm = rBounds.current;
      const transform = `
    translate(
      calc(${bounds.minX}px - var(--tl-padding)),
      calc(${bounds.minY}px - var(--tl-padding))
    )
    rotate(${rotation + (bounds.rotation || 0)}rad)`;
      elm.style.setProperty("transform", transform);
      elm.style.setProperty("width", `calc(${Math.floor(bounds.width)}px + (var(--tl-padding) * 2))`);
      elm.style.setProperty("height", `calc(${Math.floor(bounds.height)}px + (var(--tl-padding) * 2))`);
    });
  }, [bounds, rotation]);
  return rBounds;
}
function useKeyEvents() {
  const { inputs: inputs2, callbacks } = useTLContext();
  (0, import_react25.useEffect)(() => {
    const handleKeyDown = (e12) => {
      var _a2;
      (_a2 = callbacks.onKeyDown) == null ? void 0 : _a2.call(callbacks, e12.key, inputs2.keydown(e12), e12);
    };
    const handleKeyUp = (e12) => {
      var _a2;
      inputs2.keyup(e12);
      (_a2 = callbacks.onKeyUp) == null ? void 0 : _a2.call(callbacks, e12.key, inputs2.keyup(e12), e12);
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [inputs2, callbacks]);
}
var Container = observer(function Container2(_a2) {
  var _b = _a2, {
    id,
    bounds,
    rotation = 0,
    isGhost = false,
    children
  } = _b, props = __objRest2(_b, [
    "id",
    "bounds",
    "rotation",
    "isGhost",
    "children"
  ]);
  const rPositioned = usePosition(bounds, rotation);
  return /* @__PURE__ */ (0, import_react26.createElement)("div", __spreadValues3({
    id,
    ref: rPositioned,
    className: isGhost ? "tl-positioned tl-ghost" : "tl-positioned",
    "aria-label": "container",
    "data-testid": "container"
  }, props), children);
});
var Brush = observer(function Brush2({ brush }) {
  return /* @__PURE__ */ (0, import_react27.createElement)(Container, {
    bounds: brush,
    rotation: 0
  }, /* @__PURE__ */ (0, import_react27.createElement)(SVGContainer, null, /* @__PURE__ */ (0, import_react27.createElement)("rect", {
    className: "tl-brush",
    opacity: 1,
    x: 0,
    y: 0,
    width: brush.width,
    height: brush.height,
    "aria-label": "brush"
  })));
});
var CenterHandle = observer(function CenterHandle2({
  bounds,
  isLocked,
  isHidden
}) {
  return /* @__PURE__ */ (0, import_react30.createElement)("rect", {
    className: isLocked ? "tl-bounds-center tl-dashed" : "tl-bounds-center",
    x: -1,
    y: -1,
    width: bounds.width + 2,
    height: bounds.height + 2,
    opacity: isHidden ? 0 : 1,
    pointerEvents: "none",
    "aria-label": "center handle"
  });
});
var RotateHandle = observer(function RotateHandle2({
  bounds,
  targetSize,
  size,
  isHidden
}) {
  const events = useBoundsHandleEvents("rotate");
  return /* @__PURE__ */ (0, import_react31.createElement)("g", {
    cursor: "grab",
    opacity: isHidden ? 0 : 1
  }, /* @__PURE__ */ (0, import_react31.createElement)("circle", __spreadValues3({
    className: "tl-transparent",
    "aria-label": "rotate handle transparent",
    cx: bounds.width / 2,
    cy: size * -2,
    r: targetSize,
    pointerEvents: isHidden ? "none" : "all"
  }, events)), /* @__PURE__ */ (0, import_react31.createElement)("circle", {
    className: "tl-rotate-handle",
    "aria-label": "rotate handle",
    cx: bounds.width / 2,
    cy: size * -2,
    r: size / 2,
    pointerEvents: "none"
  }));
});
var cornerBgClassnames = {
  [TLBoundsCorner.TopLeft]: "tl-cursor-nwse",
  [TLBoundsCorner.TopRight]: "tl-cursor-nesw",
  [TLBoundsCorner.BottomRight]: "tl-cursor-nwse",
  [TLBoundsCorner.BottomLeft]: "tl-cursor-nesw"
};
var CornerHandle = observer(function CornerHandle2({
  size,
  targetSize,
  isHidden,
  corner,
  bounds
}) {
  const events = useBoundsHandleEvents(corner);
  const isTop = corner === TLBoundsCorner.TopLeft || corner === TLBoundsCorner.TopRight;
  const isLeft = corner === TLBoundsCorner.TopLeft || corner === TLBoundsCorner.BottomLeft;
  return /* @__PURE__ */ (0, import_react32.createElement)("g", {
    opacity: isHidden ? 0 : 1
  }, /* @__PURE__ */ (0, import_react32.createElement)("rect", __spreadValues3({
    className: "tl-transparent " + (isHidden ? "" : cornerBgClassnames[corner]),
    "aria-label": "corner transparent",
    x: (isLeft ? -1 : bounds.width + 1) - targetSize,
    y: (isTop ? -1 : bounds.height + 1) - targetSize,
    width: targetSize * 2,
    height: targetSize * 2,
    pointerEvents: isHidden ? "none" : "all"
  }, events)), /* @__PURE__ */ (0, import_react32.createElement)("rect", {
    className: "tl-corner-handle",
    "aria-label": "corner handle",
    x: (isLeft ? -1 : bounds.width + 1) - size / 2,
    y: (isTop ? -1 : bounds.height + 1) - size / 2,
    width: size,
    height: size,
    pointerEvents: "none"
  }));
});
function LinkHandle({ size, bounds, isHidden }) {
  const leftEvents = useBoundsHandleEvents("left");
  const centerEvents = useBoundsHandleEvents("center");
  const rightEvents = useBoundsHandleEvents("right");
  return /* @__PURE__ */ (0, import_react33.createElement)("g", {
    cursor: "grab",
    transform: `translate(${bounds.width / 2 - size * 4}, ${bounds.height + size * 2})`,
    "aria-label": "link handle"
  }, /* @__PURE__ */ (0, import_react33.createElement)("g", {
    className: "tl-transparent",
    pointerEvents: isHidden ? "none" : "all"
  }, /* @__PURE__ */ (0, import_react33.createElement)("rect", __spreadValues3({
    x: 0,
    y: 0,
    width: size * 2,
    height: size * 2
  }, leftEvents)), /* @__PURE__ */ (0, import_react33.createElement)("rect", __spreadValues3({
    x: size * 3,
    y: 0,
    width: size * 2,
    height: size * 2
  }, centerEvents)), /* @__PURE__ */ (0, import_react33.createElement)("rect", __spreadValues3({
    x: size * 6,
    y: 0,
    width: size * 2,
    height: size * 2
  }, rightEvents))), /* @__PURE__ */ (0, import_react33.createElement)("g", {
    className: "tl-rotate-handle",
    transform: `translate(${size / 2}, ${size / 2})`,
    "aria-label": "link rotate handle"
  }, /* @__PURE__ */ (0, import_react33.createElement)("path", {
    d: `M 0,${size / 2} L ${size},${size} ${size},0 Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  }), /* @__PURE__ */ (0, import_react33.createElement)("path", {
    transform: `translate(${size * 3}, 0)`,
    d: `M 0,0 L ${size},0 ${size / 2},${size} Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  }), /* @__PURE__ */ (0, import_react33.createElement)("path", {
    transform: `translate(${size * 6}, 0)`,
    d: `M ${size},${size / 2} L 0,0 0,${size} Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  })));
}
var edgeClassnames = {
  [TLBoundsEdge.Top]: "tl-cursor-ns",
  [TLBoundsEdge.Right]: "tl-cursor-ew",
  [TLBoundsEdge.Bottom]: "tl-cursor-ns",
  [TLBoundsEdge.Left]: "tl-cursor-ew"
};
var EdgeHandle = observer(function EdgeHandle2({
  size,
  isHidden,
  bounds,
  edge
}) {
  const events = useBoundsHandleEvents(edge);
  const isHorizontal = edge === TLBoundsEdge.Top || edge === TLBoundsEdge.Bottom;
  const isFarEdge = edge === TLBoundsEdge.Right || edge === TLBoundsEdge.Bottom;
  const { height, width } = bounds;
  return /* @__PURE__ */ (0, import_react34.createElement)("rect", __spreadValues3({
    pointerEvents: isHidden ? "none" : "all",
    className: "tl-transparent tl-edge-handle " + (isHidden ? "" : edgeClassnames[edge]),
    "aria-label": `${edge} handle`,
    opacity: isHidden ? 0 : 1,
    x: isHorizontal ? size / 2 : (isFarEdge ? width + 1 : -1) - size / 2,
    y: isHorizontal ? (isFarEdge ? height + 1 : -1) - size / 2 : size / 2,
    width: isHorizontal ? Math.max(0, width + 1 - size) : size,
    height: isHorizontal ? size : Math.max(0, height + 1 - size)
  }, events));
});
var ROTATIONS = {
  right: 0,
  bottomRight: 45,
  bottom: 90,
  bottomLeft: 135,
  left: 180,
  topLeft: 225,
  top: 270,
  topRight: 315
};
var CloneButton = observer(function CloneButton2({
  bounds,
  side,
  targetSize,
  size
}) {
  const x5 = {
    left: -44,
    topLeft: -44,
    bottomLeft: -44,
    right: bounds.width + 44,
    topRight: bounds.width + 44,
    bottomRight: bounds.width + 44,
    top: bounds.width / 2,
    bottom: bounds.width / 2
  }[side];
  const y4 = {
    left: bounds.height / 2,
    right: bounds.height / 2,
    top: -44,
    topLeft: -44,
    topRight: -44,
    bottom: bounds.height + 44,
    bottomLeft: bounds.height + 44,
    bottomRight: bounds.height + 44
  }[side];
  const { callbacks, inputs: inputs2 } = useTLContext();
  const handleClick = (0, import_react36.useCallback)((e12) => {
    var _a2;
    e12.stopPropagation();
    const info = inputs2.pointerDown(e12, side);
    (_a2 = callbacks.onShapeClone) == null ? void 0 : _a2.call(callbacks, info, e12);
  }, [callbacks.onShapeClone]);
  return /* @__PURE__ */ (0, import_react36.createElement)("g", {
    className: "tl-clone-target",
    transform: `translate(${x5}, ${y4})`,
    "aria-label": "clone button"
  }, /* @__PURE__ */ (0, import_react36.createElement)("rect", {
    className: "tl-transparent",
    width: targetSize * 4,
    height: targetSize * 4,
    x: -targetSize * 2,
    y: -targetSize * 2
  }), /* @__PURE__ */ (0, import_react36.createElement)("g", {
    className: "tl-clone-button-target",
    onPointerDown: handleClick,
    transform: `rotate(${ROTATIONS[side]})`
  }, /* @__PURE__ */ (0, import_react36.createElement)("circle", {
    className: "tl-transparent ",
    r: targetSize
  }), /* @__PURE__ */ (0, import_react36.createElement)("path", {
    className: "tl-clone-button",
    d: `M -${size / 2},-${size / 2} L ${size / 2},0 -${size / 2},${size / 2} Z`,
    strokeLinejoin: "round"
  })));
});
function CloneButtons({ targetSize, size, bounds }) {
  return /* @__PURE__ */ (0, import_react35.createElement)(import_react35.Fragment, null, /* @__PURE__ */ (0, import_react35.createElement)(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "top"
  }), /* @__PURE__ */ (0, import_react35.createElement)(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "right"
  }), /* @__PURE__ */ (0, import_react35.createElement)(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottom"
  }), /* @__PURE__ */ (0, import_react35.createElement)(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "left"
  }), /* @__PURE__ */ (0, import_react35.createElement)(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "topLeft"
  }), /* @__PURE__ */ (0, import_react35.createElement)(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "topRight"
  }), /* @__PURE__ */ (0, import_react35.createElement)(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottomLeft"
  }), /* @__PURE__ */ (0, import_react35.createElement)(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottomRight"
  }));
}
var SVGContainer = (0, import_react37.forwardRef)(function SVGContainer2(_a2, ref) {
  var _b = _a2, { id, className = "", children } = _b, rest = __objRest2(_b, ["id", "className", "children"]);
  return /* @__PURE__ */ (0, import_react37.createElement)(ObserverComponent, null, () => /* @__PURE__ */ (0, import_react37.createElement)("svg", __spreadValues3({
    ref,
    className: `tl-positioned-svg ${className}`
  }, rest), /* @__PURE__ */ (0, import_react37.createElement)("g", {
    id,
    className: "tl-centered-g"
  }, children)));
});
var Bounds = observer(function Bounds2({
  zoom,
  bounds,
  viewportWidth,
  rotation,
  isHidden,
  isLocked,
  hideCloneHandles,
  hideResizeHandles,
  hideRotateHandle,
  hideBindingHandles
}) {
  const targetSize = (viewportWidth < 768 ? 16 : 8) / zoom;
  const size = 8 / zoom;
  const smallDimension = Math.min(bounds.width, bounds.height) * zoom;
  const showRotateHandle = !hideRotateHandle && !isHidden && !isLocked && smallDimension > 32;
  const showEdgeHandles = !isHidden && !isLocked && smallDimension > 24;
  const showCornerHandles = !isHidden && !isLocked && smallDimension > 20;
  const showCloneHandles = !hideCloneHandles && smallDimension > 24;
  const showResizeHandles = !hideResizeHandles && !isLocked;
  return /* @__PURE__ */ (0, import_react29.createElement)(Container, {
    bounds,
    rotation
  }, /* @__PURE__ */ (0, import_react29.createElement)(SVGContainer, null, /* @__PURE__ */ (0, import_react29.createElement)(CenterHandle, {
    bounds,
    isLocked,
    isHidden
  }), showResizeHandles && /* @__PURE__ */ (0, import_react29.createElement)(import_react29.Fragment, null, /* @__PURE__ */ (0, import_react29.createElement)(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: TLBoundsEdge.Top,
    isHidden: !showEdgeHandles
  }), /* @__PURE__ */ (0, import_react29.createElement)(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: TLBoundsEdge.Right,
    isHidden: !showEdgeHandles
  }), /* @__PURE__ */ (0, import_react29.createElement)(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: TLBoundsEdge.Bottom,
    isHidden: !showEdgeHandles
  }), /* @__PURE__ */ (0, import_react29.createElement)(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: TLBoundsEdge.Left,
    isHidden: !showEdgeHandles
  }), /* @__PURE__ */ (0, import_react29.createElement)(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: TLBoundsCorner.TopLeft
  }), /* @__PURE__ */ (0, import_react29.createElement)(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: TLBoundsCorner.TopRight
  }), /* @__PURE__ */ (0, import_react29.createElement)(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: TLBoundsCorner.BottomRight
  }), /* @__PURE__ */ (0, import_react29.createElement)(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: TLBoundsCorner.BottomLeft
  })), showRotateHandle && /* @__PURE__ */ (0, import_react29.createElement)(RotateHandle, {
    targetSize,
    size,
    bounds,
    isHidden: !showEdgeHandles
  }), showCloneHandles && /* @__PURE__ */ (0, import_react29.createElement)(CloneButtons, {
    bounds,
    targetSize,
    size
  }), !hideBindingHandles && /* @__PURE__ */ (0, import_react29.createElement)(LinkHandle, {
    targetSize,
    size,
    bounds,
    isHidden: !showEdgeHandles
  })));
});
var BoundsBg = observer(function BoundsBg2({
  bounds,
  rotation,
  isHidden
}) {
  const events = useBoundsEvents();
  return /* @__PURE__ */ (0, import_react38.createElement)(Container, {
    bounds,
    rotation
  }, /* @__PURE__ */ (0, import_react38.createElement)(SVGContainer, null, /* @__PURE__ */ (0, import_react38.createElement)("rect", __spreadValues3({
    className: "tl-bounds-bg",
    "aria-label": "bounds bg",
    width: bounds.width,
    height: bounds.height,
    opacity: isHidden ? 0 : 1
  }, events))));
});
var Handle = observer(function Handle2({ id, point }) {
  const events = useHandleEvents(id);
  return /* @__PURE__ */ (0, import_react40.createElement)(Container, {
    bounds: utils_default.translateBounds({
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    }, point)
  }, /* @__PURE__ */ (0, import_react40.createElement)(SVGContainer, null, /* @__PURE__ */ (0, import_react40.createElement)("g", __spreadValues3({
    className: "tl-handle",
    "aria-label": "handle"
  }, events), /* @__PURE__ */ (0, import_react40.createElement)("circle", {
    className: "tl-handle-bg",
    pointerEvents: "all"
  }), /* @__PURE__ */ (0, import_react40.createElement)("circle", {
    className: "tl-counter-scaled tl-handle",
    pointerEvents: "none",
    r: 4
  }))));
});
var Handles = observer(function Handles2({
  shape,
  zoom
}) {
  if (shape.handles === void 0) {
    return null;
  }
  let prev = null;
  const handlesToShow = Object.values(shape.handles).reduce((acc, cur) => {
    const point = Vec.add(cur.point, shape.point);
    if (!prev || Vec.dist(point, prev) * zoom >= 32) {
      acc.push(cur);
      prev = point;
    }
    return acc;
  }, []);
  if (handlesToShow.length === 1)
    return null;
  return /* @__PURE__ */ (0, import_react39.createElement)(import_react39.Fragment, null, handlesToShow.map((handle) => /* @__PURE__ */ (0, import_react39.createElement)(Handle, {
    key: shape.id + "_" + handle.id,
    id: handle.id,
    point: Vec.add(handle.point, shape.point)
  })));
});
var _RenderedShape = observer(function RenderedShape(props) {
  const ref = props.utils.getRef(props.shape);
  return /* @__PURE__ */ (0, import_react43.createElement)(props.utils.Component, __spreadValues3({
    ref
  }, props));
});
var RenderedShape2 = (0, import_react43.memo)(_RenderedShape, (prev, next) => {
  if (prev.isHovered !== next.isHovered || prev.isSelected !== next.isSelected || prev.isEditing !== next.isEditing || prev.isBinding !== next.isBinding || prev.isGhost !== next.isGhost || prev.meta !== next.meta) {
    return false;
  }
  if (next.shape !== prev.shape) {
    return !next.utils.shouldRender(next.shape, prev.shape);
  }
  return true;
});
var Shape = observer(function Shape2(_a2) {
  var _b = _a2, {
    shape,
    utils,
    meta
  } = _b, rest = __objRest2(_b, [
    "shape",
    "utils",
    "meta"
  ]);
  const { callbacks } = useTLContext();
  const bounds = utils.getBounds(shape);
  const events = useShapeEvents(shape.id);
  return /* @__PURE__ */ (0, import_react42.createElement)(Container, {
    id: shape.id,
    bounds,
    rotation: shape.rotation,
    "data-shape": shape.type
  }, /* @__PURE__ */ (0, import_react42.createElement)(RenderedShape2, __spreadValues3({
    shape,
    utils,
    meta,
    events,
    onShapeChange: callbacks.onShapeChange,
    onShapeBlur: callbacks.onShapeBlur
  }, rest)));
});
var ShapeNode = observer(function ShapeNode2(_a2) {
  var _b = _a2, {
    shape,
    utils,
    meta,
    children
  } = _b, rest = __objRest2(_b, [
    "shape",
    "utils",
    "meta",
    "children"
  ]);
  return /* @__PURE__ */ (0, import_react41.createElement)(import_react41.Fragment, null, /* @__PURE__ */ (0, import_react41.createElement)(Shape, __spreadValues3({
    shape,
    utils: utils[shape.type],
    meta
  }, rest)), children && children.map((childNode) => /* @__PURE__ */ (0, import_react41.createElement)(ShapeNode2, __spreadValues3({
    key: childNode.shape.id,
    utils
  }, childNode))));
});
var ShapeIndicator = observer(function ShapeIndicator2({
  isHovered = false,
  isSelected = false,
  shape,
  user,
  meta
}) {
  const { shapeUtils: shapeUtils2 } = useTLContext();
  const utils = shapeUtils2[shape.type];
  const bounds = utils.getBounds(shape);
  const rPositioned = usePosition(bounds, shape.rotation);
  return /* @__PURE__ */ (0, import_react44.createElement)("div", {
    ref: rPositioned,
    className: "tl-indicator tl-absolute " + (user ? "" : isSelected ? "tl-selected" : "tl-hovered")
  }, /* @__PURE__ */ (0, import_react44.createElement)("svg", {
    width: "100%",
    height: "100%"
  }, /* @__PURE__ */ (0, import_react44.createElement)("g", {
    className: "tl-centered-g",
    stroke: user == null ? void 0 : user.color
  }, /* @__PURE__ */ (0, import_react44.createElement)(utils.Indicator, {
    shape,
    meta,
    user,
    isSelected,
    isHovered
  }))));
});
var Page = observer(function _Page({
  page,
  pageState,
  hideBounds,
  hideHandles,
  hideIndicators,
  hideBindingHandles,
  hideCloneHandles,
  hideRotateHandle,
  hideResizeHandles,
  meta
}) {
  const { bounds: rendererBounds, shapeUtils: shapeUtils2 } = useTLContext();
  const shapeTree = useShapeTree(page, pageState, meta);
  const { bounds, isLinked, isLocked, rotation } = useSelection(page, pageState, shapeUtils2);
  const {
    selectedIds,
    hoveredId,
    camera: { zoom }
  } = pageState;
  let _hideCloneHandles = true;
  let shapeWithHandles = void 0;
  const selectedShapes = selectedIds.map((id) => page.shapes[id]);
  if (selectedShapes.length === 1) {
    const shape = selectedShapes[0];
    const utils = shapeUtils2[shape.type];
    _hideCloneHandles = hideCloneHandles || !utils.showCloneHandles;
    if (shape.handles !== void 0) {
      shapeWithHandles = shape;
    }
  }
  return /* @__PURE__ */ (0, import_react28.createElement)(import_react28.Fragment, null, bounds && /* @__PURE__ */ (0, import_react28.createElement)(BoundsBg, {
    bounds,
    rotation,
    isHidden: hideBounds
  }), shapeTree.map((node) => /* @__PURE__ */ (0, import_react28.createElement)(ShapeNode, __spreadValues3({
    key: node.shape.id,
    utils: shapeUtils2
  }, node))), !hideIndicators && selectedShapes.map((shape) => /* @__PURE__ */ (0, import_react28.createElement)(ShapeIndicator, {
    key: "selected_" + shape.id,
    shape,
    meta,
    isSelected: true
  })), !hideIndicators && hoveredId && /* @__PURE__ */ (0, import_react28.createElement)(ShapeIndicator, {
    key: "hovered_" + hoveredId,
    shape: page.shapes[hoveredId],
    meta,
    isHovered: true
  }), bounds && /* @__PURE__ */ (0, import_react28.createElement)(Bounds, {
    zoom,
    bounds,
    viewportWidth: rendererBounds.width,
    isLocked,
    rotation,
    isHidden: hideBounds,
    hideRotateHandle,
    hideResizeHandles,
    hideBindingHandles: hideBindingHandles || !isLinked,
    hideCloneHandles: _hideCloneHandles
  }), !hideHandles && shapeWithHandles && /* @__PURE__ */ (0, import_react28.createElement)(Handles, {
    shape: shapeWithHandles,
    zoom
  }));
});
function User({ user }) {
  const rUser = (0, import_react46.useRef)(null);
  return /* @__PURE__ */ (0, import_react46.createElement)("div", {
    ref: rUser,
    className: "tl-absolute tl-user",
    style: {
      backgroundColor: user.color,
      transform: `translate(${user.point[0]}px, ${user.point[1]}px)`
    }
  });
}
function Users({ userId, users }) {
  return /* @__PURE__ */ (0, import_react45.createElement)(import_react45.Fragment, null, Object.values(users).filter((user) => user && user.id !== userId).map((user) => /* @__PURE__ */ (0, import_react45.createElement)(User, {
    key: user.id,
    user
  })));
}
function useResizeObserver(ref, onBoundsChange) {
  const { inputs: inputs2, callbacks } = useTLContext();
  const rIsMounted = (0, import_react47.useRef)(false);
  const updateBounds = (0, import_react47.useCallback)(() => {
    var _a2, _b;
    if (rIsMounted.current) {
      const rect = (_a2 = ref.current) == null ? void 0 : _a2.getBoundingClientRect();
      if (rect) {
        const bounds = {
          minX: rect.left,
          maxX: rect.left + rect.width,
          minY: rect.top,
          maxY: rect.top + rect.height,
          width: rect.width,
          height: rect.height
        };
        inputs2.bounds = bounds;
        onBoundsChange(bounds);
        (_b = callbacks.onBoundsChange) == null ? void 0 : _b.call(callbacks, bounds);
      }
    } else {
      rIsMounted.current = true;
    }
  }, [ref, inputs2, callbacks.onBoundsChange]);
  (0, import_react47.useEffect)(() => {
    const debouncedupdateBounds = Utils.debounce(updateBounds, 100);
    window.addEventListener("scroll", debouncedupdateBounds);
    window.addEventListener("resize", debouncedupdateBounds);
    return () => {
      window.removeEventListener("scroll", debouncedupdateBounds);
      window.removeEventListener("resize", debouncedupdateBounds);
    };
  }, []);
  (0, import_react47.useEffect)(() => {
    const resizeObserver = new ResizeObserver((entries) => {
      if (inputs2.isPinching) {
        return;
      }
      if (entries[0].contentRect) {
        updateBounds();
      }
    });
    if (ref.current) {
      resizeObserver.observe(ref.current);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }, [ref, inputs2]);
  (0, import_react47.useEffect)(() => {
    updateBounds();
  }, [ref]);
}
var DOUBLE_CLICK_DURATION = 250;
var Inputs = class {
  constructor() {
    __publicField(this, "pointer");
    __publicField(this, "keyboard");
    __publicField(this, "keys", {});
    __publicField(this, "isPinching", false);
    __publicField(this, "bounds", {
      minX: 0,
      maxX: 640,
      minY: 0,
      maxY: 480,
      width: 640,
      height: 480
    });
    __publicField(this, "zoom", 1);
    __publicField(this, "pointerUpTime", 0);
    __publicField(this, "activePointer");
    __publicField(this, "panStart", (e12) => {
      var _a2, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e12;
      const info = {
        target: "wheel",
        pointerId: ((_a2 = this.pointer) == null ? void 0 : _a2.pointerId) || 0,
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        delta: [0, 0],
        pressure: 0.5,
        point: Inputs.getPoint(e12, this.bounds),
        shiftKey,
        ctrlKey,
        metaKey,
        altKey,
        spaceKey: this.keys[" "]
      };
      this.pointer = info;
      return info;
    });
    __publicField(this, "pan", (delta, e12) => {
      if (!this.pointer || this.pointer.target !== "wheel") {
        return this.panStart(e12);
      }
      const { shiftKey, ctrlKey, metaKey, altKey } = e12;
      const prev = this.pointer;
      const point = Inputs.getPoint(e12, this.bounds);
      const info = __spreadProps3(__spreadValues3({}, prev), {
        target: "wheel",
        delta,
        point,
        shiftKey,
        ctrlKey,
        metaKey,
        altKey,
        spaceKey: this.keys[" "]
      });
      this.pointer = info;
      return info;
    });
    __publicField(this, "keydown", (e12) => {
      var _a2, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e12;
      this.keys[e12.key] = true;
      return {
        point: ((_a2 = this.pointer) == null ? void 0 : _a2.point) || [0, 0],
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        key: e12.key,
        keys: Object.keys(this.keys),
        shiftKey,
        ctrlKey,
        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
        altKey
      };
    });
    __publicField(this, "keyup", (e12) => {
      var _a2, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e12;
      delete this.keys[e12.key];
      return {
        point: ((_a2 = this.pointer) == null ? void 0 : _a2.point) || [0, 0],
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        key: e12.key,
        keys: Object.keys(this.keys),
        shiftKey,
        ctrlKey,
        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
        altKey
      };
    });
  }
  pointerIsValid(e12) {
    if ("pointerId" in e12) {
      if (this.activePointer && this.activePointer !== e12.pointerId) {
        return false;
      }
    }
    if ("touches" in e12) {
      const touch = e12.changedTouches[0];
      if (this.activePointer && this.activePointer !== touch.identifier) {
        return false;
      }
    }
    return true;
  }
  touchStart(e12, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e12;
    const touch = e12.changedTouches[0];
    this.activePointer = touch.identifier;
    const info = {
      target,
      pointerId: touch.identifier,
      origin: Inputs.getPoint(touch, this.bounds),
      delta: [0, 0],
      point: Inputs.getPoint(touch, this.bounds),
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  touchEnd(e12, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e12;
    const touch = e12.changedTouches[0];
    const info = {
      target,
      pointerId: touch.identifier,
      origin: Inputs.getPoint(touch, this.bounds),
      delta: [0, 0],
      point: Inputs.getPoint(touch, this.bounds),
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    this.activePointer = void 0;
    return info;
  }
  touchMove(e12, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e12;
    const touch = e12.changedTouches[0];
    const prev = this.pointer;
    const point = Inputs.getPoint(touch, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? Vec.sub(point, prev.point) : [0, 0];
    const info = __spreadProps3(__spreadValues3({
      origin: point
    }, prev), {
      target,
      pointerId: touch.identifier,
      point,
      delta,
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    return info;
  }
  pointerDown(e12, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e12;
    const point = Inputs.getPoint(e12, this.bounds);
    this.activePointer = e12.pointerId;
    const info = {
      target,
      pointerId: e12.pointerId,
      origin: point,
      point,
      delta: [0, 0],
      pressure: Inputs.getPressure(e12),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  pointerEnter(e12, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e12;
    const point = Inputs.getPoint(e12, this.bounds);
    const info = {
      target,
      pointerId: e12.pointerId,
      origin: point,
      delta: [0, 0],
      point,
      pressure: Inputs.getPressure(e12),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  pointerMove(e12, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e12;
    const prev = this.pointer;
    const point = Inputs.getPoint(e12, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? Vec.sub(point, prev.point) : [0, 0];
    const info = __spreadProps3(__spreadValues3({
      origin: point
    }, prev), {
      target,
      pointerId: e12.pointerId,
      point,
      delta,
      pressure: Inputs.getPressure(e12),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    return info;
  }
  pointerUp(e12, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e12;
    const prev = this.pointer;
    const point = Inputs.getPoint(e12, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? Vec.sub(point, prev.point) : [0, 0];
    this.activePointer = void 0;
    const info = __spreadProps3(__spreadValues3({
      origin: point
    }, prev), {
      target,
      pointerId: e12.pointerId,
      point,
      delta,
      pressure: Inputs.getPressure(e12),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    this.pointerUpTime = Date.now();
    return info;
  }
  isDoubleClick() {
    if (!this.pointer)
      return false;
    const { origin, point } = this.pointer;
    const isDoubleClick = Date.now() - this.pointerUpTime < DOUBLE_CLICK_DURATION && Vec.dist(origin, point) < 4;
    if (isDoubleClick)
      this.activePointer = void 0;
    return isDoubleClick;
  }
  clear() {
    this.pointer = void 0;
  }
  resetDoubleClick() {
    this.pointerUpTime = 0;
  }
  pinch(point, origin) {
    const { shiftKey, ctrlKey, metaKey, altKey } = this.keys;
    const delta = Vec.sub(origin, point);
    const info = {
      pointerId: 0,
      target: "pinch",
      origin,
      delta,
      point: Vec.sub(Vec.toFixed(point), [this.bounds.minX, this.bounds.minY]),
      pressure: 0.5,
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  reset() {
    this.pointerUpTime = 0;
    this.pointer = void 0;
    this.keyboard = void 0;
    this.activePointer = void 0;
    this.keys = {};
  }
  static getPoint(e12, bounds) {
    return [+e12.clientX.toFixed(2) - bounds.minX, +e12.clientY.toFixed(2) - bounds.minY];
  }
  static getPressure(e12) {
    return "pressure" in e12 ? +e12.pressure.toFixed(2) || 0.5 : 0.5;
  }
  static commandKey() {
    return Utils.isDarwin() ? "\u2318" : "Ctrl";
  }
};
var inputs = new Inputs();
function UsersIndicators({
  userId,
  users,
  meta,
  page
}) {
  const { shapeUtils: shapeUtils2 } = useTLContext();
  return /* @__PURE__ */ (0, import_react48.createElement)(import_react48.Fragment, null, Object.values(users).filter(Boolean).filter((user) => user.id !== userId && user.selectedIds.length > 0).map((user) => {
    const shapes = user.selectedIds.map((id) => page.shapes[id]).filter(Boolean);
    if (shapes.length === 0)
      return null;
    const bounds = utils_default.getCommonBounds(shapes.map((shape) => shapeUtils2[shape.type].getBounds(shape)));
    return /* @__PURE__ */ (0, import_react48.createElement)(import_react48.Fragment, {
      key: user.id + "_shapes"
    }, /* @__PURE__ */ (0, import_react48.createElement)("div", {
      className: "tl-absolute tl-user-indicator-bounds",
      style: {
        backgroundColor: user.color + "0d",
        borderColor: user.color + "78",
        transform: `translate(${bounds.minX}px, ${bounds.minY}px)`,
        width: bounds.width,
        height: bounds.height,
        pointerEvents: "none"
      }
    }), shapes.map((shape) => /* @__PURE__ */ (0, import_react48.createElement)(ShapeIndicator, {
      key: `${user.id}_${shape.id}_indicator`,
      shape,
      user,
      meta,
      isHovered: true
    })));
  }));
}
var SnapLines = observer(function SnapLines2({ snapLines }) {
  return /* @__PURE__ */ (0, import_react49.createElement)(import_react49.Fragment, null, snapLines.map((snapLine, i8) => /* @__PURE__ */ (0, import_react49.createElement)(SnapLine, {
    key: i8,
    snapLine
  })));
});
var SnapLine = observer(function SnapLine2({ snapLine }) {
  const bounds = utils_default.getBoundsFromPoints(snapLine);
  return /* @__PURE__ */ (0, import_react49.createElement)(import_react49.Fragment, null, /* @__PURE__ */ (0, import_react49.createElement)("line", {
    className: "tl-snap-line",
    x1: bounds.minX,
    y1: bounds.minY,
    x2: bounds.maxX,
    y2: bounds.maxY
  }), snapLine.map(([x5, y4], i8) => /* @__PURE__ */ (0, import_react49.createElement)("use", {
    key: i8,
    href: "#tl-snap-point",
    x: x5,
    y: y4
  })));
});
var STEPS = [
  [-1, 0.15, 64],
  [0.05, 0.375, 16],
  [0.15, 1, 4],
  [0.7, 2.5, 1]
];
function Grid({ grid, camera }) {
  return /* @__PURE__ */ (0, import_react50.createElement)("svg", {
    className: "tl-grid",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ (0, import_react50.createElement)("defs", null, STEPS.map(([min, mid, size], i8) => {
    const s8 = size * grid * camera.zoom;
    const xo = camera.point[0] * camera.zoom;
    const yo = camera.point[1] * camera.zoom;
    const gxo = xo > 0 ? xo % s8 : s8 + xo % s8;
    const gyo = yo > 0 ? yo % s8 : s8 + yo % s8;
    const opacity = camera.zoom < mid ? utils_default.modulate(camera.zoom, [min, mid], [0, 1]) : 1;
    return /* @__PURE__ */ (0, import_react50.createElement)("pattern", {
      key: `grid-pattern-${i8}`,
      id: `grid-${i8}`,
      width: s8,
      height: s8,
      patternUnits: "userSpaceOnUse"
    }, /* @__PURE__ */ (0, import_react50.createElement)("circle", {
      className: `tl-grid-dot`,
      cx: gxo,
      cy: gyo,
      r: 1,
      opacity
    }));
  })), STEPS.map((_142, i8) => /* @__PURE__ */ (0, import_react50.createElement)("rect", {
    key: `grid-rect-${i8}`,
    width: "100%",
    height: "100%",
    fill: `url(#grid-${i8})`
  })));
}
var Overlay = observer(function Overlay2({ camera: { zoom, point }, children }) {
  const l9 = 2.5 / zoom;
  return /* @__PURE__ */ (0, import_react51.createElement)("svg", {
    className: "tl-overlay"
  }, /* @__PURE__ */ (0, import_react51.createElement)("defs", null, /* @__PURE__ */ (0, import_react51.createElement)("g", {
    id: "tl-snap-point"
  }, /* @__PURE__ */ (0, import_react51.createElement)("path", {
    className: "tl-snap-point",
    d: `M ${-l9},${-l9} L ${l9},${l9} M ${-l9},${l9} L ${l9},${-l9}`
  }))), /* @__PURE__ */ (0, import_react51.createElement)("g", {
    transform: `scale(${zoom}) translate(${point})`
  }, children));
});
var Canvas = observer(function _Canvas({
  id,
  page,
  pageState,
  snapLines,
  grid,
  users,
  userId,
  meta,
  externalContainerRef,
  hideHandles,
  hideBounds,
  hideIndicators,
  hideBindingHandles,
  hideCloneHandles,
  hideResizeHandles,
  hideRotateHandle,
  hideGrid,
  onBoundsChange
}) {
  const rCanvas = (0, import_react9.useRef)(null);
  const rContainer = (0, import_react9.useRef)(null);
  const rLayer = (0, import_react9.useRef)(null);
  inputs.zoom = pageState.camera.zoom;
  useResizeObserver(rCanvas, onBoundsChange);
  useZoomEvents(pageState.camera.zoom, externalContainerRef || rCanvas);
  useSafariFocusOutFix();
  usePreventNavigation(rCanvas);
  useCameraCss(rLayer, rContainer, pageState);
  useKeyEvents();
  const events = useCanvasEvents();
  return /* @__PURE__ */ (0, import_react9.createElement)("div", {
    id,
    className: "tl-container",
    ref: rContainer
  }, /* @__PURE__ */ (0, import_react9.createElement)("div", __spreadValues3({
    id: "canvas",
    className: "tl-absolute tl-canvas",
    ref: rCanvas
  }, events), !hideGrid && grid && /* @__PURE__ */ (0, import_react9.createElement)(Grid, {
    grid,
    camera: pageState.camera
  }), /* @__PURE__ */ (0, import_react9.createElement)("div", {
    ref: rLayer,
    className: "tl-absolute tl-layer",
    "data-testid": "layer"
  }, /* @__PURE__ */ (0, import_react9.createElement)(Page, {
    page,
    pageState,
    hideBounds,
    hideIndicators,
    hideHandles,
    hideBindingHandles,
    hideCloneHandles,
    hideResizeHandles,
    hideRotateHandle,
    meta
  }), users && userId && /* @__PURE__ */ (0, import_react9.createElement)(UsersIndicators, {
    userId,
    users,
    page,
    meta
  }), pageState.brush && /* @__PURE__ */ (0, import_react9.createElement)(Brush, {
    brush: pageState.brush
  }), users && /* @__PURE__ */ (0, import_react9.createElement)(Users, {
    userId,
    users
  })), /* @__PURE__ */ (0, import_react9.createElement)(Overlay, {
    camera: pageState.camera
  }, snapLines && /* @__PURE__ */ (0, import_react9.createElement)(SnapLines, {
    snapLines
  }))));
});
var Renderer = observer(function _Renderer(_a2) {
  var _b = _a2, {
    id = "tl",
    shapeUtils: shapeUtils2,
    page,
    pageState,
    users,
    userId,
    theme,
    meta,
    snapLines,
    grid,
    containerRef,
    hideHandles = false,
    hideIndicators = false,
    hideCloneHandles = false,
    hideBindingHandles = false,
    hideResizeHandles = false,
    hideRotateHandles = false,
    hideBounds = false,
    hideGrid = true
  } = _b, rest = __objRest2(_b, [
    "id",
    "shapeUtils",
    "page",
    "pageState",
    "users",
    "userId",
    "theme",
    "meta",
    "snapLines",
    "grid",
    "containerRef",
    "hideHandles",
    "hideIndicators",
    "hideCloneHandles",
    "hideBindingHandles",
    "hideResizeHandles",
    "hideRotateHandles",
    "hideBounds",
    "hideGrid"
  ]);
  useTLTheme(theme, "#" + id);
  const rSelectionBounds = (0, import_react8.useRef)(null);
  const rPageState = (0, import_react8.useRef)(pageState);
  (0, import_react8.useEffect)(() => {
    rPageState.current = pageState;
  }, [pageState]);
  const [context2, setContext] = (0, import_react8.useState)(() => ({
    callbacks: rest,
    shapeUtils: shapeUtils2,
    rSelectionBounds,
    rPageState,
    bounds: {
      minX: 0,
      minY: 0,
      maxX: Infinity,
      maxY: Infinity,
      width: Infinity,
      height: Infinity
    },
    inputs: new Inputs()
  }));
  const onBoundsChange = (0, import_react8.useCallback)((bounds) => {
    setContext((context22) => __spreadProps3(__spreadValues3({}, context22), {
      bounds
    }));
  }, []);
  return /* @__PURE__ */ (0, import_react8.createElement)(TLContext.Provider, {
    value: context2
  }, /* @__PURE__ */ (0, import_react8.createElement)(Canvas, {
    id,
    page,
    pageState,
    snapLines,
    grid,
    users,
    userId,
    externalContainerRef: containerRef,
    hideBounds,
    hideIndicators,
    hideHandles,
    hideCloneHandles,
    hideBindingHandles,
    hideRotateHandle: hideRotateHandles,
    hideResizeHandles,
    hideGrid,
    onBoundsChange,
    meta
  }));
});
var HTMLContainer = (0, import_react52.forwardRef)(function HTMLContainer2(_a2, ref) {
  var _b = _a2, { children, className = "" } = _b, rest = __objRest2(_b, ["children", "className"]);
  return /* @__PURE__ */ (0, import_react52.createElement)(ObserverComponent, null, () => /* @__PURE__ */ (0, import_react52.createElement)("div", __spreadValues3({
    ref,
    className: `tl-positioned-div ${className}`
  }, rest), children));
});
var TLShapeUtil = class {
  constructor() {
    __publicField(this, "refMap", new Map());
    __publicField(this, "boundsCache", new WeakMap());
    __publicField(this, "showCloneHandles", false);
    __publicField(this, "hideBounds", false);
    __publicField(this, "isStateful", false);
    __publicField(this, "shouldRender", (prev, next) => true);
    __publicField(this, "getRef", (shape) => {
      if (!this.refMap.has(shape.id)) {
        this.refMap.set(shape.id, (0, import_react53.createRef)());
      }
      return this.refMap.get(shape.id);
    });
    __publicField(this, "hitTestBounds", (shape, bounds) => {
      const shapeBounds = this.getBounds(shape);
      const corners = utils_default.getRotatedCorners(shapeBounds, shape.rotation);
      return corners.every((point) => utils_default.pointInBounds(point, bounds)) || intersectPolylineBounds(corners, bounds).length > 0;
    });
    __publicField(this, "getRotatedBounds", (shape) => {
      return utils_default.getBoundsFromPoints(utils_default.getRotatedCorners(this.getBounds(shape), shape.rotation));
    });
  }
};
__publicField(TLShapeUtil, "Component", (component) => {
  return (0, import_react53.forwardRef)(component);
});
__publicField(TLShapeUtil, "Indicator", (component) => component);

// ../../node_modules/@stitches/react/dist/index.mjs
var import_react54 = __toModule(require_react());
var e = "colors";
var t = "sizes";
var r = "space";
var n = { gap: r, gridGap: r, columnGap: r, gridColumnGap: r, rowGap: r, gridRowGap: r, inset: r, insetBlock: r, insetBlockEnd: r, insetBlockStart: r, insetInline: r, insetInlineEnd: r, insetInlineStart: r, margin: r, marginTop: r, marginRight: r, marginBottom: r, marginLeft: r, marginBlock: r, marginBlockEnd: r, marginBlockStart: r, marginInline: r, marginInlineEnd: r, marginInlineStart: r, padding: r, paddingTop: r, paddingRight: r, paddingBottom: r, paddingLeft: r, paddingBlock: r, paddingBlockEnd: r, paddingBlockStart: r, paddingInline: r, paddingInlineEnd: r, paddingInlineStart: r, top: r, right: r, bottom: r, left: r, scrollMargin: r, scrollMarginTop: r, scrollMarginRight: r, scrollMarginBottom: r, scrollMarginLeft: r, scrollMarginX: r, scrollMarginY: r, scrollMarginBlock: r, scrollMarginBlockEnd: r, scrollMarginBlockStart: r, scrollMarginInline: r, scrollMarginInlineEnd: r, scrollMarginInlineStart: r, scrollPadding: r, scrollPaddingTop: r, scrollPaddingRight: r, scrollPaddingBottom: r, scrollPaddingLeft: r, scrollPaddingX: r, scrollPaddingY: r, scrollPaddingBlock: r, scrollPaddingBlockEnd: r, scrollPaddingBlockStart: r, scrollPaddingInline: r, scrollPaddingInlineEnd: r, scrollPaddingInlineStart: r, fontSize: "fontSizes", background: e, backgroundColor: e, backgroundImage: e, borderImage: e, border: e, borderBlock: e, borderBlockEnd: e, borderBlockStart: e, borderBottom: e, borderBottomColor: e, borderColor: e, borderInline: e, borderInlineEnd: e, borderInlineStart: e, borderLeft: e, borderLeftColor: e, borderRight: e, borderRightColor: e, borderTop: e, borderTopColor: e, caretColor: e, color: e, columnRuleColor: e, fill: e, outline: e, outlineColor: e, stroke: e, textDecorationColor: e, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: t, minBlockSize: t, maxBlockSize: t, inlineSize: t, minInlineSize: t, maxInlineSize: t, width: t, minWidth: t, maxWidth: t, height: t, minHeight: t, maxHeight: t, flexBasis: t, gridTemplateColumns: t, gridTemplateRows: t, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" };
var i = (e12, t14) => typeof t14 == "function" ? { "()": Function.prototype.toString.call(t14) } : t14;
var o = () => {
  const e12 = Object.create(null);
  return (t14, r13, ...n6) => {
    const o13 = ((e13) => JSON.stringify(e13, i))(t14);
    return o13 in e12 ? e12[o13] : e12[o13] = r13(t14, ...n6);
  };
};
var l = Symbol.for("sxs.internal");
var s = (e12, t14) => Object.defineProperties(e12, Object.getOwnPropertyDescriptors(t14));
var a = (e12) => {
  for (const t14 in e12)
    return true;
  return false;
};
var { hasOwnProperty: c } = Object.prototype;
var d = (e12) => e12.includes("-") ? e12 : e12.replace(/[A-Z]/g, (e13) => "-" + e13.toLowerCase());
var g = /\s+(?![^()]*\))/;
var p = (e12) => (t14) => e12(...typeof t14 == "string" ? String(t14).split(g) : [t14]);
var u = { appearance: (e12) => ({ WebkitAppearance: e12, appearance: e12 }), backfaceVisibility: (e12) => ({ WebkitBackfaceVisibility: e12, backfaceVisibility: e12 }), backdropFilter: (e12) => ({ WebkitBackdropFilter: e12, backdropFilter: e12 }), backgroundClip: (e12) => ({ WebkitBackgroundClip: e12, backgroundClip: e12 }), boxDecorationBreak: (e12) => ({ WebkitBoxDecorationBreak: e12, boxDecorationBreak: e12 }), clipPath: (e12) => ({ WebkitClipPath: e12, clipPath: e12 }), content: (e12) => ({ content: e12.includes('"') || e12.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e12) ? e12 : `"${e12}"` }), hyphens: (e12) => ({ WebkitHyphens: e12, hyphens: e12 }), maskImage: (e12) => ({ WebkitMaskImage: e12, maskImage: e12 }), maskSize: (e12) => ({ WebkitMaskSize: e12, maskSize: e12 }), tabSize: (e12) => ({ MozTabSize: e12, tabSize: e12 }), textSizeAdjust: (e12) => ({ WebkitTextSizeAdjust: e12, textSizeAdjust: e12 }), userSelect: (e12) => ({ WebkitUserSelect: e12, userSelect: e12 }), marginBlock: p((e12, t14) => ({ marginBlockStart: e12, marginBlockEnd: t14 || e12 })), marginInline: p((e12, t14) => ({ marginInlineStart: e12, marginInlineEnd: t14 || e12 })), maxSize: p((e12, t14) => ({ maxBlockSize: e12, maxInlineSize: t14 || e12 })), minSize: p((e12, t14) => ({ minBlockSize: e12, minInlineSize: t14 || e12 })), paddingBlock: p((e12, t14) => ({ paddingBlockStart: e12, paddingBlockEnd: t14 || e12 })), paddingInline: p((e12, t14) => ({ paddingInlineStart: e12, paddingInlineEnd: t14 || e12 })) };
var h = /([\d.]+)([^]*)/;
var f = (e12, t14) => e12.length ? e12.reduce((e13, r13) => (e13.push(...t14.map((e14) => e14.includes("&") ? e14.replace(/&/g, /[ +>|~]/.test(r13) && /&.*&/.test(e14) ? `:is(${r13})` : r13) : r13 + " " + e14)), e13), []) : t14;
var m = (e12, t14) => e12 in b && typeof t14 == "string" ? t14.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t15, r13, n6, i8) => r13 + (n6 === "stretch" ? `-moz-available${i8};${d(e12)}:${r13}-webkit-fill-available` : `-moz-fit-content${i8};${d(e12)}:${r13}fit-content`) + i8) : String(t14);
var b = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };
var S = (e12) => e12 ? e12 + "-" : "";
var k = (e12, t14, r13) => e12.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e13, n6, i8, o13, l9) => o13 == "$" == !!i8 ? e13 : (n6 || o13 == "--" ? "calc(" : "") + "var(--" + (o13 === "$" ? S(t14) + (l9.includes("$") ? "" : S(r13)) + l9.replace(/\$/g, "-") : l9) + ")" + (n6 || o13 == "--" ? "*" + (n6 || "") + (i8 || "1") + ")" : ""));
var y = /\s*,\s*(?![^()]*\))/;
var B = Object.prototype.toString;
var $ = (e12, t14, r13, n6, i8) => {
  let o13, l9, s8;
  const a9 = (e13, t15, r14) => {
    let c7, g5;
    const p7 = (e14) => {
      for (c7 in e14) {
        const R5 = c7.charCodeAt(0) === 64, z3 = R5 && Array.isArray(e14[c7]) ? e14[c7] : [e14[c7]];
        for (g5 of z3) {
          const e15 = /[A-Z]/.test($2 = c7) ? $2 : $2.replace(/-[^]/g, (e16) => e16[1].toUpperCase()), z4 = typeof g5 == "object" && g5 && g5.toString === B && (!n6.utils[e15] || !t15.length);
          if (e15 in n6.utils && !z4) {
            const t16 = n6.utils[e15];
            if (t16 !== l9) {
              l9 = t16, p7(t16(g5)), l9 = null;
              continue;
            }
          } else if (e15 in u) {
            const t16 = u[e15];
            if (t16 !== s8) {
              s8 = t16, p7(t16(g5)), s8 = null;
              continue;
            }
          }
          if (R5 && (b7 = c7.slice(1) in n6.media ? "@media " + n6.media[c7.slice(1)] : c7, c7 = b7.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e16, t16, r15, n7, i9, o14) => {
            const l10 = h.test(t16), s9 = 0.0625 * (l10 ? -1 : 1), [a10, c8] = l10 ? [n7, t16] : [t16, n7];
            return "(" + (r15[0] === "=" ? "" : r15[0] === ">" === l10 ? "max-" : "min-") + a10 + ":" + (r15[0] !== "=" && r15.length === 1 ? c8.replace(h, (e17, t17, n8) => Number(t17) + s9 * (r15 === ">" ? 1 : -1) + n8) : c8) + (i9 ? ") and (" + (i9[0] === ">" ? "min-" : "max-") + a10 + ":" + (i9.length === 1 ? o14.replace(h, (e17, t17, r16) => Number(t17) + s9 * (i9 === ">" ? -1 : 1) + r16) : o14) : "") + ")";
          })), z4) {
            const e16 = R5 ? r14.concat(c7) : [...r14], n7 = R5 ? [...t15] : f(t15, c7.split(y));
            o13 !== void 0 && i8(x(...o13)), o13 = void 0, a9(g5, n7, e16);
          } else
            o13 === void 0 && (o13 = [[], t15, r14]), c7 = R5 || c7.charCodeAt(0) !== 36 ? c7 : `--${S(n6.prefix)}${c7.slice(1).replace(/\$/g, "-")}`, g5 = z4 ? g5 : typeof g5 == "number" ? g5 && e15 in I ? String(g5) + "px" : String(g5) : k(m(e15, g5 == null ? "" : g5), n6.prefix, n6.themeMap[e15]), o13[0].push(`${R5 ? `${c7} ` : `${d(c7)}:`}${g5}`);
        }
      }
      var b7, $2;
    };
    p7(e13), o13 !== void 0 && i8(x(...o13)), o13 = void 0;
  };
  a9(e12, t14, r13);
};
var x = (e12, t14, r13) => `${r13.map((e13) => `${e13}{`).join("")}${t14.length ? `${t14.join(",")}{` : ""}${e12.join(";")}${t14.length ? "}" : ""}${Array(r13.length ? r13.length + 1 : 0).join("}")}`;
var I = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };
var R = (e12) => String.fromCharCode(e12 + (e12 > 25 ? 39 : 97));
var z = (e12) => ((e13) => {
  let t14, r13 = "";
  for (t14 = Math.abs(e13); t14 > 52; t14 = t14 / 52 | 0)
    r13 = R(t14 % 52) + r13;
  return R(t14 % 52) + r13;
})(((e13, t14) => {
  let r13 = t14.length;
  for (; r13; )
    e13 = 33 * e13 ^ t14.charCodeAt(--r13);
  return e13;
})(5381, JSON.stringify(e12)) >>> 0);
var W = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"];
var j = (e12) => {
  if (e12.href && !e12.href.startsWith(location.origin))
    return false;
  try {
    return e12.cssRules, true;
  } catch (e13) {
    return false;
  }
};
var E = (e12) => {
  let t14;
  const r13 = () => {
    if (t14) {
      const { rules: e13, sheet: r14 } = t14;
      if (!r14.deleteRule) {
        for (; Object(Object(r14.cssRules)[0]).type === 3; )
          r14.cssRules.splice(0, 1);
        r14.cssRules = [];
      }
      for (const t15 in e13)
        delete e13[t15];
    }
    const n6 = Object(e12).styleSheets || [];
    for (const e13 of n6)
      if (j(e13)) {
        for (let n7 = 0, i9 = e13.cssRules; i9[n7]; ++n7) {
          const o14 = Object(i9[n7]);
          if (o14.type !== 1)
            continue;
          const l9 = Object(i9[n7 + 1]);
          if (l9.type !== 4)
            continue;
          ++n7;
          const { cssText: s8 } = o14;
          if (!s8.startsWith("--sxs"))
            continue;
          const a9 = s8.slice(14, -3).trim().split(/\s+/), c7 = W[a9[0]];
          c7 && (t14 || (t14 = { sheet: e13, reset: r13, rules: {} }), t14.rules[c7] = { group: l9, index: n7, cache: new Set(a9) });
        }
        if (t14)
          break;
      }
    if (!t14) {
      const n7 = (e13, t15) => ({ type: t15, cssRules: [], insertRule(e14, t16) {
        this.cssRules.splice(t16, 0, n7(e14, { import: 3, undefined: 1 }[(e14.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return e13 === "@media{}" ? `@media{${[].map.call(this.cssRules, (e14) => e14.cssText).join("")}}` : e13;
      } });
      t14 = { sheet: e12 ? (e12.head || e12).appendChild(document.createElement("style")).sheet : n7("", "text/css"), rules: {}, reset: r13, toString() {
        const { cssRules: e13 } = t14.sheet;
        return [].map.call(e13, (r14, n8) => {
          const { cssText: i9 } = r14;
          let o14 = "";
          if (i9.startsWith("--sxs"))
            return "";
          if (e13[n8 - 1] && (o14 = e13[n8 - 1].cssText).startsWith("--sxs")) {
            if (!r14.cssRules.length)
              return "";
            for (const e14 in t14.rules)
              if (t14.rules[e14].group === r14)
                return `--sxs{--sxs:${[...t14.rules[e14].cache].join(" ")}}${i9}`;
            return r14.cssRules.length ? `${o14}${i9}` : "";
          }
          return i9;
        }).join("");
      } };
    }
    const { sheet: i8, rules: o13 } = t14;
    for (let e13 = W.length - 1; e13 >= 0; --e13) {
      const t15 = W[e13];
      if (!o13[t15]) {
        const r14 = W[e13 + 1], n7 = o13[r14] ? o13[r14].index : i8.cssRules.length;
        i8.insertRule("@media{}", n7), i8.insertRule(`--sxs{--sxs:${e13}}`, n7), o13[t15] = { group: i8.cssRules[n7 + 1], index: n7, cache: new Set([e13]) };
      }
      v(o13[t15]);
    }
  };
  return r13(), t14;
};
var v = (e12) => {
  const t14 = e12.group;
  let r13 = t14.cssRules.length;
  e12.apply = (e13) => {
    try {
      t14.insertRule(e13, r13), ++r13;
    } catch (e14) {
    }
  };
};
var T = Symbol();
var w = o();
var M = (e12, t14) => w(e12, () => (...r13) => {
  let n6 = { type: null, composers: new Set() };
  for (const t15 of r13)
    if (t15 != null)
      if (t15[l]) {
        n6.type == null && (n6.type = t15[l].type);
        for (const e13 of t15[l].composers)
          n6.composers.add(e13);
      } else
        t15.constructor !== Object || t15.$$typeof ? n6.type == null && (n6.type = t15) : n6.composers.add(C(t15, e12));
  return n6.type == null && (n6.type = "span"), n6.composers.size || n6.composers.add(["PJLV", {}, [], [], {}, []]), P(e12, n6, t14);
});
var C = (_a2, i8) => {
  var _b = _a2, { variants: e12, compoundVariants: t14, defaultVariants: r13 } = _b, n6 = __objRest(_b, ["variants", "compoundVariants", "defaultVariants"]);
  const o13 = `${S(i8.prefix)}c-${z(n6)}`, l9 = [], s8 = [], d8 = Object.create(null), g5 = [];
  for (const e13 in r13)
    d8[e13] = String(r13[e13]);
  if (typeof e12 == "object" && e12)
    for (const t15 in e12) {
      p7 = d8, u4 = t15, c.call(p7, u4) || (d8[t15] = "undefined");
      const r14 = e12[t15];
      for (const e13 in r14) {
        const n7 = { [t15]: String(e13) };
        String(e13) === "undefined" && g5.push(t15);
        const i9 = r14[e13], o14 = [n7, i9, !a(i9)];
        l9.push(o14);
      }
    }
  var p7, u4;
  if (typeof t14 == "object" && t14)
    for (const e13 of t14) {
      let _a3 = e13, { css: t15 } = _a3, r14 = __objRest(_a3, ["css"]);
      t15 = typeof t15 == "object" && t15 || {};
      for (const e14 in r14)
        r14[e14] = String(r14[e14]);
      const n7 = [r14, t15, !a(t15)];
      s8.push(n7);
    }
  return [o13, n6, l9, s8, d8, g5];
};
var P = (e12, t14, r13) => {
  const [n6, i8, o13, a9] = L(t14.composers), c7 = typeof t14.type == "function" || t14.type.$$typeof ? ((e13) => {
    function t15() {
      for (let r14 = 0; r14 < t15[T].length; r14++) {
        const [n7, i9] = t15[T][r14];
        e13.rules[n7].apply(i9);
      }
      return t15[T] = [], null;
    }
    return t15[T] = [], t15.rules = {}, W.forEach((e14) => t15.rules[e14] = { apply: (r14) => t15[T].push([e14, r14]) }), t15;
  })(r13) : null, d8 = (c7 || r13).rules, g5 = `.${n6}${i8.length > 1 ? `:where(.${i8.slice(1).join(".")})` : ""}`, p7 = (l9) => {
    l9 = typeof l9 == "object" && l9 || A;
    const _a2 = l9, { css: s8 } = _a2, p8 = __objRest(_a2, ["css"]), u4 = {};
    for (const e13 in o13)
      if (delete p8[e13], e13 in l9) {
        let t15 = l9[e13];
        typeof t15 == "object" && t15 ? u4[e13] = __spreadValues({ "@initial": o13[e13] }, t15) : (t15 = String(t15), u4[e13] = t15 !== "undefined" || a9.has(e13) ? t15 : o13[e13]);
      } else
        u4[e13] = o13[e13];
    const h3 = new Set([...i8]);
    for (const [n7, i9, o14, l10] of t14.composers) {
      r13.rules.styled.cache.has(n7) || (r13.rules.styled.cache.add(n7), $(i9, [`.${n7}`], [], e12, (e13) => {
        d8.styled.apply(e13);
      }));
      const t15 = O(o14, u4, e12.media), s9 = O(l10, u4, e12.media, true);
      for (const i10 of t15)
        if (i10 !== void 0)
          for (const [t16, o15, l11] of i10) {
            const i11 = `${n7}-${z(o15)}-${t16}`;
            h3.add(i11);
            const s10 = (l11 ? r13.rules.resonevar : r13.rules.onevar).cache, a10 = l11 ? d8.resonevar : d8.onevar;
            s10.has(i11) || (s10.add(i11), $(o15, [`.${i11}`], [], e12, (e13) => {
              a10.apply(e13);
            }));
          }
      for (const t16 of s9)
        if (t16 !== void 0)
          for (const [i10, o15] of t16) {
            const t17 = `${n7}-${z(o15)}-${i10}`;
            h3.add(t17), r13.rules.allvar.cache.has(t17) || (r13.rules.allvar.cache.add(t17), $(o15, [`.${t17}`], [], e12, (e13) => {
              d8.allvar.apply(e13);
            }));
          }
    }
    if (typeof s8 == "object" && s8) {
      const t15 = `${n6}-i${z(s8)}-css`;
      h3.add(t15), r13.rules.inline.cache.has(t15) || (r13.rules.inline.cache.add(t15), $(s8, [`.${t15}`], [], e12, (e13) => {
        d8.inline.apply(e13);
      }));
    }
    for (const e13 of String(l9.className || "").trim().split(/\s+/))
      e13 && h3.add(e13);
    const f11 = p8.className = [...h3].join(" ");
    return { type: t14.type, className: f11, selector: g5, props: p8, toString: () => f11, deferredInjector: c7 };
  };
  return s(p7, { className: n6, selector: g5, [l]: t14, toString: () => (r13.rules.styled.cache.has(n6) || p7(), n6) });
};
var L = (e12) => {
  let t14 = "";
  const r13 = [], n6 = {}, i8 = [];
  for (const [o13, , , , l9, s8] of e12) {
    t14 === "" && (t14 = o13), r13.push(o13), i8.push(...s8);
    for (const e13 in l9) {
      const t15 = l9[e13];
      (n6[e13] === void 0 || t15 !== "undefined" || s8.includes(t15)) && (n6[e13] = t15);
    }
  }
  return [t14, r13, n6, new Set(i8)];
};
var O = (e12, t14, r13, n6) => {
  const i8 = [];
  e:
    for (let [o13, l9, s8] of e12) {
      if (s8)
        continue;
      let e13, a9 = 0, c7 = false;
      for (e13 in o13) {
        const n7 = o13[e13];
        let i9 = t14[e13];
        if (i9 !== n7) {
          if (typeof i9 != "object" || !i9)
            continue e;
          {
            let e14, t15, o14 = 0;
            for (const l10 in i9) {
              if (n7 === String(i9[l10])) {
                if (l10 !== "@initial") {
                  const e15 = l10.slice(1);
                  (t15 = t15 || []).push(e15 in r13 ? r13[e15] : l10.replace(/^@media ?/, "")), c7 = true;
                }
                a9 += o14, e14 = true;
              }
              ++o14;
            }
            if (t15 && t15.length && (l9 = { ["@media " + t15.join(", ")]: l9 }), !e14)
              continue e;
          }
        }
      }
      (i8[a9] = i8[a9] || []).push([n6 ? "cv" : `${e13}-${o13[e13]}`, l9, c7]);
    }
  return i8;
};
var A = {};
var N = o();
var D = (e12, t14) => N(e12, () => (...r13) => {
  const n6 = () => {
    for (let n7 of r13) {
      n7 = typeof n7 == "object" && n7 || {};
      let r14 = z(n7);
      if (!t14.rules.global.cache.has(r14)) {
        if (t14.rules.global.cache.add(r14), "@import" in n7) {
          let e13 = [].indexOf.call(t14.sheet.cssRules, t14.rules.themed.group) - 1;
          for (let r15 of [].concat(n7["@import"]))
            r15 = r15.includes('"') || r15.includes("'") ? r15 : `"${r15}"`, t14.sheet.insertRule(`@import ${r15};`, e13++);
          delete n7["@import"];
        }
        $(n7, [], [], e12, (e13) => {
          t14.rules.global.apply(e13);
        });
      }
    }
    return "";
  };
  return s(n6, { toString: n6 });
});
var H = o();
var V2 = (e12, t14) => H(e12, () => (r13) => {
  const n6 = `${S(e12.prefix)}k-${z(r13)}`, i8 = () => {
    if (!t14.rules.global.cache.has(n6)) {
      t14.rules.global.cache.add(n6);
      const i9 = [];
      $(r13, [], [], e12, (e13) => i9.push(e13));
      const o13 = `@keyframes ${n6}{${i9.join("")}}`;
      t14.rules.global.apply(o13);
    }
    return n6;
  };
  return s(i8, { get name() {
    return i8();
  }, toString: i8 });
});
var G = class {
  constructor(e12, t14, r13, n6) {
    this.token = e12 == null ? "" : String(e12), this.value = t14 == null ? "" : String(t14), this.scale = r13 == null ? "" : String(r13), this.prefix = n6 == null ? "" : String(n6);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + S(this.prefix) + S(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
};
var F = o();
var J = (e12, t14) => F(e12, () => (r13, n6) => {
  n6 = typeof r13 == "object" && r13 || Object(n6);
  const i8 = `.${r13 = (r13 = typeof r13 == "string" ? r13 : "") || `${S(e12.prefix)}t-${z(n6)}`}`, o13 = {}, l9 = [];
  for (const t15 in n6) {
    o13[t15] = {};
    for (const r14 in n6[t15]) {
      const i9 = `--${S(e12.prefix)}${t15}-${r14}`, s9 = k(String(n6[t15][r14]), e12.prefix, t15);
      o13[t15][r14] = new G(r14, s9, t15, e12.prefix), l9.push(`${i9}:${s9}`);
    }
  }
  const s8 = () => {
    if (l9.length && !t14.rules.themed.cache.has(r13)) {
      t14.rules.themed.cache.add(r13);
      const i9 = `${n6 === e12.theme ? ":root," : ""}.${r13}{${l9.join(";")}}`;
      t14.rules.themed.apply(i9);
    }
    return r13;
  };
  return __spreadProps(__spreadValues({}, o13), { get className() {
    return s8();
  }, selector: i8, toString: s8 });
});
var U = o();
var Y = o();
var q = (e12) => {
  const t14 = ((e13) => {
    let t15 = false;
    const r13 = U(e13, (e14) => {
      t15 = true;
      const r14 = "prefix" in (e14 = typeof e14 == "object" && e14 || {}) ? String(e14.prefix) : "", i8 = typeof e14.media == "object" && e14.media || {}, o13 = typeof e14.root == "object" ? e14.root || null : globalThis.document || null, l9 = typeof e14.theme == "object" && e14.theme || {}, s8 = { prefix: r14, media: i8, theme: l9, themeMap: typeof e14.themeMap == "object" && e14.themeMap || __spreadValues({}, n), utils: typeof e14.utils == "object" && e14.utils || {} }, a9 = E(o13), c7 = { css: M(s8, a9), globalCss: D(s8, a9), keyframes: V2(s8, a9), createTheme: J(s8, a9), reset() {
        a9.reset(), c7.theme.toString();
      }, theme: {}, sheet: a9, config: s8, prefix: r14, getCssText: a9.toString, toString: a9.toString };
      return String(c7.theme = c7.createTheme(l9)), c7;
    });
    return t15 || r13.reset(), r13;
  })(e12);
  return t14.styled = (({ config: e13, sheet: t15 }) => Y(e13, () => {
    const r13 = M(e13, t15);
    return (...e14) => {
      const t16 = r13(...e14), n6 = t16[l].type, i8 = import_react54.default.forwardRef((e15, r14) => {
        const i9 = e15 && e15.as || n6, { props: o13, deferredInjector: l9 } = t16(e15);
        return delete o13.as, o13.ref = r14, l9 ? import_react54.default.createElement(import_react54.default.Fragment, null, import_react54.default.createElement(i9, o13), import_react54.default.createElement(l9, null)) : import_react54.default.createElement(i9, o13);
      });
      return i8.className = t16.className, i8.displayName = `Styled.${n6.displayName || n6.name || n6}`, i8.selector = t16.selector, i8.toString = () => t16.selector, i8[l] = t16[l], i8;
    };
  }))(t14), t14;
};

// ../../node_modules/safari-14-idb-fix/dist/index.js
function idbReady() {
  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
var dist_default = idbReady;

// ../../node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const dbp = dist_default().then(() => {
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    return promisifyRequest(request);
  });
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get4(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set5(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}

// ../../packages/tldraw/dist/esm/index.js
var import_react62 = __toModule(require_react());

// ../../node_modules/perfect-freehand/dist/esm/index.js
function W2(e12, t14, s8, h3 = (b7) => b7) {
  return e12 * h3(0.5 - t14 * (0.5 - s8));
}
function re(e12) {
  return [-e12[0], -e12[1]];
}
function l2(e12, t14) {
  return [e12[0] + t14[0], e12[1] + t14[1]];
}
function a2(e12, t14) {
  return [e12[0] - t14[0], e12[1] - t14[1]];
}
function f2(e12, t14) {
  return [e12[0] * t14, e12[1] * t14];
}
function le(e12, t14) {
  return [e12[0] / t14, e12[1] / t14];
}
function L2(e12) {
  return [e12[1], -e12[0]];
}
function ne(e12, t14) {
  return e12[0] * t14[0] + e12[1] * t14[1];
}
function oe(e12, t14) {
  return e12[0] === t14[0] && e12[1] === t14[1];
}
function fe(e12) {
  return Math.hypot(e12[0], e12[1]);
}
function be(e12) {
  return e12[0] * e12[0] + e12[1] * e12[1];
}
function Y2(e12, t14) {
  return be(a2(e12, t14));
}
function G2(e12) {
  return le(e12, fe(e12));
}
function ue(e12, t14) {
  return Math.hypot(e12[1] - t14[1], e12[0] - t14[0]);
}
function T2(e12, t14, s8) {
  let h3 = Math.sin(s8), b7 = Math.cos(s8), v6 = e12[0] - t14[0], n6 = e12[1] - t14[1], g5 = v6 * b7 - n6 * h3, E6 = v6 * h3 + n6 * b7;
  return [g5 + t14[0], E6 + t14[1]];
}
function V3(e12, t14, s8) {
  return l2(e12, f2(a2(t14, e12), s8));
}
function Z2(e12, t14, s8) {
  return l2(e12, f2(t14, s8));
}
var { min: _14, PI: ge } = Math;
var se = 0.275;
var j2 = ge + 1e-4;
function ie(e12, t14 = {}) {
  let { size: s8 = 16, smoothing: h3 = 0.5, thinning: b7 = 0.5, simulatePressure: v6 = true, easing: n6 = (r13) => r13, start: g5 = {}, end: E6 = {}, last: z3 = false } = t14, { cap: d8 = true, taper: x5 = 0, easing: q3 = (r13) => r13 * (2 - r13) } = g5, { cap: m7 = true, taper: c7 = 0, easing: M4 = (r13) => --r13 * r13 * r13 + 1 } = E6;
  if (e12.length === 0 || s8 <= 0)
    return [];
  let H3 = e12[e12.length - 1].runningLength, $2 = Math.pow(s8 * h3, 2), D7 = [], R5 = [], N2 = e12.slice(0, 10).reduce((r13, i8) => {
    let o13 = i8.pressure;
    if (v6) {
      let u4 = _14(1, i8.distance / s8), J3 = _14(1, 1 - u4);
      o13 = _14(1, r13 + (J3 - r13) * (u4 * se));
    }
    return (r13 + o13) / 2;
  }, e12[0].pressure), p7 = W2(s8, b7, e12[e12.length - 1].pressure, n6), U3, B3 = e12[0].vector, I3 = e12[0].point, C6 = I3, y4 = I3, O5 = C6;
  for (let r13 = 0; r13 < e12.length; r13++) {
    let { pressure: i8 } = e12[r13], { point: o13, vector: u4, distance: J3, runningLength: K2 } = e12[r13];
    if (r13 < e12.length - 1 && H3 - K2 < 3)
      continue;
    if (b7) {
      if (v6) {
        let P3 = _14(1, J3 / s8), Q = _14(1, 1 - P3);
        i8 = _14(1, N2 + (Q - N2) * (P3 * se));
      }
      p7 = W2(s8, b7, i8, n6);
    } else
      p7 = s8 / 2;
    U3 === void 0 && (U3 = p7);
    let pe = K2 < x5 ? q3(K2 / x5) : 1, ae = H3 - K2 < c7 ? M4((H3 - K2) / c7) : 1;
    if (p7 = Math.max(0.01, p7 * Math.min(pe, ae)), r13 === e12.length - 1) {
      let P3 = f2(L2(u4), p7);
      D7.push(a2(o13, P3)), R5.push(l2(o13, P3));
      continue;
    }
    let A4 = e12[r13 + 1].vector, ee = ne(u4, A4);
    if (ee < 0) {
      let P3 = f2(L2(B3), p7);
      for (let Q = 1 / 13, w6 = 0; w6 <= 1; w6 += Q)
        y4 = T2(a2(o13, P3), o13, j2 * w6), D7.push(y4), O5 = T2(l2(o13, P3), o13, j2 * -w6), R5.push(O5);
      I3 = y4, C6 = O5;
      continue;
    }
    let te = f2(L2(V3(A4, u4, ee)), p7);
    y4 = a2(o13, te), (r13 <= 1 || Y2(I3, y4) > $2) && (D7.push(y4), I3 = y4), O5 = l2(o13, te), (r13 <= 1 || Y2(C6, O5) > $2) && (R5.push(O5), C6 = O5), N2 = i8, B3 = u4;
  }
  let S3 = e12[0].point.slice(0, 2), k3 = e12.length > 1 ? e12[e12.length - 1].point.slice(0, 2) : l2(e12[0].point, [1, 1]), X2 = [], F5 = [];
  if (e12.length === 1) {
    if (!(x5 || c7) || z3) {
      let r13 = Z2(S3, G2(L2(a2(S3, k3))), -(U3 || p7)), i8 = [];
      for (let o13 = 1 / 13, u4 = o13; u4 <= 1; u4 += o13)
        i8.push(T2(r13, S3, j2 * 2 * u4));
      return i8;
    }
  } else {
    if (!(x5 || c7 && e12.length === 1))
      if (d8)
        for (let i8 = 1 / 13, o13 = i8; o13 <= 1; o13 += i8) {
          let u4 = T2(R5[0], S3, j2 * o13);
          X2.push(u4);
        }
      else {
        let i8 = a2(D7[0], R5[0]), o13 = f2(i8, 0.5), u4 = f2(i8, 0.51);
        X2.push(a2(S3, o13), a2(S3, u4), l2(S3, u4), l2(S3, o13));
      }
    let r13 = L2(re(e12[e12.length - 1].vector));
    if (c7 || x5 && e12.length === 1)
      F5.push(k3);
    else if (m7) {
      let i8 = Z2(k3, r13, p7);
      for (let o13 = 1 / 29, u4 = o13; u4 < 1; u4 += o13)
        F5.push(T2(i8, k3, j2 * 3 * u4));
    } else
      F5.push(l2(k3, f2(r13, p7)), l2(k3, f2(r13, p7 * 0.99)), a2(k3, f2(r13, p7 * 0.99)), a2(k3, f2(r13, p7)));
  }
  return D7.concat(F5, R5.reverse(), X2);
}
function ce(e12, t14 = {}) {
  var q3;
  let { streamline: s8 = 0.5, size: h3 = 16, last: b7 = false } = t14;
  if (e12.length === 0)
    return [];
  let v6 = 0.15 + (1 - s8) * 0.85, n6 = Array.isArray(e12[0]) ? e12 : e12.map(({ x: m7, y: c7, pressure: M4 = 0.5 }) => [m7, c7, M4]);
  if (n6.length === 2) {
    let m7 = n6[1];
    n6 = n6.slice(0, -1);
    for (let c7 = 1; c7 < 5; c7++)
      n6.push(V3(n6[0], m7, c7 / 4));
  }
  n6.length === 1 && (n6 = [...n6, [...l2(n6[0], [1, 1]), ...n6[0].slice(2)]]);
  let g5 = [{ point: [n6[0][0], n6[0][1]], pressure: n6[0][2] >= 0 ? n6[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], E6 = false, z3 = 0, d8 = g5[0], x5 = n6.length - 1;
  for (let m7 = 1; m7 < n6.length; m7++) {
    let c7 = b7 && m7 === x5 ? n6[m7].slice(0, 2) : V3(d8.point, n6[m7], v6);
    if (oe(d8.point, c7))
      continue;
    let M4 = ue(c7, d8.point);
    if (z3 += M4, m7 < x5 && !E6) {
      if (z3 < h3)
        continue;
      E6 = true;
    }
    d8 = { point: c7, pressure: n6[m7][2] >= 0 ? n6[m7][2] : 0.5, vector: G2(a2(d8.point, c7)), distance: M4, runningLength: z3 }, g5.push(d8);
  }
  return g5[0].vector = ((q3 = g5[1]) == null ? void 0 : q3.vector) || [0, 0], g5;
}
function me(e12, t14 = {}) {
  return ie(ce(e12, t14), t14);
}
var Te = me;

// ../../packages/tldraw/dist/esm/index.js
var import_react63 = __toModule(require_react());
var import_react64 = __toModule(require_react());
var import_react65 = __toModule(require_react());
var import_react66 = __toModule(require_react());
var import_react67 = __toModule(require_react());
var import_react68 = __toModule(require_react());
var import_react69 = __toModule(require_react());
var import_react70 = __toModule(require_react());

// ../../node_modules/zustand/esm/vanilla.mjs
function createStore2(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace3) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace3 ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
}

// ../../node_modules/zustand/esm/index.mjs
var import_react55 = __toModule(require_react());
function createStore3(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace3) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace3 ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
}
var isSSR = typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var useIsomorphicLayoutEffect = isSSR ? import_react55.useEffect : import_react55.useLayoutEffect;
function create(createState) {
  const api = typeof createState === "function" ? createStore3(createState) : createState;
  const useStore = (selector = api.getState, equalityFn = Object.is) => {
    const [, forceUpdate] = (0, import_react55.useReducer)((c7) => c7 + 1, 0);
    const state = api.getState();
    const stateRef = (0, import_react55.useRef)(state);
    const selectorRef = (0, import_react55.useRef)(selector);
    const equalityFnRef = (0, import_react55.useRef)(equalityFn);
    const erroredRef = (0, import_react55.useRef)(false);
    const currentSliceRef = (0, import_react55.useRef)();
    if (currentSliceRef.current === void 0) {
      currentSliceRef.current = selector(state);
    }
    let newStateSlice;
    let hasNewStateSlice = false;
    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {
      newStateSlice = selector(state);
      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);
    }
    useIsomorphicLayoutEffect(() => {
      if (hasNewStateSlice) {
        currentSliceRef.current = newStateSlice;
      }
      stateRef.current = state;
      selectorRef.current = selector;
      equalityFnRef.current = equalityFn;
      erroredRef.current = false;
    });
    const stateBeforeSubscriptionRef = (0, import_react55.useRef)(state);
    useIsomorphicLayoutEffect(() => {
      const listener = () => {
        try {
          const nextState = api.getState();
          const nextStateSlice = selectorRef.current(nextState);
          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {
            stateRef.current = nextState;
            currentSliceRef.current = nextStateSlice;
            forceUpdate();
          }
        } catch (error) {
          erroredRef.current = true;
          forceUpdate();
        }
      };
      const unsubscribe = api.subscribe(listener);
      if (api.getState() !== stateBeforeSubscriptionRef.current) {
        listener();
      }
      return unsubscribe;
    }, []);
    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;
    (0, import_react55.useDebugValue)(sliceToReturn);
    return sliceToReturn;
  };
  Object.assign(useStore, api);
  useStore[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const items = [useStore, api];
    return {
      next() {
        const done = items.length <= 0;
        return { value: items.shift(), done };
      }
    };
  };
  return useStore;
}

// ../../packages/tldraw/dist/esm/index.js
var import_react71 = __toModule(require_react());

// ../../node_modules/hotkeys-js/dist/hotkeys.esm.js
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object3, event, method) {
  if (object3.addEventListener) {
    object3.addEventListener(event, method, false);
  } else if (object3.attachEvent) {
    object3.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i8 = 0; i8 < mods.length; i8++) {
    mods[i8] = modifier[mods[i8].toLowerCase()];
  }
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  var keys = key.split(",");
  var index2 = keys.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys[index2 - 1] += ",";
    keys.splice(index2, 1);
    index2 = keys.lastIndexOf("");
  }
  return keys;
}
function compareArray(a1, a22) {
  var arr1 = a1.length >= a22.length ? a1 : a22;
  var arr2 = a1.length >= a22.length ? a22 : a1;
  var isIndex = true;
  for (var i8 = 0; i8 < arr1.length; i8++) {
    if (arr2.indexOf(arr1[i8]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "\u21EA": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  "\u21E7": 16,
  shift: 16,
  "\u2325": 18,
  alt: 18,
  option: 18,
  "\u2303": 17,
  ctrl: 17,
  control: 17,
  "\u2318": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (k3 = 1; k3 < 20; k3++) {
  _keyMap["f".concat(k3)] = 111 + k3;
}
var k3;
var _downKeys = [];
var _scope = "all";
var elementHasBindEvent = [];
var code = function code2(x5) {
  return _keyMap[x5.toLowerCase()] || _modifier[x5.toLowerCase()] || x5.toUpperCase().charCodeAt(0);
};
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  var handlers;
  var i8;
  if (!scope)
    scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i8 = 0; i8 < handlers.length; ) {
        if (handlers[i8].scope === scope)
          handlers.splice(i8, 1);
        else
          i8++;
      }
    }
  }
  if (getScope() === scope)
    setScope(newScope || "all");
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i8 = _downKeys.indexOf(key);
  if (i8 >= 0) {
    _downKeys.splice(i8, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (var k3 in _modifier) {
      if (_modifier[k3] === key)
        hotkeys[k3] = false;
    }
  }
}
function unbind(keysInfo) {
  if (!keysInfo) {
    Object.keys(_handlers).forEach(function(key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key)
        eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var scope = args[0], method = args[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = function eachUnbind2(_ref) {
  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode])
      return;
    if (!scope)
      scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].map(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
        return {};
      }
      return record;
    });
  });
};
function eventHandler(event, handler, scope) {
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y4 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y4)) {
        if (!_mods[y4] && handler.mods.indexOf(+y4) > -1 || _mods[y4] && handler.mods.indexOf(+y4) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event) {
  var asterisk = _handlers["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229)
    _downKeys.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (var k3 in _modifier) {
      if (_modifier[k3] === key)
        hotkeys[k3] = true;
    }
    if (!asterisk)
      return;
  }
  for (var e12 in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e12)) {
      _mods[e12] = event[modifierMap[e12]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  var scope = getScope();
  if (asterisk) {
    for (var i8 = 0; i8 < asterisk.length; i8++) {
      if (asterisk[i8].scope === scope && (event.type === "keydown" && asterisk[i8].keydown || event.type === "keyup" && asterisk[i8].keyup)) {
        eventHandler(event, asterisk[i8], scope);
      }
    }
  }
  if (!(key in _handlers))
    return;
  for (var _i = 0; _i < _handlers[key].length; _i++) {
    if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
      if (_handlers[key][_i].key) {
        var record = _handlers[key][_i];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a9 = 0; a9 < keyShortcut.length; a9++) {
          _downKeysCurrent.push(code(keyShortcut[a9]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope);
        }
      }
    }
  }
}
function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys = getKeys(key);
  var mods = [];
  var scope = "all";
  var element = document;
  var i8 = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
  }
  if (typeof option === "string")
    scope = option;
  for (; i8 < keys.length; i8++) {
    key = keys[i8].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers))
      _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys[i8],
      method,
      key: keys[i8],
      splitKey
    });
  }
  if (typeof element !== "undefined" && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, "keydown", function(e12) {
      dispatch(e12);
    });
    addEvent(window, "focus", function() {
      _downKeys = [];
    });
    addEvent(element, "keyup", function(e12) {
      dispatch(e12);
      clearModifier(e12);
    });
  }
}
var _api = {
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  unbind
};
for (a9 in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a9)) {
    hotkeys[a9] = _api[a9];
  }
}
var a9;
if (typeof window !== "undefined") {
  _hotkeys = window.hotkeys;
  hotkeys.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
var _hotkeys;
var hotkeys_esm_default = hotkeys;

// ../../node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js
var import_react56 = __toModule(require_react());
hotkeys_esm_default.filter = function() {
  return true;
};
var tagFilter = function tagFilter2(_ref, enableOnTags) {
  var target = _ref.target;
  var targetTagName = target && target.tagName;
  return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName));
};
var isKeyboardEventTriggeredByInput = function isKeyboardEventTriggeredByInput2(ev) {
  return tagFilter(ev, ["INPUT", "TEXTAREA", "SELECT"]);
};
function useHotkeys(keys, callback, options2, deps) {
  if (options2 instanceof Array) {
    deps = options2;
    options2 = void 0;
  }
  var _ref2 = options2 || {}, enableOnTags = _ref2.enableOnTags, filter2 = _ref2.filter, keyup = _ref2.keyup, keydown = _ref2.keydown, _ref2$filterPreventDe = _ref2.filterPreventDefault, filterPreventDefault = _ref2$filterPreventDe === void 0 ? true : _ref2$filterPreventDe, _ref2$enabled = _ref2.enabled, enabled = _ref2$enabled === void 0 ? true : _ref2$enabled, _ref2$enableOnContent = _ref2.enableOnContentEditable, enableOnContentEditable = _ref2$enableOnContent === void 0 ? false : _ref2$enableOnContent;
  var ref = (0, import_react56.useRef)(null);
  var memoisedCallback = (0, import_react56.useCallback)(function(keyboardEvent, hotkeysEvent) {
    var _keyboardEvent$target;
    if (filter2 && !filter2(keyboardEvent)) {
      return !filterPreventDefault;
    }
    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (_keyboardEvent$target = keyboardEvent.target) != null && _keyboardEvent$target.isContentEditable && !enableOnContentEditable) {
      return true;
    }
    if (ref.current === null || document.activeElement === ref.current) {
      callback(keyboardEvent, hotkeysEvent);
      return true;
    }
    return false;
  }, deps ? [ref, enableOnTags, filter2].concat(deps) : [ref, enableOnTags, filter2]);
  (0, import_react56.useEffect)(function() {
    if (!enabled) {
      hotkeys_esm_default.unbind(keys, memoisedCallback);
      return;
    }
    if (keyup && keydown !== true) {
      options2.keydown = false;
    }
    hotkeys_esm_default(keys, options2 || {}, memoisedCallback);
    return function() {
      return hotkeys_esm_default.unbind(keys, memoisedCallback);
    };
  }, [memoisedCallback, keys, enabled]);
  return ref;
}
var isHotkeyPressed = hotkeys_esm_default.isPressed;

// ../../packages/tldraw/dist/esm/index.js
var import_react72 = __toModule(require_react());
var import_react73 = __toModule(require_react());
var import_react74 = __toModule(require_react());
var import_react75 = __toModule(require_react());
var import_react76 = __toModule(require_react());
var import_react77 = __toModule(require_react());
var import_react78 = __toModule(require_react());

// ../../node_modules/@radix-ui/react-context/dist/index.module.js
var e2 = __toModule(require_react());
function createContext3(t14, n6) {
  const o13 = /* @__PURE__ */ e2.createContext(n6);
  function r13(t15) {
    const _a2 = t15, { children: n7 } = _a2, r14 = __objRest(_a2, ["children"]), c7 = e2.useMemo(() => r14, Object.values(r14));
    return e2.createElement(o13.Provider, { value: c7 }, n7);
  }
  return r13.displayName = t14 + "Provider", [r13, function(r14) {
    const c7 = e2.useContext(o13);
    if (c7)
      return c7;
    if (n6 !== void 0)
      return n6;
    throw new Error(`\`${r14}\` must be used within \`${t14}\``);
  }];
}
function createContextScope(n6, o13 = []) {
  let r13 = [];
  const c7 = () => {
    const t14 = r13.map((t15) => /* @__PURE__ */ e2.createContext(t15));
    return function(o14) {
      const r14 = (o14 == null ? void 0 : o14[n6]) || t14;
      return e2.useMemo(() => ({ [`__scope${n6}`]: __spreadProps(__spreadValues({}, o14), { [n6]: r14 }) }), [o14, r14]);
    };
  };
  return c7.scopeName = n6, [function(t14, o14) {
    const c8 = /* @__PURE__ */ e2.createContext(o14), u4 = r13.length;
    function s8(t15) {
      const _a2 = t15, { scope: o15, children: r14 } = _a2, s9 = __objRest(_a2, ["scope", "children"]), i8 = (o15 == null ? void 0 : o15[n6][u4]) || c8, a9 = e2.useMemo(() => s9, Object.values(s9));
      return e2.createElement(i8.Provider, { value: a9 }, r14);
    }
    return r13 = [...r13, o14], s8.displayName = t14 + "Provider", [s8, function(r14, s9) {
      const i8 = (s9 == null ? void 0 : s9[n6][u4]) || c8, a9 = e2.useContext(i8);
      if (a9)
        return a9;
      if (o14 !== void 0)
        return o14;
      throw new Error(`\`${r14}\` must be used within \`${t14}\``);
    }];
  }, t2(c7, ...o13)];
}
function t2(...t14) {
  const n6 = t14[0];
  if (t14.length === 1)
    return n6;
  const o13 = () => {
    const o14 = t14.map((e12) => ({ useScope: e12(), scopeName: e12.scopeName }));
    return function(t15) {
      const r13 = o14.reduce((e12, { useScope: n7, scopeName: o15 }) => __spreadValues(__spreadValues({}, e12), n7(t15)[`__scope${o15}`]), {});
      return e2.useMemo(() => ({ [`__scope${n6.scopeName}`]: r13 }), [r13]);
    };
  };
  return o13.scopeName = n6.scopeName, o13;
}

// ../../node_modules/@radix-ui/react-id/dist/index.module.js
var r2 = __toModule(require_react());

// ../../node_modules/@babel/runtime/helpers/esm/extends.js
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i8 = 1; i8 < arguments.length; i8++) {
      var source = arguments[i8];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// ../../node_modules/@radix-ui/react-id/dist/index.module.js
var n2 = { prefix: Math.round(1e10 * Math.random()), current: 0 };
var [t3, i2] = createContext3("IdProvider", n2);
function useId(e12) {
  const o13 = i2("IdProviderConsumer");
  return Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) || o13 !== n2 || console.warn("When server rendering, you must wrap your application in an <IdProvider> to ensure consistent ids are generated between the client and server."), r2.useMemo(() => e12 || `radix-id-${o13.prefix}-${++o13.current}`, [e12]);
}

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.module.js
var e3 = __toModule(require_react());
var t4 = 0;
function useFocusGuards() {
  e3.useEffect(() => {
    var e12, n6;
    const r13 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e12 = r13[0]) !== null && e12 !== void 0 ? e12 : o2()), document.body.insertAdjacentElement("beforeend", (n6 = r13[1]) !== null && n6 !== void 0 ? n6 : o2()), t4++, () => {
      t4 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e13) => e13.remove()), t4--;
    };
  }, []);
}
function o2() {
  const e12 = document.createElement("span");
  return e12.setAttribute("data-radix-focus-guard", ""), e12.tabIndex = 0, e12.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e12;
}

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.module.js
var e4 = __toModule(require_react());
function useCallbackRef(r13) {
  const t14 = e4.useRef(r13);
  return e4.useEffect(() => {
    t14.current = r13;
  }), e4.useMemo(() => (...e12) => {
    var r14;
    return (r14 = t14.current) === null || r14 === void 0 ? void 0 : r14.call(t14, ...e12);
  }, []);
}

// ../../node_modules/@radix-ui/react-use-direction/dist/index.module.js
var e5 = __toModule(require_react());
function useDirection(t14, n6) {
  const [r13, o13] = e5.useState("ltr"), [i8, u4] = e5.useState(), c7 = e5.useRef(0);
  return e5.useEffect(() => {
    if (n6 === void 0 && t14 != null && t14.parentElement) {
      const e12 = getComputedStyle(t14.parentElement);
      u4(e12);
    }
  }, [t14, n6]), e5.useEffect(() => (n6 === void 0 && function e12() {
    c7.current = requestAnimationFrame(() => {
      const t15 = i8 == null ? void 0 : i8.direction;
      t15 && o13(t15), e12();
    });
  }(), () => cancelAnimationFrame(c7.current)), [i8, n6, o13]), n6 || r13;
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
var t5 = __toModule(require_react());
function useControllableState({ prop: o13, defaultProp: r13, onChange: n6 = () => {
} }) {
  const [a9, u4] = function({ defaultProp: o14, onChange: r14 }) {
    const n7 = t5.useState(o14), [a10] = n7, u5 = t5.useRef(a10), c8 = useCallbackRef(r14);
    return t5.useEffect(() => {
      u5.current !== a10 && (c8(a10), u5.current = a10);
    }, [a10, u5, c8]), n7;
  }({ defaultProp: r13, onChange: n6 }), c7 = o13 !== void 0, f11 = c7 ? o13 : a9, l9 = useCallbackRef(n6);
  return [f11, t5.useCallback((e12) => {
    if (c7) {
      const t14 = e12, r14 = typeof e12 == "function" ? t14(o13) : e12;
      r14 !== o13 && l9(r14);
    } else
      u4(e12);
  }, [c7, o13, u4, l9])];
}

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.module.js
var o3 = __toModule(require_react());
function composeRefs(...o13) {
  return (e12) => o13.forEach((o14) => function(o15, e13) {
    typeof o15 == "function" ? o15(e13) : o15 != null && (o15.current = e13);
  }(o14, e12));
}
function useComposedRefs(...e12) {
  return o3.useCallback(composeRefs(...e12), e12);
}

// ../../node_modules/@radix-ui/react-slot/dist/index.module.js
var t6 = __toModule(require_react());
var Slot = /* @__PURE__ */ t6.forwardRef((e12, o13) => {
  const _a2 = e12, { children: a9 } = _a2, s8 = __objRest(_a2, ["children"]), c7 = t6.Children.toArray(a9);
  return c7.some(l3) ? /* @__PURE__ */ t6.createElement(t6.Fragment, null, c7.map((e13) => l3(e13) ? /* @__PURE__ */ t6.createElement(n3, _extends3({}, s8, { ref: o13 }), e13.props.children) : e13)) : /* @__PURE__ */ t6.createElement(n3, _extends3({}, s8, { ref: o13 }), a9);
});
Slot.displayName = "Slot";
var n3 = /* @__PURE__ */ t6.forwardRef((r13, n6) => {
  const _a2 = r13, { children: l9 } = _a2, a9 = __objRest(_a2, ["children"]);
  return t6.isValidElement(l9) ? /* @__PURE__ */ t6.cloneElement(l9, __spreadProps(__spreadValues({}, o4(a9, l9.props)), { ref: composeRefs(n6, l9.ref) })) : t6.Children.count(l9) > 1 ? t6.Children.only(null) : null;
});
n3.displayName = "SlotClone";
var Slottable = ({ children: e12 }) => /* @__PURE__ */ t6.createElement(t6.Fragment, null, e12);
function l3(e12) {
  return t6.isValidElement(e12) && e12.type === Slottable;
}
function o4(e12, t14) {
  const r13 = __spreadValues({}, t14);
  for (const n6 in t14) {
    const l9 = e12[n6], o13 = t14[n6];
    /^on[A-Z]/.test(n6) ? r13[n6] = (...e13) => {
      o13 == null || o13(...e13), l9 == null || l9(...e13);
    } : n6 === "style" ? r13[n6] = __spreadValues(__spreadValues({}, l9), o13) : n6 === "className" && (r13[n6] = [l9, o13].filter(Boolean).join(" "));
  }
  return __spreadValues(__spreadValues({}, e12), r13);
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.module.js
var r3 = __toModule(require_react());
var Primitive = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "p", "span", "svg", "ul"].reduce((t14, s8) => __spreadProps(__spreadValues({}, t14), { [s8]: /* @__PURE__ */ r3.forwardRef((t15, n6) => {
  const _a2 = t15, { asChild: a9 } = _a2, m7 = __objRest(_a2, ["asChild"]), d8 = a9 ? Slot : s8;
  return r3.useEffect(() => {
    window[Symbol.for("radix-ui")] = true;
  }, []), t15.as && console.error(o5), /* @__PURE__ */ r3.createElement(d8, _extends3({}, m7, { ref: n6 }));
}) }), {});
var o5 = "Warning: The `as` prop has been removed in favour of `asChild`. For details, see https://radix-ui.com/docs/primitives/overview/styling#changing-the-rendered-element";

// ../../node_modules/@radix-ui/react-collection/dist/index.module.js
var import_react57 = __toModule(require_react());
function createCollection(c7) {
  const n6 = c7 + "CollectionProvider", [l9, i8] = createContextScope(n6), [f11, a9] = l9(n6, { collectionRef: { current: null }, itemMap: new Map() }), u4 = (e12) => {
    const { scope: r13, children: t14 } = e12, c8 = import_react57.default.useRef(null), n7 = import_react57.default.useRef(new Map()).current;
    return import_react57.default.createElement(f11, { scope: r13, itemMap: n7, collectionRef: c8 }, t14);
  }, m7 = c7 + "CollectionSlot", s8 = /* @__PURE__ */ import_react57.default.forwardRef((t14, c8) => {
    const { scope: n7, children: l10 } = t14, i9 = a9(m7, n7), f12 = useComposedRefs(c8, i9.collectionRef);
    return import_react57.default.createElement(Slot, { ref: f12 }, l10);
  }), p7 = c7 + "CollectionItemSlot", d8 = "data-radix-collection-item", R5 = /* @__PURE__ */ import_react57.default.forwardRef((t14, c8) => {
    const _a2 = t14, { scope: n7, children: l10 } = _a2, i9 = __objRest(_a2, ["scope", "children"]), f12 = import_react57.default.useRef(null), u5 = useComposedRefs(c8, f12), m8 = a9(p7, n7);
    return import_react57.default.useEffect(() => (m8.itemMap.set(f12, __spreadValues({ ref: f12 }, i9)), () => {
      m8.itemMap.delete(f12);
    })), /* @__PURE__ */ import_react57.default.createElement(Slot, { [d8]: "", ref: u5 }, l10);
  });
  return [{ Provider: u4, Slot: s8, ItemSlot: R5 }, function(e12) {
    const r13 = a9(c7 + "CollectionConsumer", e12);
    return import_react57.default.useCallback(() => {
      const e13 = r13.collectionRef.current;
      if (!e13)
        return [];
      const t14 = Array.from(e13.querySelectorAll(`[${d8}]`));
      return Array.from(r13.itemMap.values()).sort((e14, r14) => t14.indexOf(e14.ref.current) - t14.indexOf(r14.ref.current));
    }, [r13.collectionRef, r13.itemMap]);
  }, i8];
}

// ../../node_modules/@radix-ui/primitive/dist/index.module.js
function composeEventHandlers(e12, n6, { checkForDefaultPrevented: t14 = true } = {}) {
  return function(r13) {
    if (e12 == null || e12(r13), t14 === false || !r13.defaultPrevented)
      return n6 == null ? void 0 : n6(r13);
  };
}

// ../../node_modules/@radix-ui/react-roving-focus/dist/index.module.js
var a3 = __toModule(require_react());
var f3 = { bubbles: false, cancelable: true };
var [p2, l4, m2] = createCollection("RovingFocusGroup");
var [d2, v2] = createContextScope("RovingFocusGroup", [m2]);
var [g2, F2] = d2("RovingFocusGroup");
var RovingFocusGroup = /* @__PURE__ */ a3.forwardRef((e12, o13) => /* @__PURE__ */ a3.createElement(p2.Provider, { scope: e12.__scopeRovingFocusGroup }, /* @__PURE__ */ a3.createElement(p2.Slot, { scope: e12.__scopeRovingFocusGroup }, /* @__PURE__ */ a3.createElement(w2, _extends3({}, e12, { ref: o13 })))));
var w2 = /* @__PURE__ */ a3.forwardRef((t14, n6) => {
  const _a2 = t14, { __scopeRovingFocusGroup: c7, orientation: p7, dir: m7 = "ltr", loop: d8 = false, currentTabStopId: v6, defaultCurrentTabStopId: F5, onCurrentTabStopIdChange: w6, onEntryFocus: b7 } = _a2, x5 = __objRest(_a2, ["__scopeRovingFocusGroup", "orientation", "dir", "loop", "currentTabStopId", "defaultCurrentTabStopId", "onCurrentTabStopIdChange", "onEntryFocus"]), E6 = a3.useRef(null), I3 = useComposedRefs(n6, E6), [G4 = null, h3] = useControllableState({ prop: v6, defaultProp: F5, onChange: w6 }), [T5, A4] = a3.useState(false), y4 = useCallbackRef(b7), D7 = l4(c7), S3 = a3.useRef(false);
  return a3.useEffect(() => {
    const e12 = E6.current;
    if (e12)
      return e12.addEventListener("rovingFocusGroup.onEntryFocus", y4), () => e12.removeEventListener("rovingFocusGroup.onEntryFocus", y4);
  }, [y4]), /* @__PURE__ */ a3.createElement(g2, { scope: c7, orientation: p7, dir: m7, loop: d8, currentTabStopId: G4, onItemFocus: a3.useCallback((e12) => h3(e12), [h3]), onItemShiftTab: a3.useCallback(() => A4(true), []) }, /* @__PURE__ */ a3.createElement(Primitive.div, _extends3({ tabIndex: T5 ? -1 : 0, "aria-orientation": p7, "data-orientation": p7 }, x5, { ref: I3, style: __spreadValues({ outline: "none" }, t14.style), onMouseDown: composeEventHandlers(t14.onMouseDown, () => {
    S3.current = true;
  }), onFocus: composeEventHandlers(t14.onFocus, (e12) => {
    const o13 = !S3.current;
    if (e12.target === e12.currentTarget && o13 && !T5) {
      const o14 = new Event("rovingFocusGroup.onEntryFocus", f3);
      if (e12.currentTarget.dispatchEvent(o14), !o14.defaultPrevented) {
        const e13 = D7().filter((e14) => e14.focusable);
        R2([e13.find((e14) => e14.active), e13.find((e14) => e14.id === G4), ...e13].filter(Boolean).map((e14) => e14.ref.current));
      }
    }
    S3.current = false;
  }), onBlur: composeEventHandlers(t14.onBlur, () => A4(false)) })));
});
var RovingFocusGroupItem = /* @__PURE__ */ a3.forwardRef((e12, o13) => {
  const _a2 = e12, { __scopeRovingFocusGroup: n6, focusable: i8 = true, active: c7 = false } = _a2, f11 = __objRest(_a2, ["__scopeRovingFocusGroup", "focusable", "active"]), m7 = useId(), d8 = F2("RovingFocusGroupItem", n6), v6 = d8.currentTabStopId === m7, g5 = l4(n6);
  return a3.createElement(p2.ItemSlot, { scope: n6, id: m7, focusable: i8, active: c7 }, /* @__PURE__ */ a3.createElement(Primitive.span, _extends3({ tabIndex: v6 ? 0 : -1, "data-orientation": d8.orientation }, f11, { ref: o13, onMouseDown: composeEventHandlers(e12.onMouseDown, (e13) => {
    i8 ? d8.onItemFocus(m7) : e13.preventDefault();
  }), onFocus: composeEventHandlers(e12.onFocus, () => d8.onItemFocus(m7)), onKeyDown: composeEventHandlers(e12.onKeyDown, (e13) => {
    if (e13.key === "Tab" && e13.shiftKey)
      return void d8.onItemShiftTab();
    if (e13.target !== e13.currentTarget)
      return;
    const o14 = function(e14, o15, r14) {
      const t15 = function(e15, o16) {
        return o16 !== "rtl" ? e15 : e15 === "ArrowLeft" ? "ArrowRight" : e15 === "ArrowRight" ? "ArrowLeft" : e15;
      }(e14.key, r14);
      return o15 === "vertical" && ["ArrowLeft", "ArrowRight"].includes(t15) || o15 === "horizontal" && ["ArrowUp", "ArrowDown"].includes(t15) ? void 0 : b2[t15];
    }(e13, d8.orientation, d8.dir);
    if (o14 !== void 0) {
      e13.preventDefault();
      let n7 = g5().filter((e14) => e14.focusable).map((e14) => e14.ref.current);
      if (o14 === "last")
        n7.reverse();
      else if (o14 === "prev" || o14 === "next") {
        o14 === "prev" && n7.reverse();
        const i9 = n7.indexOf(e13.currentTarget);
        n7 = d8.loop ? (t14 = i9 + 1, (r13 = n7).map((e14, o15) => r13[(t14 + o15) % r13.length])) : n7.slice(i9 + 1);
      }
      setTimeout(() => R2(n7));
    }
    var r13, t14;
  }) })));
});
var b2 = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" };
function R2(e12) {
  const o13 = document.activeElement;
  for (const r13 of e12) {
    if (r13 === o13)
      return;
    if (r13.focus(), document.activeElement !== o13)
      return;
  }
}
var Root = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.module.js
var o7 = __toModule(require_react());
var useLayoutEffect6 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? o7.useLayoutEffect : () => {
};

// ../../node_modules/@radix-ui/react-portal/dist/index.module.js
var import_react_dom2 = __toModule(require_react_dom());
var r4 = __toModule(require_react());
var Portal = /* @__PURE__ */ r4.forwardRef((i8, a9) => {
  var d8, n6;
  const _a2 = i8, { containerRef: m7, style: s8 } = _a2, u4 = __objRest(_a2, ["containerRef", "style"]), c7 = (d8 = m7 == null ? void 0 : m7.current) !== null && d8 !== void 0 ? d8 : globalThis === null || globalThis === void 0 || (n6 = globalThis.document) === null || n6 === void 0 ? void 0 : n6.body, [, f11] = r4.useState({});
  return useLayoutEffect6(() => {
    f11({});
  }, []), c7 ? /* @__PURE__ */ import_react_dom2.default.createPortal(/* @__PURE__ */ r4.createElement(Primitive.div, _extends3({ "data-radix-portal": "" }, u4, { ref: a9, style: c7 === document.body ? __spreadValues({ position: "absolute", top: 0, left: 0, zIndex: 2147483647 }, s8) : void 0 })), c7) : null;
});

// ../../node_modules/@radix-ui/react-arrow/dist/index.module.js
var r5 = __toModule(require_react());
var Arrow = /* @__PURE__ */ r5.forwardRef((o13, i8) => {
  const _a2 = o13, { children: n6, width: s8 = 10, height: m7 = 5 } = _a2, p7 = __objRest(_a2, ["children", "width", "height"]);
  return r5.createElement(Primitive.svg, _extends3({}, p7, { ref: i8, width: s8, height: m7, viewBox: "0 0 30 10", preserveAspectRatio: "none" }), o13.asChild ? n6 : /* @__PURE__ */ r5.createElement("polygon", { points: "0,0 30,0 15,10" }));
});
var Root2 = Arrow;

// ../../node_modules/@radix-ui/react-use-size/dist/index.module.js
var e7 = __toModule(require_react());
function useSize(r13) {
  const [i8, t14] = e7.useState(void 0);
  return e7.useEffect(() => {
    if (r13) {
      const e12 = new ResizeObserver((e13) => {
        if (!Array.isArray(e13))
          return;
        if (!e13.length)
          return;
        const i9 = e13[0];
        let o13, n6;
        if ("borderBoxSize" in i9) {
          const e14 = i9.borderBoxSize, r14 = Array.isArray(e14) ? e14[0] : e14;
          o13 = r14.inlineSize, n6 = r14.blockSize;
        } else {
          const e14 = r13.getBoundingClientRect();
          o13 = e14.width, n6 = e14.height;
        }
        t14({ width: o13, height: n6 });
      });
      return e12.observe(r13, { box: "border-box" }), () => {
        t14(void 0), e12.unobserve(r13);
      };
    }
  }, [r13]), i8;
}

// ../../node_modules/@radix-ui/rect/dist/index.module.js
function observeElementRect(n6, o13) {
  const i8 = e8.get(n6);
  return i8 === void 0 ? (e8.set(n6, { rect: {}, callbacks: [o13] }), e8.size === 1 && (t7 = requestAnimationFrame(c2))) : (i8.callbacks.push(o13), o13(n6.getBoundingClientRect())), () => {
    const c7 = e8.get(n6);
    if (c7 === void 0)
      return;
    const i9 = c7.callbacks.indexOf(o13);
    i9 > -1 && c7.callbacks.splice(i9, 1), c7.callbacks.length === 0 && (e8.delete(n6), e8.size === 0 && cancelAnimationFrame(t7));
  };
}
var t7;
var e8 = new Map();
function c2() {
  const n6 = [];
  e8.forEach((t14, e12) => {
    const c7 = e12.getBoundingClientRect();
    var o13, i8;
    o13 = t14.rect, i8 = c7, (o13.width !== i8.width || o13.height !== i8.height || o13.top !== i8.top || o13.right !== i8.right || o13.bottom !== i8.bottom || o13.left !== i8.left) && (t14.rect = c7, n6.push(t14));
  }), n6.forEach((t14) => {
    t14.callbacks.forEach((e12) => e12(t14.rect));
  }), t7 = requestAnimationFrame(c2);
}

// ../../node_modules/@radix-ui/react-use-rect/dist/index.module.js
var r6 = __toModule(require_react());
function useRect(e12) {
  const [o13, c7] = r6.useState();
  return r6.useEffect(() => {
    if (e12) {
      const r13 = observeElementRect(e12, c7);
      return () => {
        c7(void 0), r13();
      };
    }
  }, [e12]), o13;
}

// ../../node_modules/@radix-ui/popper/dist/index.module.js
function getPlacementData({ anchorRect: p7, popperSize: c7, arrowSize: f11, arrowOffset: l9 = 0, side: d8, sideOffset: h3 = 0, align: x5, alignOffset: g5 = 0, shouldAvoidCollisions: u4 = true, collisionBoundariesRect: w6, collisionTolerance: m7 = 0 }) {
  if (!p7 || !c7 || !w6)
    return { popperStyles: o8, arrowStyles: n4 };
  const y4 = function(e12, r13, o13 = 0, n6 = 0, i8) {
    const p8 = i8 ? i8.height : 0, a9 = t8(r13, e12, "x"), s8 = t8(r13, e12, "y"), c8 = s8.before - o13 - p8, f12 = s8.after + o13 + p8, l10 = a9.before - o13 - p8, d9 = a9.after + o13 + p8;
    return { top: { start: { x: a9.start + n6, y: c8 }, center: { x: a9.center, y: c8 }, end: { x: a9.end - n6, y: c8 } }, right: { start: { x: d9, y: s8.start + n6 }, center: { x: d9, y: s8.center }, end: { x: d9, y: s8.end - n6 } }, bottom: { start: { x: a9.start + n6, y: f12 }, center: { x: a9.center, y: f12 }, end: { x: a9.end - n6, y: f12 } }, left: { start: { x: l10, y: s8.start + n6 }, center: { x: l10, y: s8.center }, end: { x: l10, y: s8.end - n6 } } };
  }(c7, p7, h3, g5, f11), b7 = y4[d8][x5];
  if (u4 === false) {
    const t14 = e9(b7);
    let o13 = n4;
    f11 && (o13 = i3({ popperSize: c7, arrowSize: f11, arrowOffset: l9, side: d8, align: x5 }));
    return { popperStyles: __spreadProps(__spreadValues({}, t14), { "--radix-popper-transform-origin": r7(c7, d8, x5, l9, f11) }), arrowStyles: o13, placedSide: d8, placedAlign: x5 };
  }
  const S3 = DOMRect.fromRect(__spreadValues(__spreadValues({}, c7), b7)), $2 = (O5 = w6, z3 = m7, DOMRect.fromRect({ width: O5.width - 2 * z3, height: O5.height - 2 * z3, x: O5.left + z3, y: O5.top + z3 }));
  var O5, z3;
  const R5 = s2(S3, $2), M4 = y4[a4(d8)][x5], D7 = function(t14, e12, r13) {
    const o13 = a4(t14);
    return e12[t14] && !r13[o13] ? o13 : t14;
  }(d8, R5, s2(DOMRect.fromRect(__spreadValues(__spreadValues({}, c7), M4)), $2)), A4 = function(t14, e12, r13, o13, n6) {
    const i8 = r13 === "top" || r13 === "bottom", p8 = i8 ? "left" : "top", a9 = i8 ? "right" : "bottom", s8 = i8 ? "width" : "height", c8 = e12[s8] > t14[s8];
    if ((o13 === "start" || o13 === "center") && (n6[p8] && c8 || n6[a9] && !c8))
      return "end";
    if ((o13 === "end" || o13 === "center") && (n6[a9] && c8 || n6[p8] && !c8))
      return "start";
    return o13;
  }(c7, p7, d8, x5, R5), I3 = e9(y4[D7][A4]);
  let C6 = n4;
  f11 && (C6 = i3({ popperSize: c7, arrowSize: f11, arrowOffset: l9, side: D7, align: A4 }));
  return { popperStyles: __spreadProps(__spreadValues({}, I3), { "--radix-popper-transform-origin": r7(c7, D7, A4, l9, f11) }), arrowStyles: C6, placedSide: D7, placedAlign: A4 };
}
function t8(t14, e12, r13) {
  const o13 = t14[r13 === "x" ? "left" : "top"], n6 = r13 === "x" ? "width" : "height", i8 = t14[n6], p7 = e12[n6];
  return { before: o13 - p7, start: o13, center: o13 + (i8 - p7) / 2, end: o13 + i8 - p7, after: o13 + i8 };
}
function e9(t14) {
  return { position: "absolute", top: 0, left: 0, minWidth: "max-content", willChange: "transform", transform: `translate3d(${Math.round(t14.x + window.scrollX)}px, ${Math.round(t14.y + window.scrollY)}px, 0)` };
}
function r7(t14, e12, r13, o13, n6) {
  const i8 = e12 === "top" || e12 === "bottom", p7 = n6 ? n6.width : 0, a9 = n6 ? n6.height : 0, s8 = p7 / 2 + o13;
  let c7 = "", f11 = "";
  return i8 ? (c7 = { start: `${s8}px`, center: "center", end: t14.width - s8 + "px" }[r13], f11 = e12 === "top" ? `${t14.height + a9}px` : -a9 + "px") : (c7 = e12 === "left" ? `${t14.width + a9}px` : -a9 + "px", f11 = { start: `${s8}px`, center: "center", end: t14.height - s8 + "px" }[r13]), `${c7} ${f11}`;
}
var o8 = { position: "fixed", top: 0, left: 0, opacity: 0, transform: "translate3d(0, -200%, 0)" };
var n4 = { position: "absolute", opacity: 0 };
function i3({ popperSize: t14, arrowSize: e12, arrowOffset: r13, side: o13, align: n6 }) {
  const i8 = (t14.width - e12.width) / 2, a9 = (t14.height - e12.width) / 2, s8 = { top: 0, right: 90, bottom: 180, left: -90 }[o13], c7 = Math.max(e12.width, e12.height), f11 = { width: `${c7}px`, height: `${c7}px`, transform: `rotate(${s8}deg)`, willChange: "transform", position: "absolute", [o13]: "100%", direction: p3(o13, n6) };
  return o13 !== "top" && o13 !== "bottom" || (n6 === "start" && (f11.left = `${r13}px`), n6 === "center" && (f11.left = `${i8}px`), n6 === "end" && (f11.right = `${r13}px`)), o13 !== "left" && o13 !== "right" || (n6 === "start" && (f11.top = `${r13}px`), n6 === "center" && (f11.top = `${a9}px`), n6 === "end" && (f11.bottom = `${r13}px`)), f11;
}
function p3(t14, e12) {
  return (t14 !== "top" && t14 !== "right" || e12 !== "end") && (t14 !== "bottom" && t14 !== "left" || e12 === "end") ? "ltr" : "rtl";
}
function a4(t14) {
  return { top: "bottom", right: "left", bottom: "top", left: "right" }[t14];
}
function s2(t14, e12) {
  return { top: t14.top < e12.top, right: t14.right > e12.right, bottom: t14.bottom > e12.bottom, left: t14.left < e12.left };
}

// ../../node_modules/@radix-ui/react-popper/dist/index.module.js
var s3 = __toModule(require_react());
var [c3, l5] = createContextScope("Popper");
var [f4, d3] = c3("Popper");
var Popper = (e12) => {
  const { __scopePopper: o13, children: r13 } = e12, [t14, n6] = s3.useState(null);
  return s3.createElement(f4, { scope: o13, anchor: t14, onAnchorChange: n6 }, r13);
};
var PopperAnchor = /* @__PURE__ */ s3.forwardRef((e12, r13) => {
  const _a2 = e12, { __scopePopper: t14, virtualRef: n6 } = _a2, p7 = __objRest(_a2, ["__scopePopper", "virtualRef"]), c7 = d3("PopperAnchor", t14), l9 = s3.useRef(null), f11 = useComposedRefs(r13, l9);
  return s3.useEffect(() => {
    c7.onAnchorChange((n6 == null ? void 0 : n6.current) || l9.current);
  }), n6 ? null : /* @__PURE__ */ s3.createElement(Primitive.div, _extends3({}, p7, { ref: f11 }));
});
var [u2, m3] = c3("PopperContent");
var PopperContent = /* @__PURE__ */ s3.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopePopper: c7, side: l9 = "bottom", sideOffset: f11, align: m7 = "center", alignOffset: w6, collisionTolerance: h3, avoidCollisions: x5 = true } = _a2, v6 = __objRest(_a2, ["__scopePopper", "side", "sideOffset", "align", "alignOffset", "collisionTolerance", "avoidCollisions"]), P3 = d3("PopperContent", c7), [A4, g5] = s3.useState(), E6 = useRect(P3.anchor), [y4, C6] = s3.useState(null), S3 = useSize(y4), [R5, O5] = s3.useState(null), _18 = useSize(R5), b7 = useComposedRefs(n6, (e13) => C6(e13)), z3 = function() {
    const [e13, o13] = s3.useState(void 0);
    return s3.useEffect(() => {
      let e14;
      function r13() {
        o13({ width: window.innerWidth, height: window.innerHeight });
      }
      function t14() {
        window.clearTimeout(e14), e14 = window.setTimeout(r13, 100);
      }
      return r13(), window.addEventListener("resize", t14), () => window.removeEventListener("resize", t14);
    }, []), e13;
  }(), T5 = z3 ? DOMRect.fromRect(__spreadProps(__spreadValues({}, z3), { x: 0, y: 0 })) : void 0, { popperStyles: k3, arrowStyles: L4, placedSide: B3, placedAlign: D7 } = getPlacementData({ anchorRect: E6, popperSize: S3, arrowSize: _18, arrowOffset: A4, side: l9, sideOffset: f11, align: m7, alignOffset: w6, shouldAvoidCollisions: x5, collisionBoundariesRect: T5, collisionTolerance: h3 }), H3 = B3 !== void 0;
  return s3.createElement("div", { style: k3, "data-radix-popper-content-wrapper": "" }, /* @__PURE__ */ s3.createElement(u2, { scope: c7, arrowStyles: L4, onArrowChange: O5, onArrowOffsetChange: g5 }, /* @__PURE__ */ s3.createElement(Primitive.div, _extends3({ "data-side": B3, "data-align": D7 }, v6, { style: __spreadProps(__spreadValues({}, v6.style), { animation: H3 ? void 0 : "none" }), ref: b7 }))));
});
var PopperArrow = /* @__PURE__ */ s3.forwardRef(function(o13, r13) {
  const _a2 = o13, { __scopePopper: t14, offset: n6 } = _a2, i8 = __objRest(_a2, ["__scopePopper", "offset"]), p7 = m3("PopperArrow", t14), { onArrowOffsetChange: c7 } = p7;
  return s3.useEffect(() => c7(n6), [c7, n6]), /* @__PURE__ */ s3.createElement("span", { style: __spreadProps(__spreadValues({}, p7.arrowStyles), { pointerEvents: "none" }) }, /* @__PURE__ */ s3.createElement("span", { ref: p7.onArrowChange, style: { display: "inline-block", verticalAlign: "top", pointerEvents: "auto" } }, /* @__PURE__ */ s3.createElement(Root2, _extends3({}, i8, { ref: r13, style: __spreadProps(__spreadValues({}, i8.style), { display: "block" }) }))));
});
var Root3 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

// ../../node_modules/@radix-ui/react-presence/dist/index.module.js
var t9 = __toModule(require_react());
var Presence = (u4) => {
  const { present: o13, children: i8 } = u4, s8 = function(n6) {
    const [u5, o14] = t9.useState(), i9 = t9.useRef({}), s9 = t9.useRef(n6), c8 = t9.useRef("none"), a10 = n6 ? "mounted" : "unmounted", [d8, m7] = function(e12, n7) {
      return t9.useReducer((e13, t14) => {
        const r13 = n7[e13][t14];
        return r13 != null ? r13 : e13;
      }, e12);
    }(a10, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } });
    return t9.useEffect(() => {
      const e12 = r8(i9.current);
      c8.current = d8 === "mounted" ? e12 : "none";
    }, [d8]), useLayoutEffect6(() => {
      const e12 = i9.current, t14 = s9.current;
      if (t14 !== n6) {
        const u6 = c8.current, o15 = r8(e12);
        if (n6)
          m7("MOUNT");
        else if (o15 === "none" || (e12 == null ? void 0 : e12.display) === "none")
          m7("UNMOUNT");
        else {
          const e13 = u6 !== o15;
          m7(t14 && e13 ? "ANIMATION_OUT" : "UNMOUNT");
        }
        s9.current = n6;
      }
    }, [n6, m7]), useLayoutEffect6(() => {
      if (u5) {
        const e12 = (e13) => {
          const n8 = r8(i9.current).includes(e13.animationName);
          e13.target === u5 && n8 && m7("ANIMATION_END");
        }, n7 = (e13) => {
          e13.target === u5 && (c8.current = r8(i9.current));
        };
        return u5.addEventListener("animationstart", n7), u5.addEventListener("animationcancel", e12), u5.addEventListener("animationend", e12), () => {
          u5.removeEventListener("animationstart", n7), u5.removeEventListener("animationcancel", e12), u5.removeEventListener("animationend", e12);
        };
      }
    }, [u5, m7]), { isPresent: ["mounted", "unmountSuspended"].includes(d8), ref: t9.useCallback((e12) => {
      e12 && (i9.current = getComputedStyle(e12)), o14(e12);
    }, []) };
  }(o13), c7 = typeof i8 == "function" ? i8({ present: s8.isPresent }) : t9.Children.only(i8), a9 = useComposedRefs(s8.ref, c7.ref);
  return typeof i8 == "function" || s8.isPresent ? /* @__PURE__ */ t9.cloneElement(c7, { ref: a9 }) : null;
};
function r8(e12) {
  return (e12 == null ? void 0 : e12.animationName) || "none";
}
Presence.displayName = "Presence";

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.module.js
var o9 = __toModule(require_react());
var c4 = { bubbles: false, cancelable: true };
var FocusScope = /* @__PURE__ */ o9.forwardRef((i8, f11) => {
  const _a2 = i8, { loop: l9 = false, trapped: m7 = false, onMountAutoFocus: p7, onUnmountAutoFocus: v6 } = _a2, E6 = __objRest(_a2, ["loop", "trapped", "onMountAutoFocus", "onUnmountAutoFocus"]), [F5, S3] = o9.useState(null), b7 = useCallbackRef(p7), T5 = useCallbackRef(v6), y4 = o9.useRef(null), L4 = useComposedRefs(f11, (e12) => S3(e12)), h3 = o9.useRef({ paused: false, pause() {
    this.paused = true;
  }, resume() {
    this.paused = false;
  } }).current;
  o9.useEffect(() => {
    if (m7) {
      let e12 = function(e13) {
        if (h3.paused || !F5)
          return;
        const t15 = e13.target;
        F5.contains(t15) ? y4.current = t15 : a5(y4.current, { select: true });
      }, t14 = function(e13) {
        !h3.paused && F5 && (F5.contains(e13.relatedTarget) || a5(y4.current, { select: true }));
      };
      return document.addEventListener("focusin", e12), document.addEventListener("focusout", t14), () => {
        document.removeEventListener("focusin", e12), document.removeEventListener("focusout", t14);
      };
    }
  }, [m7, F5, h3.paused]), o9.useEffect(() => {
    if (F5) {
      d4.add(h3);
      const e12 = document.activeElement;
      if (!F5.contains(e12)) {
        const t14 = new Event("focusScope.autoFocusOnMount", c4);
        F5.addEventListener("focusScope.autoFocusOnMount", b7), F5.dispatchEvent(t14), t14.defaultPrevented || (!function(e13, { select: t15 = false } = {}) {
          const n6 = document.activeElement;
          for (const o13 of e13)
            if (a5(o13, { select: t15 }), document.activeElement !== n6)
              return;
        }(r9(F5), { select: true }), document.activeElement === e12 && a5(F5));
      }
      return () => {
        F5.removeEventListener("focusScope.autoFocusOnMount", b7), setTimeout(() => {
          const t14 = new Event("focusScope.autoFocusOnUnmount", c4);
          F5.addEventListener("focusScope.autoFocusOnUnmount", T5), F5.dispatchEvent(t14), t14.defaultPrevented || a5(e12 != null ? e12 : document.body, { select: true }), F5.removeEventListener("focusScope.autoFocusOnUnmount", T5), d4.remove(h3);
        }, 0);
      };
    }
  }, [F5, b7, T5, h3]);
  const x5 = o9.useCallback((e12) => {
    if (!l9 && !m7)
      return;
    if (h3.paused)
      return;
    const t14 = e12.key === "Tab" && !e12.altKey && !e12.ctrlKey && !e12.metaKey, n6 = document.activeElement;
    if (t14 && n6) {
      const t15 = e12.currentTarget, [o13, u4] = function(e13) {
        const t16 = r9(e13), n7 = s4(t16, e13), o14 = s4(t16.reverse(), e13);
        return [n7, o14];
      }(t15);
      o13 && u4 ? e12.shiftKey || n6 !== u4 ? e12.shiftKey && n6 === o13 && (e12.preventDefault(), l9 && a5(u4, { select: true })) : (e12.preventDefault(), l9 && a5(o13, { select: true })) : n6 === t15 && e12.preventDefault();
    }
  }, [l9, m7, h3.paused]);
  return o9.createElement(Primitive.div, _extends3({ tabIndex: -1 }, E6, { ref: L4, onKeyDown: x5 }));
});
function r9(e12) {
  const t14 = [], n6 = document.createTreeWalker(e12, NodeFilter.SHOW_ELEMENT, { acceptNode: (e13) => {
    const t15 = e13.tagName === "INPUT" && e13.type === "hidden";
    return e13.disabled || e13.hidden || t15 ? NodeFilter.FILTER_SKIP : e13.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n6.nextNode(); )
    t14.push(n6.currentNode);
  return t14;
}
function s4(e12, t14) {
  for (const n6 of e12)
    if (!i4(n6, { upTo: t14 }))
      return n6;
}
function i4(e12, { upTo: t14 }) {
  if (getComputedStyle(e12).visibility === "hidden")
    return true;
  for (; e12; ) {
    if (t14 !== void 0 && e12 === t14)
      return false;
    if (getComputedStyle(e12).display === "none")
      return true;
    e12 = e12.parentElement;
  }
  return false;
}
function a5(e12, { select: t14 = false } = {}) {
  if (e12 && e12.focus) {
    const n6 = document.activeElement;
    e12.focus({ preventScroll: true }), e12 !== n6 && function(e13) {
      return e13 instanceof HTMLInputElement && "select" in e13;
    }(e12) && t14 && e12.select();
  }
}
var d4 = function() {
  let e12 = [];
  return { add(t14) {
    const n6 = e12[0];
    t14 !== n6 && (n6 == null || n6.pause()), e12 = f5(e12, t14), e12.unshift(t14);
  }, remove(t14) {
    var n6;
    e12 = f5(e12, t14), (n6 = e12[0]) === null || n6 === void 0 || n6.resume();
  } };
}();
function f5(e12, t14) {
  const n6 = [...e12], o13 = n6.indexOf(t14);
  return o13 !== -1 && n6.splice(o13, 1), n6;
}

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js
var t10 = __toModule(require_react());
function useEscapeKeydown(n6) {
  const o13 = useCallbackRef(n6);
  t10.useEffect(() => {
    const e12 = (e13) => {
      e13.key === "Escape" && o13(e13);
    };
    return document.addEventListener("keydown", e12), () => document.removeEventListener("keydown", e12);
  }, [o13]);
}

// ../../node_modules/@radix-ui/react-use-body-pointer-events/dist/index.module.js
var t11 = __toModule(require_react());
var n5;
var o10 = 0;
function useBodyPointerEvents({ disabled: r13 }) {
  const u4 = t11.useRef(false), c7 = t11.useRef(false);
  t11.useEffect(() => {
    const e12 = (e13) => {
      const t15 = e13.pointerType === "mouse";
      u4.current = !t15, c7.current = t15 && e13.button === 0;
    }, t14 = () => {
      u4.current = false, c7.current = false;
    };
    return document.addEventListener("pointerdown", e12), document.addEventListener("pointerup", t14), () => {
      document.removeEventListener("pointerdown", e12), document.removeEventListener("pointerup", t14);
    };
  }, []), useLayoutEffect6(() => {
    if (r13) {
      let e12 = function() {
        o10--, o10 === 0 && (document.body.style.pointerEvents = n5);
      };
      return o10 === 0 && (n5 = document.body.style.pointerEvents), document.body.style.pointerEvents = "none", o10++, () => {
        u4.current ? document.addEventListener("click", e12, { once: true }) : c7.current ? document.addEventListener("pointerup", e12, { once: true }) : e12();
      };
    }
  }, [r13]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
var i5 = __toModule(require_react());
var [a6, c5] = C2();
var [l6, d5] = b3();
var [m4, f6] = C2("TotalLayerCountWithDisabledOutsidePointerEventsProvider");
var [p4, v3] = b3("RunningLayerCountWithDisabledOutsidePointerEventsProvider");
var DismissableLayer = /* @__PURE__ */ i5.forwardRef((e12, t14) => {
  const n6 = d5() === 0, r13 = /* @__PURE__ */ i5.createElement(E2, _extends3({}, e12, { ref: t14 }));
  return n6 ? /* @__PURE__ */ i5.createElement(a6, null, /* @__PURE__ */ i5.createElement(m4, null, r13)) : r13;
});
var E2 = /* @__PURE__ */ i5.forwardRef((r13, a9) => {
  const _a2 = r13, { disableOutsidePointerEvents: m7 = false, onEscapeKeyDown: E6, onPointerDownOutside: C6, onFocusOutside: b7, onInteractOutside: w6, onDismiss: L4 } = _a2, y4 = __objRest(_a2, ["disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss"]), D7 = c5(), P3 = d5() + 1, T5 = P3 === D7, g5 = f6(m7), x5 = v3() + (m7 ? 1 : 0), O5 = x5 < g5;
  useBodyPointerEvents({ disabled: m7 }), useEscapeKeydown((e12) => {
    T5 && (E6 == null || E6(e12), e12.defaultPrevented || L4 == null || L4());
  });
  const { onPointerDownCapture: R5 } = function(e12) {
    const n6 = useCallbackRef(e12), r14 = i5.useRef(false);
    return i5.useEffect(() => {
      const e13 = (e14) => {
        const t15 = e14.target;
        if (t15 && !r14.current) {
          const r15 = new CustomEvent("dismissableLayer.pointerDownOutside", { bubbles: false, cancelable: true, detail: { originalEvent: e14 } });
          t15.addEventListener("dismissableLayer.pointerDownOutside", n6, { once: true }), t15.dispatchEvent(r15);
        }
        r14.current = false;
      }, t14 = window.setTimeout(() => {
        document.addEventListener("pointerdown", e13);
      }, 0);
      return () => {
        window.clearTimeout(t14), document.removeEventListener("pointerdown", e13);
      };
    }, [n6]), { onPointerDownCapture: () => r14.current = true };
  }((e12) => {
    O5 || (C6 == null || C6(e12), w6 == null || w6(e12), e12.defaultPrevented || L4 == null || L4());
  }), { onBlurCapture: h3, onFocusCapture: F5 } = function(e12) {
    const n6 = useCallbackRef(e12), r14 = i5.useRef(false);
    return i5.useEffect(() => {
      const e13 = (e14) => {
        const t14 = e14.target;
        if (t14 && !r14.current) {
          const r15 = new CustomEvent("dismissableLayer.focusOutside", { bubbles: false, cancelable: true, detail: { originalEvent: e14 } });
          t14.addEventListener("dismissableLayer.focusOutside", n6, { once: true }), t14.dispatchEvent(r15);
        }
      };
      return document.addEventListener("focusin", e13), () => document.removeEventListener("focusin", e13);
    }, [n6]), { onFocusCapture: () => r14.current = true, onBlurCapture: () => r14.current = false };
  }((e12) => {
    b7 == null || b7(e12), w6 == null || w6(e12), e12.defaultPrevented || L4 == null || L4();
  }), k3 = g5 > 0 && !O5;
  return i5.createElement(l6, { runningCount: P3 }, /* @__PURE__ */ i5.createElement(p4, { runningCount: x5 }, /* @__PURE__ */ i5.createElement(Primitive.div, _extends3({}, y4, { ref: a9, style: __spreadValues({ pointerEvents: k3 ? "auto" : void 0 }, y4.style), onPointerDownCapture: composeEventHandlers(r13.onPointerDownCapture, R5), onBlurCapture: composeEventHandlers(r13.onBlurCapture, h3), onFocusCapture: composeEventHandlers(r13.onFocusCapture, F5) }))));
});
function C2(e12) {
  const [t14, n6] = createContext3("TotalLayerCount", { total: 0, onTotalIncrease: () => {
  }, onTotalDecrease: () => {
  } }), o13 = ({ children: e13 }) => {
    const [n7, r13] = i5.useState(0);
    return i5.createElement(t14, { total: n7, onTotalIncrease: i5.useCallback(() => r13((e14) => e14 + 1), []), onTotalDecrease: i5.useCallback(() => r13((e14) => e14 - 1), []) }, e13);
  };
  return [o13, function(e13 = true) {
    const { total: t15, onTotalIncrease: r13, onTotalDecrease: o14 } = n6("TotalLayerCountConsumer");
    return i5.useLayoutEffect(() => {
      if (e13)
        return r13(), () => o14();
    }, [e13, r13, o14]), t15;
  }];
}
function b3(e12) {
  const [t14, n6] = createContext3("RunningLayerCount", { count: 0 }), o13 = (e13) => {
    const { children: n7, runningCount: r13 } = e13;
    return i5.createElement(t14, { count: r13 }, n7);
  };
  return [o13, function() {
    return n6("RunningLayerCountConsumer").count || 0;
  }];
}

// ../../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (parentNode === void 0) {
    parentNode = getDefaultParent(originalTarget);
  }
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
  if (!markerMap[markerName]) {
    markerMap[markerName] = new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = new Set();
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || targets.indexOf(parent) >= 0) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        var attr = node.getAttribute("aria-hidden");
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node) || 0) + 1;
        var markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute("aria-hidden", "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute("aria-hidden");
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = new WeakMap();
      counterMap = new WeakMap();
      uncontrolledNodes = new WeakMap();
      markerMap = {};
    }
  };
};

// ../../node_modules/react-remove-scroll/node_modules/tslib/modules/index.js
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign: __assign2,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values: __values2,
  __read: __read2,
  __spread,
  __spreadArrays,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var React8 = __toModule(require_react());

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var React4 = __toModule(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/use-sidecar/node_modules/tslib/modules/index.js
var import_tslib2 = __toModule(require_tslib2());
var {
  __extends: __extends2,
  __assign: __assign3,
  __rest: __rest2,
  __decorate: __decorate2,
  __param: __param2,
  __metadata: __metadata2,
  __awaiter: __awaiter2,
  __generator: __generator2,
  __exportStar: __exportStar2,
  __createBinding: __createBinding2,
  __values: __values3,
  __read: __read3,
  __spread: __spread2,
  __spreadArrays: __spreadArrays2,
  __await: __await2,
  __asyncGenerator: __asyncGenerator2,
  __asyncDelegator: __asyncDelegator2,
  __asyncValues: __asyncValues2,
  __makeTemplateObject: __makeTemplateObject2,
  __importStar: __importStar2,
  __importDefault: __importDefault2,
  __classPrivateFieldGet: __classPrivateFieldGet2,
  __classPrivateFieldSet: __classPrivateFieldSet2
} = import_tslib2.default;

// ../../node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a9) {
  return a9;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x5) {
          return x5 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x5) {
          return cb(x5);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x5) {
          pendingQueue.push(x5);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign3({ async: true, ssr: false }, options2);
  return medium;
}

// ../../node_modules/use-sidecar/dist/es2015/exports.js
var React3 = __toModule(require_react());
var SideCar = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest2(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React3.createElement(Target, __assign3({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react58 = __toModule(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react58.useState)(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
function useMergeRefs(refs, defaultValue) {
  return useCallbackRef2(defaultValue, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React4.forwardRef(function(props, parentRef) {
  var ref = React4.useRef(null);
  var _a2 = React4.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container3 = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([
    ref,
    parentRef
  ]);
  var containerProps = __assign2({}, rest, callbacks);
  return React4.createElement(React4.Fragment, null, enabled && React4.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }), forwardProps ? React4.cloneElement(React4.Children.only(children), __assign2({}, containerProps, { ref: containerRef })) : React4.createElement(Container3, __assign2({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React7 = __toModule(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React6 = __toModule(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var React5 = __toModule(require_react());

// ../../node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles3) {
    React5.useEffect(function() {
      sheet.add(styles3);
      return function() {
        sheet.remove();
      };
    }, []);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles3 = _a2.styles;
    useStyle2(styles3);
    return null;
  };
  return Sheet;
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x5) {
  return parseInt(x5 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [
    parse2(left),
    parse2(top2),
    parse2(right)
  ];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top2 = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  ." + noScrollbarsClassName + " {\n   overflow: hidden " + important + ";\n   padding-right: " + gap + "px " + important + ";\n  }\n  body {\n    overflow: hidden " + important + ";\n    " + [
    allowRelative && "position: relative " + important + ";",
    gapMode === "margin" && "\n    padding-left: " + left + "px;\n    padding-top: " + top2 + "px;\n    padding-right: " + right + "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: " + gap + "px " + important + ";\n    ",
    gapMode === "padding" && "padding-right: " + gap + "px " + important + ";"
  ].filter(Boolean).join("") + "\n  }\n  \n  ." + zeroRightClassName + " {\n    right: " + gap + "px " + important + ";\n  }\n  \n  ." + fullWidthClassName + " {\n    margin-right: " + gap + "px " + important + ";\n  }\n  \n  ." + zeroRightClassName + " ." + zeroRightClassName + " {\n    right: 0 " + important + ";\n  }\n  \n  ." + fullWidthClassName + " ." + fullWidthClassName + " {\n    margin-right: 0 " + important + ";\n  }\n  \n  body {\n    " + removedBarSizeVariable + ": " + gap + "px;\n  }\n";
};
var RemoveScrollBar = function(props) {
  var _a2 = React6.useState(getGapWidth(props.gapMode)), gap = _a2[0], setGap = _a2[1];
  React6.useEffect(function() {
    setGap(getGapWidth(props.gapMode));
  }, [props.gapMode]);
  var noRelative = props.noRelative, noImportant = props.noImportant, _b = props.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  return React6.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var elementCouldBeVScrolled = function(node) {
  var styles3 = window.getComputedStyle(node);
  return styles3.overflowY !== "hidden" && !(styles3.overflowY === styles3.overflowX && styles3.overflowY === "visible");
};
var elementCouldBeHScrolled = function(node) {
  var styles3 = window.getComputedStyle(node);
  if (node.type === "range") {
    return true;
  }
  return styles3.overflowX !== "hidden" && !(styles3.overflowY === styles3.overflowX && styles3.overflowX === "visible");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), s8 = _a2[1], d8 = _a2[2];
      if (s8 > d8) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [scrollTop, scrollHeight, clientHeight];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [scrollLeft, scrollWidth, clientWidth];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var delta = sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options2 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options2, options2);
    window.removeEventListener("test", options2, options2);
  } catch (err) {
    passiveSupported = false;
  }
}
var options2;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x5, y4) {
  return x5[0] === y4[0] && x5[1] === y4[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-" + id + " {pointer-events: none;}\n  .allow-interactivity-" + id + " {pointer-events: all;}\n";
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React7.useRef([]);
  var touchStartRef = React7.useRef([0, 0]);
  var activeAxis = React7.useRef();
  var id = React7.useState(idCounter++)[0];
  var Style2 = React7.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React7.useRef(props);
  React7.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React7.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-" + id);
      var allow_1 = [
        props.lockRef.current
      ].concat((props.shards || []).map(extractRef)).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-" + id);
      });
      return function() {
        document.body.classList.remove("block-interactivity-" + id);
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-" + id);
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React7.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React7.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e12) {
      return e12.name === event.type && e12.target === event.target && deltaCompare(e12.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      event.preventDefault();
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        event.preventDefault();
      }
    }
  }, []);
  var shouldCancel = React7.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e12) {
        return e12 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React7.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React7.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React7.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React7.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React7.createElement(React7.Fragment, null, inert ? React7.createElement(Style2, { styles: generateStyle(id) }) : null, removeScrollBar ? React7.createElement(RemoveScrollBar, { gapMode: "margin" }) : null);
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React8.forwardRef(function(props, ref) {
  return React8.createElement(RemoveScroll, __assign2({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/@radix-ui/react-menu/dist/index.module.js
var E3 = __toModule(require_react());
var x2 = ["Enter", " "];
var b4 = ["ArrowUp", "PageDown", "End"];
var R3 = ["ArrowDown", "PageUp", "Home", ...b4];
var _15 = { ltr: [...x2, "ArrowRight"], rtl: [...x2, "ArrowLeft"] };
var y2 = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] };
var [I2, k2, P2] = createCollection("Menu");
var [D2, S2] = createContextScope("Menu", [P2, l5, v2]);
var O2 = l5();
var T3 = v2();
var [L3, A2] = D2("Menu");
var Menu = (e12) => {
  const { __scopeMenu: t14, open: o13 = false, children: u4, onOpenChange: c7, modal: i8 = true } = e12, s8 = O2(t14), [l9, d8] = E3.useState(null), p7 = E3.useRef(false), f11 = useCallbackRef(c7), m7 = useDirection(l9, e12.dir);
  return E3.useEffect(() => {
    const e13 = () => p7.current = true, t15 = () => p7.current = false;
    return document.addEventListener("keydown", e13, { capture: true }), document.addEventListener("pointerdown", t15, { capture: true }), document.addEventListener("pointermove", t15, { capture: true }), () => {
      document.removeEventListener("keydown", e13, { capture: true }), document.removeEventListener("pointerdown", t15, { capture: true }), document.removeEventListener("pointermove", t15, { capture: true });
    };
  }, []), /* @__PURE__ */ E3.createElement(Root3, s8, /* @__PURE__ */ E3.createElement(L3, { scope: t14, isSubmenu: false, isUsingKeyboardRef: p7, dir: m7, open: o13, onOpenChange: f11, content: l9, onContentChange: d8, onRootClose: E3.useCallback(() => f11(false), [f11]), modal: i8 }, u4));
};
var MenuSub = (t14) => {
  const { __scopeMenu: r13, children: o13, open: u4 = false, onOpenChange: c7 } = t14, i8 = A2("MenuSub", r13), s8 = O2(r13), [l9, d8] = E3.useState(null), [p7, f11] = E3.useState(null), m7 = useCallbackRef(c7);
  return E3.useEffect(() => (i8.open === false && m7(false), () => m7(false)), [i8.open, m7]), /* @__PURE__ */ E3.createElement(Root3, s8, /* @__PURE__ */ E3.createElement(L3, { scope: r13, isSubmenu: true, isUsingKeyboardRef: i8.isUsingKeyboardRef, dir: i8.dir, open: u4, onOpenChange: m7, content: p7, onContentChange: f11, onRootClose: i8.onRootClose, contentId: useId(), trigger: l9, onTriggerChange: d8, triggerId: useId(), modal: false }, o13));
};
var MenuAnchor = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeMenu: n6 } = _a2, r13 = __objRest(_a2, ["__scopeMenu"]), o13 = O2(n6);
  return E3.createElement(Anchor, _extends3({}, o13, r13, { ref: t14 }));
});
var [F3, K] = D2("MenuContent");
var MenuContent = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { forceMount: n6 } = _a2, r13 = __objRest(_a2, ["forceMount"]), o13 = A2("MenuContent", e12.__scopeMenu);
  return E3.createElement(I2.Provider, { scope: e12.__scopeMenu }, /* @__PURE__ */ E3.createElement(Presence, { present: n6 || o13.open }, /* @__PURE__ */ E3.createElement(I2.Slot, { scope: e12.__scopeMenu }, o13.isSubmenu ? /* @__PURE__ */ E3.createElement(X, _extends3({}, r13, { ref: t14 })) : /* @__PURE__ */ E3.createElement(G3, _extends3({}, r13, { ref: t14 })))));
});
var G3 = /* @__PURE__ */ E3.forwardRef((e12, t14) => A2("MenuContent", e12.__scopeMenu).modal ? /* @__PURE__ */ E3.createElement(U2, _extends3({}, e12, { ref: t14 })) : /* @__PURE__ */ E3.createElement(V4, _extends3({}, e12, { ref: t14 })));
var U2 = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const n6 = A2("MenuContent", e12.__scopeMenu), r13 = E3.useRef(null), o13 = useComposedRefs(t14, r13);
  return E3.useEffect(() => {
    const e13 = r13.current;
    if (e13)
      return hideOthers(e13);
  }, []), /* @__PURE__ */ E3.createElement(B2, _extends3({}, e12, { ref: o13, trapFocus: n6.open, disableOutsidePointerEvents: n6.open, disableOutsideScroll: true, onFocusOutside: composeEventHandlers(e12.onFocusOutside, (e13) => e13.preventDefault(), { checkForDefaultPrevented: false }), onDismiss: () => n6.onOpenChange(false) }));
});
var V4 = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const n6 = A2("MenuContent", e12.__scopeMenu);
  return E3.createElement(B2, _extends3({}, e12, { ref: t14, trapFocus: false, disableOutsidePointerEvents: false, disableOutsideScroll: false, onDismiss: () => n6.onOpenChange(false) }));
});
var X = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const n6 = A2("MenuContent", e12.__scopeMenu), r13 = E3.useRef(null), o13 = useComposedRefs(t14, r13);
  return n6.isSubmenu ? /* @__PURE__ */ E3.createElement(B2, _extends3({ id: n6.contentId, "aria-labelledby": n6.triggerId }, e12, { ref: o13, align: "start", side: n6.dir === "rtl" ? "left" : "right", portalled: true, disableOutsidePointerEvents: false, disableOutsideScroll: false, trapFocus: false, onOpenAutoFocus: (e13) => {
    var t15;
    n6.isUsingKeyboardRef.current && ((t15 = r13.current) === null || t15 === void 0 || t15.focus()), e13.preventDefault();
  }, onCloseAutoFocus: (e13) => e13.preventDefault(), onFocusOutside: composeEventHandlers(e12.onFocusOutside, (e13) => {
    e13.target !== n6.trigger && n6.onOpenChange(false);
  }), onEscapeKeyDown: composeEventHandlers(e12.onEscapeKeyDown, n6.onRootClose), onKeyDown: composeEventHandlers(e12.onKeyDown, (e13) => {
    const t15 = e13.currentTarget.contains(e13.target), r14 = y2[n6.dir].includes(e13.key);
    var o14;
    t15 && r14 && (n6.onOpenChange(false), (o14 = n6.trigger) === null || o14 === void 0 || o14.focus(), e13.preventDefault());
  }) })) : null;
});
var B2 = /* @__PURE__ */ E3.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeMenu: r13, loop: u4 = false, trapFocus: i8, onOpenAutoFocus: s8, onCloseAutoFocus: l9, disableOutsidePointerEvents: f11, onEscapeKeyDown: v6, onPointerDownOutside: g5, onFocusOutside: h3, onInteractOutside: x5, onDismiss: _18, disableOutsideScroll: y4, allowPinchZoom: I3, portalled: P3 } = _a2, D7 = __objRest(_a2, ["__scopeMenu", "loop", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "disableOutsideScroll", "allowPinchZoom", "portalled"]), S3 = A2("MenuContent", r13), L4 = O2(r13), K2 = T3(r13), G4 = k2(r13), [U3, V5] = E3.useState(null), X2 = E3.useRef(null), B3 = useComposedRefs(n6, X2, S3.onContentChange), Y4 = E3.useRef(0), Z4 = E3.useRef(""), z3 = E3.useRef(0), H3 = E3.useRef(null), W4 = E3.useRef("right"), q3 = E3.useRef(0), N2 = P3 ? Portal : E3.Fragment, Q = y4 ? Combination_default : E3.Fragment, $2 = y4 ? { allowPinchZoom: I3 } : void 0, ee = (e13) => {
    var t14, n7;
    const r14 = Z4.current + e13, o13 = G4().filter((e14) => !e14.disabled), u5 = document.activeElement, c7 = (t14 = o13.find((e14) => e14.ref.current === u5)) === null || t14 === void 0 ? void 0 : t14.textValue, a9 = function(e14, t15, n8) {
      const r15 = t15.length > 1 && Array.from(t15).every((e15) => e15 === t15[0]) ? t15[0] : t15, o14 = n8 ? e14.indexOf(n8) : -1;
      let u6 = (c8 = e14, a10 = Math.max(o14, 0), c8.map((e15, t16) => c8[(a10 + t16) % c8.length]));
      var c8, a10;
      r15.length === 1 && (u6 = u6.filter((e15) => e15 !== n8));
      const i10 = u6.find((e15) => e15.toLowerCase().startsWith(r15.toLowerCase()));
      return i10 !== n8 ? i10 : void 0;
    }(o13.map((e14) => e14.textValue), r14, c7), i9 = (n7 = o13.find((e14) => e14.textValue === a9)) === null || n7 === void 0 ? void 0 : n7.ref.current;
    !function e14(t15) {
      Z4.current = t15, window.clearTimeout(Y4.current), t15 !== "" && (Y4.current = window.setTimeout(() => e14(""), 1e3));
    }(r14), i9 && setTimeout(() => i9.focus());
  };
  E3.useEffect(() => () => window.clearTimeout(Y4.current), []), useFocusGuards();
  const te = E3.useCallback((e13) => {
    var t14, n7;
    return W4.current === ((t14 = H3.current) === null || t14 === void 0 ? void 0 : t14.side) && function(e14, t15) {
      if (!t15)
        return false;
      return function(e15, t16) {
        const { x: n8, y: r14 } = e15;
        let o13 = false;
        for (let e16 = 0, u5 = t16.length - 1; e16 < t16.length; u5 = e16++) {
          const c7 = t16[e16].x, a9 = t16[e16].y, i9 = t16[u5].x, s9 = t16[u5].y;
          a9 > r14 != s9 > r14 && n8 < (i9 - c7) * (r14 - a9) / (s9 - a9) + c7 && (o13 = !o13);
        }
        return o13;
      }({ x: e14.clientX, y: e14.clientY }, t15);
    }(e13, (n7 = H3.current) === null || n7 === void 0 ? void 0 : n7.area);
  }, []);
  return E3.createElement(N2, null, /* @__PURE__ */ E3.createElement(Q, $2, /* @__PURE__ */ E3.createElement(F3, { scope: r13, searchRef: Z4, onItemEnter: E3.useCallback((e13) => {
    te(e13) && e13.preventDefault();
  }, [te]), onItemLeave: E3.useCallback((e13) => {
    var t14;
    te(e13) || ((t14 = X2.current) === null || t14 === void 0 || t14.focus(), V5(null));
  }, [te]), onTriggerLeave: E3.useCallback((e13) => {
    te(e13) && e13.preventDefault();
  }, [te]), pointerGraceTimerRef: z3, onPointerGraceIntentChange: E3.useCallback((e13) => {
    H3.current = e13;
  }, []) }, /* @__PURE__ */ E3.createElement(FocusScope, { asChild: true, trapped: i8, onMountAutoFocus: composeEventHandlers(s8, (e13) => {
    var t14;
    e13.preventDefault(), (t14 = X2.current) === null || t14 === void 0 || t14.focus();
  }), onUnmountAutoFocus: l9 }, /* @__PURE__ */ E3.createElement(DismissableLayer, { asChild: true, disableOutsidePointerEvents: f11, onEscapeKeyDown: v6, onPointerDownOutside: g5, onFocusOutside: h3, onInteractOutside: x5, onDismiss: _18 }, /* @__PURE__ */ E3.createElement(Root, _extends3({ asChild: true }, K2, { dir: S3.dir, orientation: "vertical", loop: u4, currentTabStopId: U3, onCurrentTabStopIdChange: V5, onEntryFocus: (e13) => {
    S3.isUsingKeyboardRef.current || e13.preventDefault();
  } }), /* @__PURE__ */ E3.createElement(Content, _extends3({ role: "menu", dir: S3.dir, "data-state": j3(S3.open) }, L4, D7, { ref: B3, style: __spreadValues({ outline: "none" }, D7.style), onKeyDown: composeEventHandlers(D7.onKeyDown, (e13) => {
    const t14 = e13.target, n7 = e13.currentTarget.contains(t14), r14 = e13.ctrlKey || e13.altKey || e13.metaKey;
    n7 && !r14 && e13.key.length === 1 && ee(e13.key), e13.key === "Tab" && e13.preventDefault();
    const o13 = X2.current;
    if (e13.target !== o13)
      return;
    if (!R3.includes(e13.key))
      return;
    e13.preventDefault();
    const u5 = G4().filter((e14) => !e14.disabled).map((e14) => e14.ref.current);
    b4.includes(e13.key) && u5.reverse(), function(e14) {
      const t15 = document.activeElement;
      for (const n8 of e14) {
        if (n8 === t15)
          return;
        if (n8.focus(), document.activeElement !== t15)
          return;
      }
    }(u5);
  }), onBlur: composeEventHandlers(e12.onBlur, (e13) => {
    e13.currentTarget.contains(e13.target) || (window.clearTimeout(Y4.current), Z4.current = "");
  }), onPointerMove: composeEventHandlers(e12.onPointerMove, J2((e13) => {
    const t14 = e13.target, n7 = q3.current !== e13.clientX;
    if (e13.currentTarget.contains(t14) && n7) {
      const t15 = e13.clientX > q3.current ? "right" : "left";
      W4.current = t15, q3.current = e13.clientX;
    }
  })) }))))))));
});
var MenuGroup = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeMenu: n6 } = _a2, r13 = __objRest(_a2, ["__scopeMenu"]);
  return E3.createElement(Primitive.div, _extends3({ role: "group" }, r13, { ref: t14 }));
});
var MenuItem = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { disabled: n6 = false, onSelect: r13 } = _a2, o13 = __objRest(_a2, ["disabled", "onSelect"]), u4 = E3.useRef(null), c7 = A2("MenuItem", e12.__scopeMenu), a9 = K("MenuItem", e12.__scopeMenu), i8 = useComposedRefs(t14, u4), s8 = E3.useRef(false);
  return E3.createElement(Y3, _extends3({}, o13, { ref: i8, disabled: n6, onClick: composeEventHandlers(e12.onClick, () => {
    const e13 = u4.current;
    if (!n6 && e13) {
      const t15 = new Event("menu.itemSelect", { bubbles: true, cancelable: true });
      e13.addEventListener("menu.itemSelect", (e14) => r13 == null ? void 0 : r13(e14), { once: true }), e13.dispatchEvent(t15), t15.defaultPrevented ? s8.current = false : c7.onRootClose();
    }
  }), onPointerDown: (t15) => {
    var n7;
    (n7 = e12.onPointerDown) === null || n7 === void 0 || n7.call(e12, t15), s8.current = true;
  }, onPointerUp: composeEventHandlers(e12.onPointerUp, (e13) => {
    var t15;
    s8.current || (t15 = e13.currentTarget) === null || t15 === void 0 || t15.click();
  }), onKeyDown: composeEventHandlers(e12.onKeyDown, (e13) => {
    const t15 = a9.searchRef.current !== "";
    n6 || t15 && e13.key === " " || x2.includes(e13.key) && (e13.currentTarget.click(), e13.preventDefault());
  }) }));
});
var MenuSubTrigger = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const n6 = A2("MenuSubTrigger", e12.__scopeMenu), r13 = K("MenuSubTrigger", e12.__scopeMenu), o13 = E3.useRef(null), { pointerGraceTimerRef: u4, onPointerGraceIntentChange: c7 } = r13, a9 = E3.useCallback(() => {
    o13.current && window.clearTimeout(o13.current), o13.current = null;
  }, []);
  return E3.useEffect(() => a9, [a9]), E3.useEffect(() => {
    const e13 = u4.current;
    return () => {
      window.clearTimeout(e13), c7(null);
    };
  }, [u4, c7]), n6.isSubmenu ? /* @__PURE__ */ E3.createElement(MenuAnchor, _extends3({ asChild: true }, e12), /* @__PURE__ */ E3.createElement(Y3, _extends3({ id: n6.triggerId, "aria-haspopup": "menu", "aria-expanded": n6.open, "aria-controls": n6.contentId, "data-state": j3(n6.open) }, e12, { ref: composeRefs(t14, n6.onTriggerChange), onClick: (t15) => {
    var r14;
    (r14 = e12.onClick) === null || r14 === void 0 || r14.call(e12, t15), e12.disabled || t15.defaultPrevented || (t15.currentTarget.focus(), n6.open || n6.onOpenChange(true));
  }, onPointerMove: composeEventHandlers(e12.onPointerMove, J2((t15) => {
    r13.onItemEnter(t15), t15.defaultPrevented || e12.disabled || n6.open || o13.current || (r13.onPointerGraceIntentChange(null), o13.current = window.setTimeout(() => {
      n6.onOpenChange(true), a9();
    }, 100));
  })), onPointerLeave: composeEventHandlers(e12.onPointerLeave, J2((e13) => {
    var t15;
    a9();
    const o14 = (t15 = n6.content) === null || t15 === void 0 ? void 0 : t15.getBoundingClientRect();
    if (o14) {
      var c8;
      const t16 = (c8 = n6.content) === null || c8 === void 0 ? void 0 : c8.dataset.side, a10 = t16 === "right", i8 = a10 ? -5 : 5, s8 = o14[a10 ? "left" : "right"], l9 = o14[a10 ? "right" : "left"];
      r13.onPointerGraceIntentChange({ area: [{ x: e13.clientX + i8, y: e13.clientY }, { x: s8, y: o14.top }, { x: l9, y: o14.top }, { x: l9, y: o14.bottom }, { x: s8, y: o14.bottom }], side: t16 }), window.clearTimeout(u4.current), u4.current = window.setTimeout(() => r13.onPointerGraceIntentChange(null), 300);
    } else {
      if (r13.onTriggerLeave(e13), e13.defaultPrevented)
        return;
      r13.onPointerGraceIntentChange(null);
    }
  })), onKeyDown: composeEventHandlers(e12.onKeyDown, (t15) => {
    const o14 = r13.searchRef.current !== "";
    var u5;
    e12.disabled || o14 && t15.key === " " || _15[n6.dir].includes(t15.key) && (n6.onOpenChange(true), (u5 = n6.content) === null || u5 === void 0 || u5.focus(), t15.preventDefault());
  }) }))) : null;
});
var Y3 = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeMenu: n6, disabled: r13 = false, textValue: u4 } = _a2, c7 = __objRest(_a2, ["__scopeMenu", "disabled", "textValue"]), a9 = K("MenuItem", n6), i8 = T3(n6), l9 = E3.useRef(null), d8 = useComposedRefs(t14, l9), [p7, f11] = E3.useState("");
  return E3.useEffect(() => {
    const e13 = l9.current;
    var t15;
    e13 && f11(((t15 = e13.textContent) !== null && t15 !== void 0 ? t15 : "").trim());
  }, [c7.children]), /* @__PURE__ */ E3.createElement(I2.ItemSlot, { scope: n6, disabled: r13, textValue: u4 != null ? u4 : p7 }, /* @__PURE__ */ E3.createElement(Item, _extends3({ asChild: true }, i8, { focusable: !r13 }), /* @__PURE__ */ E3.createElement(Primitive.div, _extends3({ role: "menuitem", "aria-disabled": r13 || void 0, "data-disabled": r13 ? "" : void 0 }, c7, { ref: d8, onPointerMove: composeEventHandlers(e12.onPointerMove, J2((e13) => {
    if (r13)
      a9.onItemLeave(e13);
    else if (a9.onItemEnter(e13), !e13.defaultPrevented) {
      e13.currentTarget.focus();
    }
  })), onPointerLeave: composeEventHandlers(e12.onPointerLeave, J2((e13) => a9.onItemLeave(e13))) }))));
});
var MenuCheckboxItem = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { checked: n6 = false, onCheckedChange: r13 } = _a2, o13 = __objRest(_a2, ["checked", "onCheckedChange"]);
  return E3.createElement(H2, { scope: e12.__scopeMenu, checked: n6 }, /* @__PURE__ */ E3.createElement(MenuItem, _extends3({ role: "menuitemcheckbox", "aria-checked": n6 }, o13, { ref: t14, "data-state": q2(n6), onSelect: composeEventHandlers(o13.onSelect, () => r13 == null ? void 0 : r13(!n6), { checkForDefaultPrevented: false }) })));
});
var [Z3, z2] = D2("MenuRadioGroup", { value: void 0, onValueChange: () => {
} });
var MenuRadioGroup = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { value: r13, onValueChange: o13 } = _a2, u4 = __objRest(_a2, ["value", "onValueChange"]), c7 = useCallbackRef(o13);
  return E3.createElement(Z3, { scope: e12.__scopeMenu, value: r13, onValueChange: c7 }, /* @__PURE__ */ E3.createElement(MenuGroup, _extends3({}, u4, { ref: t14 })));
});
var MenuRadioItem = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { value: n6 } = _a2, r13 = __objRest(_a2, ["value"]), o13 = z2("MenuRadioItem", e12.__scopeMenu), u4 = n6 === o13.value;
  return E3.createElement(H2, { scope: e12.__scopeMenu, checked: u4 }, /* @__PURE__ */ E3.createElement(MenuItem, _extends3({ role: "menuitemradio", "aria-checked": u4 }, r13, { ref: t14, "data-state": q2(u4), onSelect: composeEventHandlers(r13.onSelect, () => {
    var e13;
    return (e13 = o13.onValueChange) === null || e13 === void 0 ? void 0 : e13.call(o13, n6);
  }, { checkForDefaultPrevented: false }) })));
});
var [H2, W3] = D2("MenuItemIndicator", { checked: false });
var MenuItemIndicator = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeMenu: n6, forceMount: r13 } = _a2, o13 = __objRest(_a2, ["__scopeMenu", "forceMount"]), u4 = W3("MenuItemIndicator", n6);
  return E3.createElement(Presence, { present: r13 || u4.checked }, /* @__PURE__ */ E3.createElement(Primitive.span, _extends3({}, o13, { ref: t14, "data-state": q2(u4.checked) })));
});
var MenuSeparator = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeMenu: n6 } = _a2, r13 = __objRest(_a2, ["__scopeMenu"]);
  return E3.createElement(Primitive.div, _extends3({ role: "separator", "aria-orientation": "horizontal" }, r13, { ref: t14 }));
});
var MenuArrow = /* @__PURE__ */ E3.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeMenu: n6 } = _a2, r13 = __objRest(_a2, ["__scopeMenu"]), o13 = O2(n6);
  return E3.createElement(Arrow2, _extends3({}, o13, r13, { ref: t14 }));
});
function j3(e12) {
  return e12 ? "open" : "closed";
}
function q2(e12) {
  return e12 ? "checked" : "unchecked";
}
function J2(e12) {
  return (t14) => t14.pointerType === "mouse" ? e12(t14) : void 0;
}
var Root4 = Menu;
var Sub = MenuSub;
var Anchor2 = MenuAnchor;
var SubTrigger = MenuSubTrigger;
var Content2 = MenuContent;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow3 = MenuArrow;

// ../../node_modules/@radix-ui/react-dropdown-menu/dist/index.module.js
var d6 = __toModule(require_react());
var [s5, i6] = createContextScope("DropdownMenu", [S2]);
var l7 = S2();
var [m5, w3] = s5("DropdownMenu");
var DropdownMenu = (e12) => {
  const { __scopeDropdownMenu: n6, children: r13, open: p7, defaultOpen: a9, onOpenChange: c7 } = e12, s8 = M2("DropdownMenu", n6), i8 = l7(n6), [w6 = false, D7] = useControllableState({ prop: p7, defaultProp: a9, onChange: c7 }), g5 = d6.useCallback(() => D7((e13) => !e13), [D7]);
  return s8.isInsideContent ? /* @__PURE__ */ d6.createElement(m5, { scope: n6, isRootMenu: false, open: w6, onOpenChange: D7, onOpenToggle: g5 }, /* @__PURE__ */ d6.createElement(Sub, _extends3({}, i8, { open: w6, onOpenChange: D7 }), r13)) : /* @__PURE__ */ d6.createElement(f7, _extends3({}, e12, { open: w6, onOpenChange: D7, onOpenToggle: g5 }), r13);
};
var f7 = (n6) => {
  const { __scopeDropdownMenu: r13, children: t14, dir: p7, open: a9, onOpenChange: c7, onOpenToggle: s8, modal: i8 = true } = n6, w6 = l7(r13), f11 = d6.useRef(null);
  return d6.createElement(m5, { scope: r13, isRootMenu: true, triggerId: useId(), triggerRef: f11, contentId: useId(), open: a9, onOpenChange: c7, onOpenToggle: s8, modal: i8 }, /* @__PURE__ */ d6.createElement(Root4, _extends3({}, w6, { open: a9, onOpenChange: c7, dir: p7, modal: i8 }), t14));
};
var DropdownMenuTrigger = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: t14 } = _a2, p7 = __objRest(_a2, ["__scopeDropdownMenu"]), s8 = w3("DropdownMenuTrigger", t14), i8 = l7(t14);
  return s8.isRootMenu ? /* @__PURE__ */ d6.createElement(Anchor2, _extends3({ asChild: true }, i8), /* @__PURE__ */ d6.createElement(Primitive.button, _extends3({ type: "button", id: s8.triggerId, "aria-haspopup": "menu", "aria-expanded": !!s8.open || void 0, "aria-controls": s8.open ? s8.contentId : void 0, "data-state": s8.open ? "open" : "closed" }, p7, { ref: composeRefs(n6, s8.triggerRef), onPointerDown: composeEventHandlers(e12.onPointerDown, (e13) => {
    e13.button === 0 && e13.ctrlKey === false && (s8.open || e13.preventDefault(), s8.onOpenToggle());
  }), onKeyDown: composeEventHandlers(e12.onKeyDown, (e13) => {
    [" ", "Enter", "ArrowDown"].includes(e13.key) && (e13.preventDefault(), s8.onOpenChange(true));
  }) }))) : null;
});
var [D3, M2] = s5("DropdownMenuContent", { isInsideContent: false });
var DropdownMenuContent = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = w3("DropdownMenuContent", r13), a9 = l7(r13), c7 = __spreadProps(__spreadValues({}, t14), { style: __spreadProps(__spreadValues({}, e12.style), { "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)" }) });
  return d6.createElement(D3, { scope: r13, isInsideContent: true }, p7.isRootMenu ? /* @__PURE__ */ d6.createElement(g3, _extends3({ __scopeDropdownMenu: r13 }, c7, { ref: n6 })) : /* @__PURE__ */ d6.createElement(Content2, _extends3({}, a9, c7, { ref: n6 })));
});
var g3 = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13, portalled: t14 = true } = _a2, p7 = __objRest(_a2, ["__scopeDropdownMenu", "portalled"]), a9 = w3("DropdownMenuContent", r13), c7 = l7(r13), s8 = d6.useRef(false);
  return a9.isRootMenu ? /* @__PURE__ */ d6.createElement(Content2, _extends3({ id: a9.contentId, "aria-labelledby": a9.triggerId }, c7, p7, { ref: n6, portalled: t14, onCloseAutoFocus: (o13) => {
    var n7, r14;
    ((n7 = e12.onCloseAutoFocus) === null || n7 === void 0 || n7.call(e12, o13), o13.defaultPrevented) || (s8.current || (r14 = a9.triggerRef.current) === null || r14 === void 0 || r14.focus(), o13.preventDefault());
    s8.current = false;
  }, onInteractOutside: (o13) => {
    var n7, r14;
    if ((n7 = e12.onInteractOutside) === null || n7 === void 0 || n7.call(e12, o13), !o13.defaultPrevented) {
      const e13 = o13.detail.originalEvent, n8 = e13.button === 0 && e13.ctrlKey === true, r15 = e13.button === 2 || n8;
      a9.modal && !r15 || (s8.current = true);
    }
    const t15 = o13.target;
    ((r14 = a9.triggerRef.current) === null || r14 === void 0 ? void 0 : r14.contains(t15)) && o13.preventDefault();
  } })) : null;
});
var DropdownMenuItem = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r13);
  return d6.createElement(Item2, _extends3({}, p7, t14, { ref: n6 }));
});
var DropdownMenuTriggerItem = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r13);
  return d6.createElement(SubTrigger, _extends3({}, p7, t14, { ref: n6 }));
});
var DropdownMenuCheckboxItem = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r13);
  return d6.createElement(CheckboxItem, _extends3({}, p7, t14, { ref: n6 }));
});
var DropdownMenuRadioGroup = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r13);
  return d6.createElement(RadioGroup, _extends3({}, p7, t14, { ref: n6 }));
});
var DropdownMenuRadioItem = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r13);
  return d6.createElement(RadioItem, _extends3({}, p7, t14, { ref: n6 }));
});
var DropdownMenuItemIndicator = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r13);
  return d6.createElement(ItemIndicator, _extends3({}, p7, t14, { ref: n6 }));
});
var DropdownMenuSeparator = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r13);
  return d6.createElement(Separator, _extends3({}, p7, t14, { ref: n6 }));
});
var DropdownMenuArrow = /* @__PURE__ */ d6.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeDropdownMenu: r13 } = _a2, t14 = __objRest(_a2, ["__scopeDropdownMenu"]), p7 = l7(r13);
  return d6.createElement(Arrow3, _extends3({}, p7, t14, { ref: n6 }));
});
var Root5 = DropdownMenu;
var Trigger = DropdownMenuTrigger;
var Content3 = DropdownMenuContent;
var Item3 = DropdownMenuItem;
var TriggerItem = DropdownMenuTriggerItem;
var CheckboxItem2 = DropdownMenuCheckboxItem;
var RadioGroup2 = DropdownMenuRadioGroup;
var RadioItem2 = DropdownMenuRadioItem;
var ItemIndicator2 = DropdownMenuItemIndicator;
var Separator2 = DropdownMenuSeparator;
var Arrow4 = DropdownMenuArrow;

// ../../node_modules/@radix-ui/react-icons/dist/react-icons.esm.js
var import_react59 = __toModule(require_react());
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i8;
  for (i8 = 0; i8 < sourceKeys.length; i8++) {
    key = sourceKeys[i8];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var AlignBottomIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M9 3C9 2.44772 8.55229 2 8 2H7C6.44772 2 6 2.44772 6 3L6 14H1.5C1.22386 14 1 14.2239 1 14.5C1 14.7761 1.22386 15 1.5 15L6 15H9H13.5C13.7761 15 14 14.7761 14 14.5C14 14.2239 13.7761 14 13.5 14H9V3Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignCenterHorizontallyIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M1.99988 6C1.44759 6 0.999877 6.44772 0.999877 7L0.999877 8C0.999877 8.55228 1.44759 9 1.99988 9L6.99988 9L6.99988 13.5C6.99988 13.7761 7.22374 14 7.49988 14C7.77602 14 7.99988 13.7761 7.99988 13.5L7.99988 9L12.9999 9C13.5522 9 13.9999 8.55228 13.9999 8L13.9999 7C13.9999 6.44772 13.5522 6 12.9999 6L7.99988 6L7.99988 1.5C7.99988 1.22386 7.77602 1 7.49988 1C7.22373 1 6.99988 1.22386 6.99988 1.5L6.99988 6L1.99988 6Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignCenterVerticallyIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M6.99988 1C6.44759 1 5.99988 1.44772 5.99988 2V7H1.49988C1.22374 7 0.999878 7.22386 0.999878 7.5C0.999878 7.77614 1.22374 8 1.49988 8H5.99988V13C5.99988 13.5523 6.44759 14 6.99988 14H7.99988C8.55216 14 8.99988 13.5523 8.99988 13V8H13.4999C13.776 8 13.9999 7.77614 13.9999 7.5C13.9999 7.22386 13.776 7 13.4999 7H8.99988V2C8.99988 1.44772 8.55216 1 7.99988 1L6.99988 1Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignLeftIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M0.499995 0.999995C0.223855 0.999995 -5.58458e-07 1.22385 -5.46388e-07 1.49999L-2.18554e-08 13.4999C-9.78492e-09 13.776 0.223855 13.9999 0.499995 13.9999C0.776136 13.9999 0.999991 13.776 0.999991 13.4999L0.999991 8.99993L12 8.99993C12.5523 8.99993 13 8.55222 13 7.99993L13 6.99994C13 6.44766 12.5523 5.99995 12 5.99995L0.999991 5.99995L0.999991 1.49999C0.999991 1.22385 0.776135 0.999995 0.499995 0.999995Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignRightIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M14.4999 1C14.2237 1 13.9999 1.22386 13.9999 1.5L13.9999 6L2.99988 6C2.44759 6 1.99988 6.44772 1.99988 7L1.99988 8C1.99988 8.55228 2.44759 9 2.99988 9L13.9999 9L13.9999 13.5C13.9999 13.7761 14.2237 14 14.4999 14C14.776 14 14.9999 13.7761 14.9999 13.5L14.9999 9L14.9999 6L14.9999 1.5C14.9999 1.22386 14.776 1 14.4999 1Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AlignTopIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M1.5 0C1.22386 0 1 0.223858 1 0.5C1 0.776142 1.22386 1 1.5 1H6V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V1H13.5C13.7761 1 14 0.776142 14 0.5C14 0.223858 13.7761 0 13.5 0H9H6H1.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AngleIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M8.8914 2.1937C9.1158 2.35464 9.16725 2.66701 9.00631 2.89141L2.47388 12H13.5C13.7761 12 14 12.2239 14 12.5C14 12.7762 13.7761 13 13.5 13H1.5C1.31254 13 1.14082 12.8952 1.0552 12.7284C0.969578 12.5616 0.984438 12.361 1.09369 12.2086L8.19369 2.30862C8.35462 2.08422 8.667 2.03277 8.8914 2.1937ZM11.1 6.50001C11.1 6.22387 11.3238 6.00001 11.6 6.00001C11.8761 6.00001 12.1 6.22387 12.1 6.50001C12.1 6.77615 11.8761 7.00001 11.6 7.00001C11.3238 7.00001 11.1 6.77615 11.1 6.50001ZM10.4 4.00001C10.1239 4.00001 9.90003 4.22387 9.90003 4.50001C9.90003 4.77615 10.1239 5.00001 10.4 5.00001C10.6762 5.00001 10.9 4.77615 10.9 4.50001C10.9 4.22387 10.6762 4.00001 10.4 4.00001ZM12.1 8.50001C12.1 8.22387 12.3238 8.00001 12.6 8.00001C12.8761 8.00001 13.1 8.22387 13.1 8.50001C13.1 8.77615 12.8761 9.00001 12.6 9.00001C12.3238 9.00001 12.1 8.77615 12.1 8.50001ZM13.4 10C13.1239 10 12.9 10.2239 12.9 10.5C12.9 10.7761 13.1239 11 13.4 11C13.6762 11 13.9 10.7761 13.9 10.5C13.9 10.2239 13.6762 10 13.4 10Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ArrowDownIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ArrowTopRightIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ArrowUpIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var AspectRatioIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M2.5 2H12.5C12.7761 2 13 2.22386 13 2.5V12.5C13 12.7761 12.7761 13 12.5 13H2.5C2.22386 13 2 12.7761 2 12.5V2.5C2 2.22386 2.22386 2 2.5 2ZM1 2.5C1 1.67157 1.67157 1 2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5ZM7.5 4C7.77614 4 8 3.77614 8 3.5C8 3.22386 7.77614 3 7.5 3C7.22386 3 7 3.22386 7 3.5C7 3.77614 7.22386 4 7.5 4ZM8 5.5C8 5.77614 7.77614 6 7.5 6C7.22386 6 7 5.77614 7 5.5C7 5.22386 7.22386 5 7.5 5C7.77614 5 8 5.22386 8 5.5ZM7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8ZM10 7.5C10 7.77614 9.77614 8 9.5 8C9.22386 8 9 7.77614 9 7.5C9 7.22386 9.22386 7 9.5 7C9.77614 7 10 7.22386 10 7.5ZM11.5 8C11.7761 8 12 7.77614 12 7.5C12 7.22386 11.7761 7 11.5 7C11.2239 7 11 7.22386 11 7.5C11 7.77614 11.2239 8 11.5 8Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var BoxIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M12.5 2H2.5C2.22386 2 2 2.22386 2 2.5V12.5C2 12.7761 2.22386 13 2.5 13H12.5C12.7761 13 13 12.7761 13 12.5V2.5C13 2.22386 12.7761 2 12.5 2ZM2.5 1C1.67157 1 1 1.67157 1 2.5V12.5C1 13.3284 1.67157 14 2.5 14H12.5C13.3284 14 14 13.3284 14 12.5V2.5C14 1.67157 13.3284 1 12.5 1H2.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var CheckIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var ChevronRightIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var CircleIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M0.877075 7.49991C0.877075 3.84222 3.84222 0.877075 7.49991 0.877075C11.1576 0.877075 14.1227 3.84222 14.1227 7.49991C14.1227 11.1576 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1576 0.877075 7.49991ZM7.49991 1.82708C4.36689 1.82708 1.82708 4.36689 1.82708 7.49991C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49991C13.1727 4.36689 10.6329 1.82708 7.49991 1.82708Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var CopyIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M1 9.50006C1 10.3285 1.67157 11.0001 2.5 11.0001H4L4 10.0001H2.5C2.22386 10.0001 2 9.7762 2 9.50006L2 2.50006C2 2.22392 2.22386 2.00006 2.5 2.00006L9.5 2.00006C9.77614 2.00006 10 2.22392 10 2.50006V4.00002H5.5C4.67158 4.00002 4 4.67159 4 5.50002V12.5C4 13.3284 4.67158 14 5.5 14H12.5C13.3284 14 14 13.3284 14 12.5V5.50002C14 4.67159 13.3284 4.00002 12.5 4.00002H11V2.50006C11 1.67163 10.3284 1.00006 9.5 1.00006H2.5C1.67157 1.00006 1 1.67163 1 2.50006V9.50006ZM5 5.50002C5 5.22388 5.22386 5.00002 5.5 5.00002H12.5C12.7761 5.00002 13 5.22388 13 5.50002V12.5C13 12.7762 12.7761 13 12.5 13H5.5C5.22386 13 5 12.7762 5 12.5V5.50002Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var CursorArrowIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M3.29227 0.048984C3.47033 -0.032338 3.67946 -0.00228214 3.8274 0.125891L12.8587 7.95026C13.0134 8.08432 13.0708 8.29916 13.0035 8.49251C12.9362 8.68586 12.7578 8.81866 12.5533 8.82768L9.21887 8.97474L11.1504 13.2187C11.2648 13.47 11.1538 13.7664 10.9026 13.8808L8.75024 14.8613C8.499 14.9758 8.20255 14.8649 8.08802 14.6137L6.15339 10.3703L3.86279 12.7855C3.72196 12.934 3.50487 12.9817 3.31479 12.9059C3.1247 12.8301 3 12.6461 3 12.4414V0.503792C3 0.308048 3.11422 0.130306 3.29227 0.048984ZM4 1.59852V11.1877L5.93799 9.14425C6.05238 9.02363 6.21924 8.96776 6.38319 8.99516C6.54715 9.02256 6.68677 9.12965 6.75573 9.2809L8.79056 13.7441L10.0332 13.178L8.00195 8.71497C7.93313 8.56376 7.94391 8.38824 8.03072 8.24659C8.11753 8.10494 8.26903 8.01566 8.435 8.00834L11.2549 7.88397L4 1.59852Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var DotFilledIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z",
    fill: color
  }));
});
var DotsHorizontalIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var GroupIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M1.44995 0.949951C1.31734 0.949951 1.19016 1.00263 1.0964 1.0964C1.00263 1.19017 0.949951 1.31735 0.949951 1.44995L0.949966 3.44995C0.949969 3.7261 1.17383 3.94995 1.44997 3.94995C1.72611 3.94995 1.94997 3.72609 1.94997 3.44995L1.94995 1.94995H3.44997C3.72611 1.94995 3.94997 1.72609 3.94997 1.44995C3.94997 1.17381 3.72611 0.949951 3.44997 0.949951H1.44995ZM5.94995 0.949951C5.67381 0.949951 5.44995 1.17381 5.44995 1.44995C5.44995 1.72609 5.67381 1.94995 5.94995 1.94995H8.94995C9.22609 1.94995 9.44995 1.72609 9.44995 1.44995C9.44995 1.17381 9.22609 0.949951 8.94995 0.949951H5.94995ZM5.44995 13.45C5.44995 13.1738 5.67381 12.95 5.94995 12.95H8.94995C9.22609 12.95 9.44995 13.1738 9.44995 13.45C9.44995 13.7261 9.22609 13.95 8.94995 13.95H5.94995C5.67381 13.95 5.44995 13.7261 5.44995 13.45ZM1.94995 5.94995C1.94995 5.67381 1.72609 5.44995 1.44995 5.44995C1.17381 5.44995 0.949951 5.67381 0.949951 5.94995V8.94995C0.949951 9.22609 1.17381 9.44995 1.44995 9.44995C1.72609 9.44995 1.94995 9.22609 1.94995 8.94995V5.94995ZM13.45 5.44995C13.7261 5.44995 13.95 5.67381 13.95 5.94995V8.94995C13.95 9.22609 13.7261 9.44995 13.45 9.44995C13.1738 9.44995 12.95 9.22609 12.95 8.94995V5.94995C12.95 5.67381 13.1738 5.44995 13.45 5.44995ZM11.45 0.949951C11.1738 0.949951 10.95 1.17381 10.95 1.44995C10.95 1.72609 11.1738 1.94995 11.45 1.94995H12.9499V3.44995C12.9499 3.72609 13.1738 3.94995 13.4499 3.94995C13.7261 3.94995 13.9499 3.72609 13.9499 3.44995V1.44995C13.9499 1.17381 13.7252 0.949951 13.449 0.949951H11.45ZM1.44995 10.95C1.72609 10.95 1.94995 11.1738 1.94995 11.45V12.95H3.44997C3.72611 12.95 3.94997 13.1738 3.94997 13.45C3.94997 13.7261 3.72611 13.95 3.44997 13.95H1.44995C1.17381 13.95 0.949951 13.7261 0.949951 13.45V11.45C0.949951 11.1738 1.17381 10.95 1.44995 10.95ZM13.95 11.45C13.95 11.1738 13.7261 10.95 13.45 10.95C13.1738 10.9499 12.95 11.1738 12.95 11.4499L12.9491 12.95H11.45C11.1738 12.95 10.95 13.1738 10.95 13.45C10.95 13.7261 11.1738 13.95 11.45 13.95H13.4499C13.7261 13.95 13.9499 13.7261 13.9499 13.45L13.95 11.45Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var HamburgerMenuIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var LockClosedIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var LockOpen1Icon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M7.4986 0C6.3257 0 5.36107 0.38943 4.73753 1.19361C4.23745 1.83856 4 2.68242 4 3.63325H5C5 2.84313 5.19691 2.23312 5.5278 1.80636C5.91615 1.30552 6.55152 1 7.4986 1C8.35683 1 8.96336 1.26502 9.35846 1.68623C9.75793 2.11211 10 2.76044 10 3.63601V6H3C2.44772 6 2 6.44772 2 7V13C2 13.5523 2.44772 14 3 14H12C12.5523 14 13 13.5523 13 13V7C13 6.44771 12.5523 6 12 6H11V3.63601C11 2.58135 10.7065 1.66167 10.0878 1.0021C9.46477 0.337871 8.57061 0 7.4986 0ZM3 7H12V13H3V7Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var MixerVerticalIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M5 1.5C5 1.22386 4.77614 1 4.5 1C4.22386 1 4 1.22386 4 1.5L4 7C4 7.01671 4.00082 7.03323 4.00242 7.04952C2.86009 7.28022 2 8.28967 2 9.5C2 10.7103 2.86009 11.7198 4.00242 11.9505C4.00082 11.9668 4 11.9833 4 12V13.5C4 13.7761 4.22386 14 4.5 14C4.77614 14 5 13.7761 5 13.5V12C5 11.9833 4.99918 11.9668 4.99758 11.9505C6.1399 11.7198 7 10.7103 7 9.5C7 8.28967 6.1399 7.28022 4.99758 7.04952C4.99918 7.03323 5 7.01671 5 7L5 1.5ZM11 1.5C11 1.22386 10.7761 1 10.5 1C10.2239 1 10 1.22386 10 1.5V3C10 3.01671 10.0008 3.03323 10.0024 3.04952C8.8601 3.28022 8 4.28967 8 5.5C8 6.71033 8.8601 7.71978 10.0024 7.95048C10.0008 7.96677 10 7.98329 10 8V13.5C10 13.7761 10.2239 14 10.5 14C10.7761 14 11 13.7761 11 13.5V8C11 7.98329 10.9992 7.96677 10.9976 7.95048C12.1399 7.71978 13 6.71033 13 5.5C13 4.28967 12.1399 3.28022 10.9976 3.04952C10.9992 3.03323 11 3.01671 11 3V1.5ZM4.5 8C3.67157 8 3 8.67157 3 9.5C3 10.3284 3.67157 11 4.5 11C5.32843 11 6 10.3284 6 9.5C6 8.67157 5.32843 8 4.5 8ZM9 5.5C9 4.67157 9.67157 4 10.5 4C11.3284 4 12 4.67157 12 5.5C12 6.32843 11.3284 7 10.5 7C9.67157 7 9 6.32843 9 5.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var Pencil1Icon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1465 1.14645L3.71455 8.57836C3.62459 8.66832 3.55263 8.77461 3.50251 8.89155L2.04044 12.303C1.9599 12.491 2.00189 12.709 2.14646 12.8536C2.29103 12.9981 2.50905 13.0401 2.69697 12.9596L6.10847 11.4975C6.2254 11.4474 6.3317 11.3754 6.42166 11.2855L13.8536 3.85355C14.0488 3.65829 14.0488 3.34171 13.8536 3.14645L11.8536 1.14645ZM4.42166 9.28547L11.5 2.20711L12.7929 3.5L5.71455 10.5784L4.21924 11.2192L3.78081 10.7808L4.42166 9.28547Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var Pencil2Icon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M12.1464 1.14645C12.3417 0.951184 12.6583 0.951184 12.8535 1.14645L14.8535 3.14645C15.0488 3.34171 15.0488 3.65829 14.8535 3.85355L10.9109 7.79618C10.8349 7.87218 10.7471 7.93543 10.651 7.9835L6.72359 9.94721C6.53109 10.0435 6.29861 10.0057 6.14643 9.85355C5.99425 9.70137 5.95652 9.46889 6.05277 9.27639L8.01648 5.34897C8.06455 5.25283 8.1278 5.16507 8.2038 5.08907L12.1464 1.14645ZM12.5 2.20711L8.91091 5.79618L7.87266 7.87267L8.12731 8.12732L10.2038 7.08907L13.7929 3.5L12.5 2.20711ZM9.99998 2L8.99998 3H4.9C4.47171 3 4.18056 3.00039 3.95552 3.01877C3.73631 3.03668 3.62421 3.06915 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3.06915 3.62421 3.03669 3.73631 3.01878 3.95552C3.00039 4.18056 3 4.47171 3 4.9V11.1C3 11.5283 3.00039 11.8194 3.01878 12.0445C3.03669 12.2637 3.06915 12.3758 3.10899 12.454C3.20487 12.6422 3.35785 12.7951 3.54601 12.891C3.62421 12.9309 3.73631 12.9633 3.95552 12.9812C4.18056 12.9996 4.47171 13 4.9 13H11.1C11.5283 13 11.8194 12.9996 12.0445 12.9812C12.2637 12.9633 12.3758 12.9309 12.454 12.891C12.6422 12.7951 12.7951 12.6422 12.891 12.454C12.9309 12.3758 12.9633 12.2637 12.9812 12.0445C12.9996 11.8194 13 11.5283 13 11.1V6.99998L14 5.99998V11.1V11.1207C14 11.5231 14 11.8553 13.9779 12.1259C13.9549 12.407 13.9057 12.6653 13.782 12.908C13.5903 13.2843 13.2843 13.5903 12.908 13.782C12.6653 13.9057 12.407 13.9549 12.1259 13.9779C11.8553 14 11.5231 14 11.1207 14H11.1H4.9H4.87934C4.47686 14 4.14468 14 3.87409 13.9779C3.59304 13.9549 3.33469 13.9057 3.09202 13.782C2.7157 13.5903 2.40973 13.2843 2.21799 12.908C2.09434 12.6653 2.04506 12.407 2.0221 12.1259C1.99999 11.8553 1.99999 11.5231 2 11.1207V11.1206V11.1V4.9V4.87935V4.87932V4.87931C1.99999 4.47685 1.99999 4.14468 2.0221 3.87409C2.04506 3.59304 2.09434 3.33469 2.21799 3.09202C2.40973 2.71569 2.7157 2.40973 3.09202 2.21799C3.33469 2.09434 3.59304 2.04506 3.87409 2.0221C4.14468 1.99999 4.47685 1.99999 4.87932 2H4.87935H4.9H9.99998Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var PinBottomIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M13.5 13.95C13.7485 13.95 13.95 13.7485 13.95 13.5C13.95 13.2514 13.7485 13.05 13.5 13.05L1.49995 13.05C1.25142 13.05 1.04995 13.2514 1.04995 13.5C1.04995 13.7485 1.25142 13.95 1.49995 13.95L13.5 13.95ZM11.0681 7.5683C11.2439 7.39257 11.2439 7.10764 11.0681 6.93191C10.8924 6.75617 10.6075 6.75617 10.4317 6.93191L7.94993 9.41371L7.94993 1.49998C7.94993 1.25146 7.74846 1.04998 7.49993 1.04998C7.2514 1.04998 7.04993 1.25146 7.04993 1.49998L7.04993 9.41371L4.56813 6.93191C4.39239 6.75617 4.10746 6.75617 3.93173 6.93191C3.75599 7.10764 3.75599 7.39257 3.93173 7.5683L7.18173 10.8183C7.35746 10.994 7.64239 10.994 7.81812 10.8183L11.0681 7.5683Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var PinTopIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M1.50005 1.05005C1.25152 1.05005 1.05005 1.25152 1.05005 1.50005C1.05005 1.74858 1.25152 1.95005 1.50005 1.95005L13.5 1.95005C13.7486 1.95005 13.95 1.74858 13.95 1.50005C13.95 1.25152 13.7486 1.05005 13.5 1.05005H1.50005ZM3.93188 7.43169C3.75614 7.60743 3.75614 7.89236 3.93188 8.06809C4.10761 8.24383 4.39254 8.24383 4.56827 8.06809L7.05007 5.58629V13.5C7.05007 13.7485 7.25155 13.95 7.50007 13.95C7.7486 13.95 7.95007 13.7485 7.95007 13.5L7.95007 5.58629L10.4319 8.06809C10.6076 8.24383 10.8925 8.24383 11.0683 8.06809C11.244 7.89235 11.244 7.60743 11.0683 7.43169L7.81827 4.18169C7.64254 4.00596 7.35761 4.00596 7.18188 4.18169L3.93188 7.43169Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var PlusIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var RotateCounterClockwiseIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M7.59664 2.93628C7.76085 3.06401 8.00012 2.94698 8.00012 2.73895V1.99998C9.98143 2 11.1848 2.3637 11.9105 3.08945C12.6363 3.81522 13 5.0186 13 6.99998C13 7.27613 13.2239 7.49998 13.5 7.49998C13.7761 7.49998 14 7.27613 14 6.99998C14 4.9438 13.6325 3.39719 12.6176 2.38234C11.6028 1.36752 10.0562 0.999999 8.00012 0.999984V0.261266C8.00012 0.0532293 7.76085 -0.0637944 7.59664 0.063928L6.00384 1.30277C5.87516 1.40286 5.87516 1.59735 6.00384 1.69744L7.59664 2.93628ZM9.5 5H2.5C2.22386 5 2 5.22386 2 5.5V12.5C2 12.7761 2.22386 13 2.5 13H9.5C9.77614 13 10 12.7761 10 12.5V5.5C10 5.22386 9.77614 5 9.5 5ZM2.5 4C1.67157 4 1 4.67157 1 5.5V12.5C1 13.3284 1.67157 14 2.5 14H9.5C10.3284 14 11 13.3284 11 12.5V5.5C11 4.67157 10.3284 4 9.5 4H2.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var SpaceEvenlyHorizontallyIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992ZM0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992ZM1.99998 6.99994C1.99998 6.44766 2.44769 5.99995 2.99998 5.99995L5.99995 5.99995C6.55223 5.99995 6.99994 6.44766 6.99994 6.99994L6.99994 7.99993C6.99994 8.55221 6.55223 8.99992 5.99995 8.99992L2.99998 8.99992C2.4477 8.99992 1.99998 8.55221 1.99998 7.99993L1.99998 6.99994ZM8.99993 5.99995C8.44765 5.99995 7.99993 6.44766 7.99993 6.99994L7.99993 7.99993C7.99993 8.55221 8.44765 8.99992 8.99993 8.99992L11.9999 8.99992C12.5522 8.99992 12.9999 8.55221 12.9999 7.99993L12.9999 6.99994C12.9999 6.44766 12.5522 5.99995 11.9999 5.99995L8.99993 5.99995Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var SpaceEvenlyVerticallyIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM7 2C6.44772 2 6 2.44772 6 3V6C6 6.55228 6.44772 7 7 7H8C8.55228 7 9 6.55228 9 6V3C9 2.44772 8.55228 2 8 2H7ZM7 8C6.44772 8 6 8.44771 6 9V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V9C9 8.44772 8.55228 8 8 8H7ZM1.49988 14C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H1.49988Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var SquareIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M1 1H1.5H13.5H14V1.5V13.5V14H13.5H1.5H1V13.5V1.5V1ZM2 2V13H13V2H2Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var StretchHorizontallyIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 5.99995L0.999992 5.99995L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 8.99992L13.9999 8.99992L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var StretchVerticallyIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H6H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM9 14V1L6 1V14H1.49988C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H9Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M3.94993 2.95002L3.94993 4.49998C3.94993 4.74851 3.74845 4.94998 3.49993 4.94998C3.2514 4.94998 3.04993 4.74851 3.04993 4.49998V2.50004C3.04993 2.45246 3.05731 2.40661 3.07099 2.36357C3.12878 2.18175 3.29897 2.05002 3.49993 2.05002H11.4999C11.6553 2.05002 11.7922 2.12872 11.8731 2.24842C11.9216 2.32024 11.9499 2.40682 11.9499 2.50002L11.9499 2.50004V4.49998C11.9499 4.74851 11.7485 4.94998 11.4999 4.94998C11.2514 4.94998 11.0499 4.74851 11.0499 4.49998V2.95002H8.04993V12.05H9.25428C9.50281 12.05 9.70428 12.2515 9.70428 12.5C9.70428 12.7486 9.50281 12.95 9.25428 12.95H5.75428C5.50575 12.95 5.30428 12.7486 5.30428 12.5C5.30428 12.2515 5.50575 12.05 5.75428 12.05H6.94993V2.95002H3.94993Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextAlignCenterIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM4 7.5C4 7.22386 4.22386 7 4.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H4.5C4.22386 8 4 7.77614 4 7.5ZM3 10.5C3 10.2239 3.22386 10 3.5 10H11.5C11.7761 10 12 10.2239 12 10.5C12 10.7761 11.7761 11 11.5 11H3.5C3.22386 11 3 10.7761 3 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextAlignJustifyIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M2.5 4C2.22386 4 2 4.22386 2 4.5C2 4.77614 2.22386 5 2.5 5H12.5C12.7761 5 13 4.77614 13 4.5C13 4.22386 12.7761 4 12.5 4H2.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextAlignLeftIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H7.5C7.77614 7 8 7.22386 8 7.5C8 7.77614 7.77614 8 7.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H10.5C10.7761 10 11 10.2239 11 10.5C11 10.7761 10.7761 11 10.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var TextAlignRightIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM7 7.5C7 7.22386 7.22386 7 7.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H7.5C7.22386 8 7 7.77614 7 7.5ZM4 10.5C4 10.2239 4.22386 10 4.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H4.5C4.22386 11 4 10.7761 4 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var VercelLogoIcon = /* @__PURE__ */ (0, import_react59.forwardRef)(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose2(_ref, ["color"]);
  return (0, import_react59.createElement)("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), (0, import_react59.createElement)("path", {
    d: "M7.49998 1L6.92321 2.00307L1.17498 12L0.599976 13H1.7535H13.2464H14.4L13.825 12L8.07674 2.00307L7.49998 1ZM7.49998 3.00613L2.3285 12H12.6714L7.49998 3.00613Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});

// ../../packages/tldraw/dist/esm/index.js
var import_react79 = __toModule(require_react());
var import_react80 = __toModule(require_react());
var import_react81 = __toModule(require_react());
var import_react82 = __toModule(require_react());

// ../../node_modules/@radix-ui/react-visually-hidden/dist/index.module.js
var r10 = __toModule(require_react());
var VisuallyHidden = /* @__PURE__ */ r10.forwardRef((i8, o13) => /* @__PURE__ */ r10.createElement(Primitive.span, _extends3({}, i8, { ref: o13, style: __spreadProps(__spreadValues({}, i8.style), { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }) })));
var Root6 = VisuallyHidden;

// ../../node_modules/@radix-ui/react-use-previous/dist/index.module.js
var e11 = __toModule(require_react());
function usePrevious(r13) {
  const t14 = e11.useRef(r13);
  return e11.useEffect(() => {
    t14.current = r13;
  }, [r13]), t14.current;
}

// ../../node_modules/@radix-ui/react-tooltip/dist/index.module.js
var E4 = __toModule(require_react());
function y3(e12) {
  return { type: "machine.actions.assign", assign: e12 };
}
var T4;
var C3;
var v4 = y3((e12, t14) => {
  var o13;
  return __spreadProps(__spreadValues({}, e12), { id: (o13 = t14.id) !== null && o13 !== void 0 ? o13 : e12.id });
});
var _16 = function(e12, { debug: t14 = false, warnOnUnknownTransitions: o13 = false } = {}) {
  let n6 = e12.initial, r13 = e12.context;
  const i8 = [], a9 = (s8) => {
    var l9, c7;
    const p7 = e12.states[n6], u4 = s8.type, d8 = (l9 = e12.on) === null || l9 === void 0 ? void 0 : l9[u4], m7 = (c7 = p7.on) === null || c7 === void 0 ? void 0 : c7[u4], f11 = d8 != null ? d8 : m7;
    if (f11 === void 0)
      o13 && console.warn(`From state: "${n6}", event "${u4}" has no transition to any state`);
    else {
      const { target: o14, actions: l10 = [], cond: c8 = () => true } = f11, u5 = o14 ? e12.states[o14] : {};
      if (c8(r13, s8)) {
        const e13 = (p7.exit || []).concat(l10, u5.entry || []);
        r13 = function(e14, t15, o15) {
          let n7 = o15;
          return e14 == null || e14.forEach((e15) => {
            typeof e15 == "function" ? e15(n7, t15, a9) : e15.type === "machine.actions.assign" && (n7 = e15.assign(n7, t15));
          }), n7;
        }(e13, s8, r13), o14 && (n6 = o14, t14 && (console.group("event:", s8), console.log("state:", n6), console.log("context:", r13), console.groupEnd()), i8.forEach((e14) => e14({ state: n6, context: r13 })));
      }
    }
  };
  return { subscribe: function(e13) {
    return i8.push(e13), () => {
      i8.splice(i8.indexOf(e13), 1);
    };
  }, send: a9, getContext: function() {
    return r13;
  } };
}({ initial: "closed", context: { id: null, delayed: false }, on: { FOCUS: { target: "open" } }, states: { closed: { entry: [y3((e12) => __spreadProps(__spreadValues({}, e12), { id: null }))], on: { OPEN: { target: "opening" } } }, opening: { entry: [(e12, t14, o13) => {
  const n6 = t14.delayDuration, r13 = () => o13({ type: "DELAY_TIMER_END" });
  n6 === void 0 ? r13() : T4 = window.setTimeout(r13, n6);
}, v4, y3((e12) => __spreadProps(__spreadValues({}, e12), { delayed: true }))], exit: [() => clearTimeout(T4)], on: { DELAY_TIMER_END: { target: "open" }, CLOSE: { target: "closed" } } }, open: { entry: [v4], exit: [y3((e12) => __spreadProps(__spreadValues({}, e12), { delayed: false }))], on: { OPEN: { target: "open" }, CLOSE: { target: "closing", cond: (e12, t14) => e12.id === t14.id } } }, closing: { entry: [(e12, t14, o13) => {
  var n6;
  const r13 = (n6 = t14.skipDelayDuration) !== null && n6 !== void 0 ? n6 : 300;
  C3 = window.setTimeout(() => o13({ type: "SKIP_DELAY_TIMER_END" }), r13);
}], exit: [() => clearTimeout(C3)], on: { OPEN: { target: "open" }, SKIP_DELAY_TIMER_END: { target: "closed" } } } } });
var [b5, D4] = createContextScope("Tooltip", [l5]);
var w4 = l5();
var [h2, O3] = b5("Tooltip");
var Tooltip = (t14) => {
  const { __scopeTooltip: o13, children: n6, open: i8, defaultOpen: a9 = false, onOpenChange: s8, delayDuration: l9 = 700, skipDelayDuration: c7 = 300 } = t14, u4 = w4(o13), [m7, f11] = E4.useState(null), g5 = useId(), [x5 = false, y4] = useControllableState({ prop: i8, defaultProp: a9, onChange: s8 }), [T5, C6] = E4.useState(i8 ? "instant-open" : "closed");
  E4.useEffect(() => _16.subscribe(({ state: e12, context: t15 }) => {
    e12 === "open" && t15.id === g5 ? y4(true) : y4(false);
  }), [g5, y4]), E4.useEffect(() => _16.subscribe(({ state: e12, context: t15 }) => {
    t15.id === g5 ? C6(e12 === "open" ? t15.delayed ? "delayed-open" : "instant-open" : "closed") : C6("closed");
  }), [g5]);
  const v6 = E4.useCallback(() => _16.send({ type: "FOCUS", id: g5 }), [g5]), b7 = E4.useCallback(() => _16.send({ type: "OPEN", id: g5, delayDuration: l9 }), [g5, l9]), D7 = E4.useCallback(() => _16.send({ type: "CLOSE", id: g5, skipDelayDuration: c7 }), [c7, g5]);
  return E4.useEffect(() => () => D7(), [D7]), useLayoutEffect6(() => {
    i8 === true && _16.send({ type: "OPEN", id: g5 });
  }, [g5, i8]), /* @__PURE__ */ E4.createElement(Root3, u4, /* @__PURE__ */ E4.createElement(h2, { scope: o13, contentId: g5, open: x5, stateAttribute: T5, trigger: m7, onTriggerChange: f11, onFocus: v6, onOpen: b7, onClose: D7 }, n6));
};
var TooltipTrigger = /* @__PURE__ */ E4.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeTooltip: o13 } = _a2, n6 = __objRest(_a2, ["__scopeTooltip"]), i8 = O3("TooltipTrigger", o13), s8 = w4(o13), l9 = useComposedRefs(t14, i8.onTriggerChange);
  return E4.createElement(Anchor, _extends3({ asChild: true }, s8), /* @__PURE__ */ E4.createElement(Primitive.button, _extends3({ type: "button", "aria-describedby": i8.open ? i8.contentId : void 0, "data-state": i8.stateAttribute }, n6, { ref: l9, onMouseEnter: composeEventHandlers(e12.onMouseEnter, i8.onOpen), onMouseLeave: composeEventHandlers(e12.onMouseLeave, i8.onClose), onMouseDown: composeEventHandlers(e12.onMouseDown, i8.onClose), onFocus: composeEventHandlers(e12.onFocus, i8.onFocus), onBlur: composeEventHandlers(e12.onBlur, i8.onClose), onKeyDown: composeEventHandlers(e12.onKeyDown, (e13) => {
    e13.key !== "Enter" && e13.key !== " " || i8.onClose();
  }) })));
});
var TooltipContent = /* @__PURE__ */ E4.forwardRef((e12, t14) => {
  const _a2 = e12, { forceMount: o13 } = _a2, n6 = __objRest(_a2, ["forceMount"]), r13 = O3("TooltipContent", e12.__scopeTooltip);
  return E4.createElement(Presence, { present: o13 || r13.open }, /* @__PURE__ */ E4.createElement(A3, _extends3({ ref: t14 }, n6)));
});
var A3 = /* @__PURE__ */ E4.forwardRef((e12, i8) => {
  const _a2 = e12, { __scopeTooltip: a9, children: s8, "aria-label": l9, portalled: c7 = true } = _a2, p7 = __objRest(_a2, ["__scopeTooltip", "children", "aria-label", "portalled"]), d8 = O3("TooltipContent", a9), m7 = w4(a9), f11 = c7 ? Portal : E4.Fragment;
  return useEscapeKeydown(() => d8.onClose()), /* @__PURE__ */ E4.createElement(f11, null, /* @__PURE__ */ E4.createElement(M3, { __scopeTooltip: a9 }), /* @__PURE__ */ E4.createElement(Content, _extends3({ "data-state": d8.stateAttribute }, m7, p7, { ref: i8, style: __spreadProps(__spreadValues({}, p7.style), { "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)" }) }), /* @__PURE__ */ E4.createElement(Slottable, null, s8), /* @__PURE__ */ E4.createElement(Root6, { id: d8.contentId, role: "tooltip" }, l9 || s8)));
});
var TooltipArrow = /* @__PURE__ */ E4.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeTooltip: o13 } = _a2, n6 = __objRest(_a2, ["__scopeTooltip"]), i8 = w4(o13);
  return E4.createElement(Arrow2, _extends3({}, i8, n6, { ref: t14 }));
});
function M3(e12) {
  const { __scopeTooltip: t14 } = e12, o13 = O3("CheckTriggerMoved", t14), n6 = useRect(o13.trigger), r13 = n6 == null ? void 0 : n6.left, i8 = usePrevious(r13), a9 = n6 == null ? void 0 : n6.top, s8 = usePrevious(a9), p7 = o13.onClose;
  return E4.useEffect(() => {
    (i8 !== void 0 && i8 !== r13 || s8 !== void 0 && s8 !== a9) && p7();
  }, [p7, i8, s8, r13, a9]), null;
}
var Root7 = Tooltip;
var Trigger2 = TooltipTrigger;
var Content4 = TooltipContent;
var Arrow5 = TooltipArrow;

// ../../packages/tldraw/dist/esm/index.js
var import_react83 = __toModule(require_react());
var import_react84 = __toModule(require_react());
var import_react85 = __toModule(require_react());
var import_react86 = __toModule(require_react());
var import_react87 = __toModule(require_react());
var import_react88 = __toModule(require_react());
var import_react89 = __toModule(require_react());
var import_react90 = __toModule(require_react());
var import_react91 = __toModule(require_react());
var import_react92 = __toModule(require_react());
var import_react93 = __toModule(require_react());
var import_react94 = __toModule(require_react());
var import_react95 = __toModule(require_react());
var import_react96 = __toModule(require_react());
var import_react97 = __toModule(require_react());
var import_react98 = __toModule(require_react());
var import_react99 = __toModule(require_react());
var import_react100 = __toModule(require_react());
var import_react101 = __toModule(require_react());
var import_react102 = __toModule(require_react());
var import_react103 = __toModule(require_react());
var import_react104 = __toModule(require_react());
var import_react105 = __toModule(require_react());
var import_react106 = __toModule(require_react());
var import_react107 = __toModule(require_react());
var import_react108 = __toModule(require_react());
var import_react109 = __toModule(require_react());
var import_react110 = __toModule(require_react());
var import_react111 = __toModule(require_react());
var import_react112 = __toModule(require_react());
var import_react113 = __toModule(require_react());
var import_react114 = __toModule(require_react());
var import_react115 = __toModule(require_react());

// ../../node_modules/@radix-ui/react-dialog/dist/index.module.js
var f8 = __toModule(require_react());
var [D5, v5] = createContextScope("Dialog");
var [x3, C4] = D5("Dialog");
var Dialog = (e12) => {
  const { __scopeDialog: o13, children: t14, open: r13, defaultOpen: n6, onOpenChange: a9, modal: i8 = true } = e12, l9 = f8.useRef(null), [u4 = false, p7] = useControllableState({ prop: r13, defaultProp: n6, onChange: a9 });
  return f8.createElement(x3, { scope: o13, triggerRef: l9, contentId: useId(), titleId: useId(), descriptionId: useId(), open: u4, onOpenChange: p7, onOpenToggle: f8.useCallback(() => p7((e13) => !e13), [p7]), modal: i8 }, t14);
};
var DialogTrigger = /* @__PURE__ */ f8.forwardRef((e12, o13) => {
  const _a2 = e12, { __scopeDialog: t14 } = _a2, n6 = __objRest(_a2, ["__scopeDialog"]), a9 = C4("DialogTrigger", t14), i8 = useComposedRefs(o13, a9.triggerRef);
  return f8.createElement(Primitive.button, _extends3({ type: "button", "aria-haspopup": "dialog", "aria-expanded": a9.open, "aria-controls": a9.contentId, "data-state": R4(a9.open) }, n6, { ref: i8, onClick: composeEventHandlers(e12.onClick, a9.onOpenToggle) }));
});
var DialogOverlay = /* @__PURE__ */ f8.forwardRef((e12, o13) => {
  const _a2 = e12, { forceMount: t14 } = _a2, r13 = __objRest(_a2, ["forceMount"]), a9 = C4("DialogOverlay", e12.__scopeDialog);
  return a9.modal ? /* @__PURE__ */ f8.createElement(Presence, { present: t14 || a9.open }, /* @__PURE__ */ f8.createElement(b6, _extends3({}, r13, { ref: o13 }))) : null;
});
var b6 = /* @__PURE__ */ f8.forwardRef((e12, o13) => {
  const _a2 = e12, { __scopeDialog: t14 } = _a2, n6 = __objRest(_a2, ["__scopeDialog"]), i8 = C4("DialogOverlay", t14);
  return f8.createElement(Portal, null, /* @__PURE__ */ f8.createElement(Primitive.div, _extends3({ "data-state": R4(i8.open) }, n6, { ref: o13 })));
});
var DialogContent = /* @__PURE__ */ f8.forwardRef((e12, o13) => {
  const _a2 = e12, { forceMount: t14 } = _a2, r13 = __objRest(_a2, ["forceMount"]), a9 = C4("DialogContent", e12.__scopeDialog);
  return f8.createElement(Presence, { present: t14 || a9.open }, a9.modal ? /* @__PURE__ */ f8.createElement(E5, _extends3({}, r13, { ref: o13 })) : /* @__PURE__ */ f8.createElement(_17, _extends3({}, r13, { ref: o13 })));
});
var E5 = /* @__PURE__ */ f8.forwardRef((t14, r13) => {
  const _a2 = t14, { allowPinchZoom: n6 } = _a2, i8 = __objRest(_a2, ["allowPinchZoom"]), l9 = C4("DialogContent", t14.__scopeDialog), c7 = f8.useRef(null), s8 = useComposedRefs(r13, c7);
  return f8.useEffect(() => {
    const o13 = c7.current;
    if (o13)
      return hideOthers(o13);
  }, []), /* @__PURE__ */ f8.createElement(Portal, null, /* @__PURE__ */ f8.createElement(Combination_default, { allowPinchZoom: n6 }, /* @__PURE__ */ f8.createElement(O4, _extends3({}, i8, { ref: s8, trapFocus: l9.open, disableOutsidePointerEvents: true, onCloseAutoFocus: composeEventHandlers(t14.onCloseAutoFocus, (e12) => {
    var o13;
    e12.preventDefault(), (o13 = l9.triggerRef.current) === null || o13 === void 0 || o13.focus();
  }), onPointerDownOutside: composeEventHandlers(t14.onPointerDownOutside, (e12) => {
    const o13 = e12.detail.originalEvent, t15 = o13.button === 0 && o13.ctrlKey === true;
    (o13.button === 2 || t15) && e12.preventDefault();
  }), onFocusOutside: composeEventHandlers(t14.onFocusOutside, (e12) => e12.preventDefault()) }))));
});
var _17 = /* @__PURE__ */ f8.forwardRef((e12, o13) => {
  const t14 = C4("DialogContent", e12.__scopeDialog), r13 = f8.useRef(false);
  return f8.createElement(Portal, null, /* @__PURE__ */ f8.createElement(O4, _extends3({}, e12, { ref: o13, trapFocus: false, disableOutsidePointerEvents: false, onCloseAutoFocus: (o14) => {
    var n6, a9;
    ((n6 = e12.onCloseAutoFocus) === null || n6 === void 0 || n6.call(e12, o14), o14.defaultPrevented) || (r13.current || (a9 = t14.triggerRef.current) === null || a9 === void 0 || a9.focus(), o14.preventDefault());
    r13.current = false;
  }, onInteractOutside: (o14) => {
    var n6, a9;
    (n6 = e12.onInteractOutside) === null || n6 === void 0 || n6.call(e12, o14), o14.defaultPrevented || (r13.current = true);
    const i8 = o14.target;
    ((a9 = t14.triggerRef.current) === null || a9 === void 0 ? void 0 : a9.contains(i8)) && o14.preventDefault();
  } })));
});
var O4 = /* @__PURE__ */ f8.forwardRef((e12, o13) => {
  const _a2 = e12, { __scopeDialog: r13, "aria-label": n6, "aria-labelledby": a9, "aria-describedby": c7, trapFocus: s8, onOpenAutoFocus: u4, onCloseAutoFocus: p7 } = _a2, g5 = __objRest(_a2, ["__scopeDialog", "aria-label", "aria-labelledby", "aria-describedby", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus"]), D7 = C4("DialogContent", r13), v6 = f8.useRef(null), x5 = useComposedRefs(o13, v6);
  return useFocusGuards(), /* @__PURE__ */ f8.createElement(f8.Fragment, null, /* @__PURE__ */ f8.createElement(FocusScope, { asChild: true, loop: true, trapped: s8, onMountAutoFocus: u4, onUnmountAutoFocus: p7 }, /* @__PURE__ */ f8.createElement(DismissableLayer, _extends3({ role: "dialog", id: D7.contentId, "aria-describedby": c7 || D7.descriptionId, "aria-labelledby": n6 ? void 0 : a9 || D7.titleId, "aria-label": n6 || void 0, "data-state": R4(D7.open) }, g5, { ref: x5, onDismiss: () => D7.onOpenChange(false) }))), false);
});
var DialogClose = /* @__PURE__ */ f8.forwardRef((e12, o13) => {
  const _a2 = e12, { __scopeDialog: t14 } = _a2, n6 = __objRest(_a2, ["__scopeDialog"]), a9 = C4("DialogClose", t14);
  return f8.createElement(Primitive.button, _extends3({ type: "button" }, n6, { ref: o13, onClick: composeEventHandlers(e12.onClick, () => a9.onOpenChange(false)) }));
});
function R4(e12) {
  return e12 ? "open" : "closed";
}
var [w5, F4] = createContext3("DialogLabelWarning", { contentName: "DialogContent", titleName: "DialogTitle", docsSlug: "dialog" });
var Root8 = Dialog;
var Trigger3 = DialogTrigger;
var Overlay3 = DialogOverlay;
var Content5 = DialogContent;
var Close = DialogClose;

// ../../node_modules/@radix-ui/react-alert-dialog/dist/index.module.js
var a8 = __toModule(require_react());
var [c6, s6] = createContextScope("AlertDialog", [v5]);
var p5 = v5();
var AlertDialog = (e12) => {
  const _a2 = e12, { __scopeAlertDialog: t14 } = _a2, o13 = __objRest(_a2, ["__scopeAlertDialog"]), l9 = p5(t14);
  return a8.createElement(Root8, _extends3({}, l9, o13, { modal: true }));
};
var AlertDialogTrigger = /* @__PURE__ */ a8.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeAlertDialog: o13 } = _a2, l9 = __objRest(_a2, ["__scopeAlertDialog"]), n6 = p5(o13);
  return a8.createElement(Trigger3, _extends3({}, n6, l9, { ref: t14 }));
});
var AlertDialogOverlay = /* @__PURE__ */ a8.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeAlertDialog: o13 } = _a2, l9 = __objRest(_a2, ["__scopeAlertDialog"]), n6 = p5(o13);
  return a8.createElement(Overlay3, _extends3({}, n6, l9, { ref: t14 }));
});
var [g4, f9] = c6("AlertDialogContent");
var AlertDialogContent = /* @__PURE__ */ a8.forwardRef((o13, n6) => {
  const _a2 = o13, { __scopeAlertDialog: c7, children: s8 } = _a2, f11 = __objRest(_a2, ["__scopeAlertDialog", "children"]), m7 = p5(c7), A4 = a8.useRef(null), u4 = useComposedRefs(n6, A4), d8 = a8.useRef(null);
  return a8.createElement(w5, { contentName: "AlertDialogContent", titleName: D6, docsSlug: "alert-dialog" }, /* @__PURE__ */ a8.createElement(g4, { scope: c7, cancelRef: d8 }, /* @__PURE__ */ a8.createElement(Content5, _extends3({ role: "alertdialog" }, m7, f11, { ref: u4, onOpenAutoFocus: composeEventHandlers(f11.onOpenAutoFocus, (e12) => {
    var t14;
    e12.preventDefault(), (t14 = d8.current) === null || t14 === void 0 || t14.focus({ preventScroll: true });
  }), onPointerDownOutside: (e12) => e12.preventDefault(), onInteractOutside: (e12) => e12.preventDefault() }), /* @__PURE__ */ a8.createElement(Slottable, null, s8), false)));
});
var D6 = "AlertDialogTitle";
var AlertDialogAction = /* @__PURE__ */ a8.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeAlertDialog: o13 } = _a2, l9 = __objRest(_a2, ["__scopeAlertDialog"]), n6 = p5(o13);
  return a8.createElement(Close, _extends3({}, n6, l9, { ref: t14 }));
});
var AlertDialogCancel = /* @__PURE__ */ a8.forwardRef((e12, t14) => {
  const _a2 = e12, { __scopeAlertDialog: o13 } = _a2, n6 = __objRest(_a2, ["__scopeAlertDialog"]), { cancelRef: c7 } = f9("AlertDialogCancel", o13), s8 = p5(o13), g5 = useComposedRefs(t14, c7);
  return a8.createElement(Close, _extends3({}, s8, n6, { ref: g5 }));
});
var Root9 = AlertDialog;
var Trigger4 = AlertDialogTrigger;
var Overlay4 = AlertDialogOverlay;
var Content6 = AlertDialogContent;
var Action = AlertDialogAction;
var Cancel = AlertDialogCancel;

// ../../packages/tldraw/dist/esm/index.js
var import_react116 = __toModule(require_react());
var import_react117 = __toModule(require_react());
var import_react118 = __toModule(require_react());

// ../../node_modules/@radix-ui/react-context-menu/dist/index.module.js
var u3 = __toModule(require_react());
var [s7, i7] = createContextScope("ContextMenu", [S2]);
var x4 = S2();
var [p6, C5] = s7("ContextMenu");
var ContextMenu = (n6) => {
  const { __scopeContextMenu: o13, children: r13, onOpenChange: c7, dir: s8, modal: i8 = true } = n6, [C6, m7] = u3.useState(false), f11 = l8("ContextMenu", o13), d8 = x4(o13), M4 = useCallbackRef(c7), R5 = u3.useCallback((e12) => {
    m7(e12), M4(e12);
  }, [M4]);
  return f11.isInsideContent ? /* @__PURE__ */ u3.createElement(p6, { scope: o13, isRootMenu: false, open: C6, onOpenChange: R5, modal: i8 }, /* @__PURE__ */ u3.createElement(Sub, _extends3({}, d8, { open: C6, onOpenChange: R5 }), r13)) : /* @__PURE__ */ u3.createElement(p6, { scope: o13, isRootMenu: true, open: C6, onOpenChange: R5, modal: i8 }, /* @__PURE__ */ u3.createElement(Root4, _extends3({}, d8, { dir: s8, open: C6, onOpenChange: R5, modal: i8 }), r13));
};
var ContextMenuTrigger = /* @__PURE__ */ u3.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeContextMenu: r13 } = _a2, s8 = __objRest(_a2, ["__scopeContextMenu"]), i8 = C5("ContextMenuTrigger", r13), p7 = x4(r13), l9 = u3.useRef({ x: 0, y: 0 }), f11 = u3.useRef({ getBoundingClientRect: () => DOMRect.fromRect(__spreadValues({ width: 0, height: 0 }, l9.current)) }), M4 = u3.useRef(0), R5 = u3.useCallback(() => window.clearTimeout(M4.current), []), _18 = (e13) => {
    l9.current = { x: e13.clientX, y: e13.clientY }, i8.onOpenChange(true);
  };
  return u3.useEffect(() => R5, [R5]), /* @__PURE__ */ u3.createElement(m6, { scope: r13, isInsideContent: false }, /* @__PURE__ */ u3.createElement(Anchor2, _extends3({}, p7, { virtualRef: f11 })), /* @__PURE__ */ u3.createElement(Primitive.span, _extends3({}, s8, { ref: n6, style: __spreadValues({ WebkitTouchCallout: "none" }, e12.style), onContextMenu: composeEventHandlers(e12.onContextMenu, (e13) => {
    R5(), e13.preventDefault(), _18(e13);
  }), onPointerDown: composeEventHandlers(e12.onPointerDown, d7((e13) => {
    R5(), M4.current = window.setTimeout(() => _18(e13), 700);
  })), onPointerMove: composeEventHandlers(e12.onPointerMove, d7(R5)), onPointerCancel: composeEventHandlers(e12.onPointerCancel, d7(R5)), onPointerUp: composeEventHandlers(e12.onPointerUp, d7(R5)) })));
});
var [m6, l8] = s7("ContextMenuContent", { isInsideContent: false });
var ContextMenuContent = /* @__PURE__ */ u3.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeContextMenu: o13 } = _a2, r13 = __objRest(_a2, ["__scopeContextMenu"]), c7 = C5("ContextMenuContent", o13), s8 = x4(o13), i8 = __spreadProps(__spreadValues({}, r13), { style: __spreadProps(__spreadValues({}, e12.style), { "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)" }) });
  return u3.createElement(m6, { scope: o13, isInsideContent: true }, c7.isRootMenu ? /* @__PURE__ */ u3.createElement(f10, _extends3({ __scopeContextMenu: o13 }, i8, { ref: n6 })) : /* @__PURE__ */ u3.createElement(Content2, _extends3({}, s8, i8, { ref: n6 })));
});
var f10 = /* @__PURE__ */ u3.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeContextMenu: o13 } = _a2, r13 = __objRest(_a2, ["__scopeContextMenu"]), c7 = C5("ContextMenuContent", o13), s8 = x4(o13), i8 = u3.useRef(false);
  return u3.createElement(Content2, _extends3({}, s8, r13, { ref: n6, portalled: true, side: "right", sideOffset: 2, align: "start", onCloseAutoFocus: (t14) => {
    var n7;
    (n7 = e12.onCloseAutoFocus) === null || n7 === void 0 || n7.call(e12, t14), !t14.defaultPrevented && i8.current && t14.preventDefault(), i8.current = false;
  }, onInteractOutside: (t14) => {
    var n7;
    (n7 = e12.onInteractOutside) === null || n7 === void 0 || n7.call(e12, t14), t14.defaultPrevented || c7.modal || (i8.current = true);
  } }));
});
var ContextMenuItem = /* @__PURE__ */ u3.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeContextMenu: o13 } = _a2, r13 = __objRest(_a2, ["__scopeContextMenu"]), c7 = x4(o13);
  return u3.createElement(Item2, _extends3({}, c7, r13, { ref: n6 }));
});
var ContextMenuTriggerItem = /* @__PURE__ */ u3.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeContextMenu: o13 } = _a2, r13 = __objRest(_a2, ["__scopeContextMenu"]), c7 = x4(o13);
  return u3.createElement(SubTrigger, _extends3({}, c7, r13, { ref: n6 }));
});
var ContextMenuArrow = /* @__PURE__ */ u3.forwardRef((e12, n6) => {
  const _a2 = e12, { __scopeContextMenu: o13 } = _a2, r13 = __objRest(_a2, ["__scopeContextMenu"]), c7 = x4(o13);
  return u3.createElement(Arrow3, _extends3({}, c7, r13, { ref: n6 }));
});
function d7(e12) {
  return (t14) => t14.pointerType !== "mouse" ? e12(t14) : void 0;
}
var Root10 = ContextMenu;
var Trigger5 = ContextMenuTrigger;
var Content7 = ContextMenuContent;

// ../../packages/tldraw/dist/esm/index.js
var import_react119 = __toModule(require_react());
var __create2 = Object.create;
var __defProp4 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a9, b7) => {
  for (var prop in b7 || (b7 = {}))
    if (__hasOwnProp4.call(b7, prop))
      __defNormalProp4(a9, prop, b7[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b7)) {
      if (__propIsEnum4.call(b7, prop))
        __defNormalProp4(a9, prop, b7[prop]);
    }
  return a9;
};
var __spreadProps4 = (a9, b7) => __defProps4(a9, __getOwnPropDescs4(b7));
var __markAsModule2 = (target) => __defProp4(target, "__esModule", { value: true });
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule2(target);
  for (var name in all)
    __defProp4(target, name, { get: all[name], enumerable: true });
};
var __reExport2 = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp4.call(target, key) && key !== "default")
        __defProp4(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule2 = (module2) => {
  return __reExport2(__markAsModule2(__defProp4(module2 != null ? __create2(__getProtoOf2(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e12) {
        reject(e12);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e12) {
        reject(e12);
      }
    };
    var step = (x5) => x5.done ? resolve(x5.value) : Promise.resolve(x5.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var require_browser_fs_access = __commonJS2({
  "src/state/data/browser-fs-access/index.js"(exports2) {
    var w6 = Object.defineProperty;
    var q3 = (e12) => w6(e12, "__esModule", { value: true });
    var u4 = (e12, t22) => () => e12 && (t22 = e12(e12 = 0));
    var p7 = (e12, t22) => {
      q3(e12);
      for (var i8 in t22)
        w6(e12, i8, { get: t22[i8], enumerable: true });
    };
    var r13 = (e12, t22, i8) => new Promise((d8, a9) => {
      var l9 = (s8) => {
        try {
          n6(i8.next(s8));
        } catch (o13) {
          a9(o13);
        }
      }, c7 = (s8) => {
        try {
          n6(i8.throw(s8));
        } catch (o13) {
          a9(o13);
        }
      }, n6 = (s8) => s8.done ? d8(s8.value) : Promise.resolve(s8.value).then(l9, c7);
      n6((i8 = i8.apply(e12, t22)).next());
    });
    var y4 = {};
    p7(y4, { default: () => z3 });
    var z3;
    var v6 = u4(() => {
      z3 = (...t22) => r13(void 0, [...t22], function* (e12 = {}) {
        return new Promise((i8, d8) => {
          let a9 = document.createElement("input");
          a9.type = "file";
          let l9 = [...e12.mimeTypes ? e12.mimeTypes : [], e12.extensions ? e12.extensions : []].join();
          a9.multiple = e12.multiple || false, a9.accept = l9 || "";
          let c7, n6 = () => c7(d8);
          e12.setupLegacyCleanupAndRejection ? c7 = e12.setupLegacyCleanupAndRejection(n6) : (c7 = (s8) => {
            window.removeEventListener("pointermove", n6), window.removeEventListener("pointerdown", n6), window.removeEventListener("keydown", n6), s8 && s8(new DOMException("The user aborted a request.", "AbortError"));
          }, window.addEventListener("pointermove", n6), window.addEventListener("pointerdown", n6), window.addEventListener("keydown", n6)), a9.addEventListener("change", () => {
            c7(), i8(a9.multiple ? Array.from(a9.files) : a9.files[0]);
          }), a9.click();
        });
      });
    });
    var E6 = {};
    p7(E6, { default: () => B3 });
    var h3;
    var B3;
    var j4 = u4(() => {
      ;
      h3 = (e12) => r13(void 0, null, function* () {
        let t22 = yield e12.getFile();
        return t22.handle = e12, t22;
      }), B3 = (...t22) => r13(void 0, [...t22], function* (e12 = {}) {
        let i8 = yield window.chooseFileSystemEntries({
          accepts: [
            {
              description: e12.description || "",
              mimeTypes: e12.mimeTypes || ["*/*"],
              extensions: e12.extensions || [""]
            }
          ],
          multiple: e12.multiple || false
        });
        return e12.multiple ? Promise.all(i8.map(h3)) : h3(i8);
      });
    });
    var g5 = {};
    p7(g5, { default: () => I3 });
    var G4;
    var I3;
    var x5 = u4(() => {
      ;
      G4 = (e12) => r13(void 0, null, function* () {
        let t22 = yield e12.getFile();
        return t22.handle = e12, t22;
      }), I3 = (...t22) => r13(void 0, [...t22], function* (e12 = {}) {
        let i8 = {};
        e12.mimeTypes ? e12.mimeTypes.map((l9) => {
          i8[l9] = e12.extensions || [];
        }) : i8["*/*"] = e12.extensions || [];
        let d8 = yield window.showOpenFilePicker({
          types: [{ description: e12.description || "", accept: i8 }],
          multiple: e12.multiple || false
        }), a9 = yield Promise.all(d8.map(G4));
        return e12.multiple ? a9 : a9[0];
      });
    });
    var F5 = {};
    p7(F5, { default: () => K2 });
    var K2;
    var k3 = u4(() => {
      K2 = (...t22) => r13(void 0, [...t22], function* (e12 = {}) {
        return e12.recursive = e12.recursive || false, new Promise((i8, d8) => {
          let a9 = document.createElement("input");
          a9.type = "file", a9.webkitdirectory = true;
          let l9, c7 = () => l9(d8);
          e12.setupLegacyCleanupAndRejection ? l9 = e12.setupLegacyCleanupAndRejection(c7) : (l9 = (n6) => {
            window.removeEventListener("pointermove", c7), window.removeEventListener("pointerdown", c7), window.removeEventListener("keydown", c7), n6 && n6(new DOMException("The user aborted a request.", "AbortError"));
          }, window.addEventListener("pointermove", c7), window.addEventListener("pointerdown", c7), window.addEventListener("keydown", c7)), a9.addEventListener("change", () => {
            l9();
            let n6 = Array.from(a9.files);
            e12.recursive || (n6 = n6.filter((s8) => s8.webkitRelativePath.split("/").length === 2)), i8(n6);
          }), a9.click();
        });
      });
    });
    var b7 = {};
    p7(b7, { default: () => Q });
    var P3;
    var Q;
    var O5 = u4(() => {
      ;
      P3 = (d8, a9, ...l9) => r13(void 0, [d8, a9, ...l9], function* (e12, t22, i8 = e12.name) {
        let c7 = [], n6 = [];
        for (let s8 of e12.getEntries()) {
          let o13 = `${i8}/${s8.name}`;
          s8.isFile ? n6.push(yield s8.getFile().then((f11) => (f11.directoryHandle = e12, Object.defineProperty(f11, "webkitRelativePath", {
            configurable: true,
            enumerable: true,
            get: () => o13
          })))) : s8.isDirectory && t22 && c7.push(yield P3(s8, t22, o13));
        }
        return [...(yield Promise.all(c7)).flat(), ...yield Promise.all(n6)];
      }), Q = (...t22) => r13(void 0, [...t22], function* (e12 = {}) {
        e12.recursive = e12.recursive || false;
        let i8 = yield window.chooseFileSystemEntries({ type: "open-directory" });
        return P3(i8, e12.recursive);
      });
    });
    var T5 = {};
    p7(T5, { default: () => V5 });
    var R5;
    var V5;
    var S3 = u4(() => {
      ;
      R5 = (d8, a9, ...l9) => r13(void 0, [d8, a9, ...l9], function* (e12, t22, i8 = e12.name) {
        let c7 = [], n6 = [];
        for (let s8 of e12.values()) {
          let o13 = `${i8}/${s8.name}`;
          s8.kind === "file" ? n6.push(yield s8.getFile().then((f11) => (f11.directoryHandle = e12, Object.defineProperty(f11, "webkitRelativePath", {
            configurable: true,
            enumerable: true,
            get: () => o13
          })))) : s8.kind === "directory" && t22 && c7.push(yield R5(s8, t22, o13));
        }
        return [...(yield Promise.all(c7)).flat(), ...yield Promise.all(n6)];
      }), V5 = (...t22) => r13(void 0, [...t22], function* (e12 = {}) {
        e12.recursive = e12.recursive || false;
        let i8 = yield window.showDirectoryPicker();
        return R5(i8, e12.recursive);
      });
    });
    var N2 = {};
    p7(N2, { default: () => Y4 });
    var Y4;
    var U3 = u4(() => {
      Y4 = (i8, ...d8) => r13(void 0, [i8, ...d8], function* (e12, t22 = {}) {
        let a9 = document.createElement("a");
        a9.download = t22.fileName || "Untitled", a9.href = URL.createObjectURL(e12), a9.addEventListener("click", () => {
          setTimeout(() => URL.revokeObjectURL(a9.href), 30 * 1e3);
        }), a9.click();
      });
    });
    var C6 = {};
    p7(C6, { default: () => Z4 });
    var Z4;
    var D7 = u4(() => {
      Z4 = (d8, ...a9) => r13(void 0, [d8, ...a9], function* (e12, t22 = {}, i8 = null) {
        ;
        t22.fileName = t22.fileName || "Untitled", i8 = i8 || (yield window.chooseFileSystemEntries({
          type: "save-file",
          accepts: [
            {
              description: t22.description || "",
              mimeTypes: [e12.type],
              extensions: t22.extensions || [""]
            }
          ]
        }));
        let l9 = yield i8.createWritable();
        return yield l9.write(e12), yield l9.close(), i8;
      });
    });
    var M4 = {};
    p7(M4, { default: () => _18 });
    var _18;
    var W4 = u4(() => {
      _18 = (a9, ...l9) => r13(void 0, [a9, ...l9], function* (e12, t22 = {}, i8 = null, d8 = false) {
        t22.fileName = t22.fileName || "Untitled";
        let c7 = {};
        if (t22.mimeTypes ? (t22.mimeTypes.push(e12.type), t22.mimeTypes.map((o13) => {
          c7[o13] = t22.extensions || [];
        })) : c7[e12.type] = t22.extensions || [], i8)
          try {
            yield i8.getFile();
          } catch (o13) {
            if (i8 = null, d8)
              throw o13;
          }
        let n6 = i8 || (yield window.showSaveFilePicker({
          suggestedName: t22.fileName,
          types: [{ description: t22.description || "", accept: c7 }]
        })), s8 = yield n6.createWritable();
        return yield s8.write(e12), yield s8.close(), n6;
      });
    });
    p7(exports2, { directoryOpen: () => A4, fileOpen: () => L4, fileSave: () => $2, supported: () => m7 });
    var H3 = (() => {
      if ("top" in self && self !== top)
        try {
          top.location + "";
        } catch (e12) {
          return false;
        }
      else {
        if ("chooseFileSystemEntries" in self)
          return "chooseFileSystemEntries";
        if ("showOpenFilePicker" in self)
          return "showOpenFilePicker";
      }
      return false;
    })();
    var m7 = H3;
    var J3 = m7 ? m7 === "chooseFileSystemEntries" ? Promise.resolve().then(() => (j4(), E6)) : Promise.resolve().then(() => (x5(), g5)) : Promise.resolve().then(() => (v6(), y4));
    function L4(...e12) {
      return r13(this, null, function* () {
        return (yield J3).default(...e12);
      });
    }
    var X2 = m7 ? m7 === "chooseFileSystemEntries" ? Promise.resolve().then(() => (O5(), b7)) : Promise.resolve().then(() => (S3(), T5)) : Promise.resolve().then(() => (k3(), F5));
    function A4(...e12) {
      return r13(this, null, function* () {
        return (yield X2).default(...e12);
      });
    }
    var ee = m7 ? m7 === "chooseFileSystemEntries" ? Promise.resolve().then(() => (D7(), C6)) : Promise.resolve().then(() => (W4(), M4)) : Promise.resolve().then(() => (U3(), N2));
    function $2(...e12) {
      return r13(this, null, function* () {
        return (yield ee).default(...e12);
      });
    }
  }
});
var { styled, createTheme } = q({
  themeMap: __spreadValues4({}, n),
  theme: {
    colors: {
      bounds: "rgba(65, 132, 244, 1.000)",
      boundsBg: "rgba(65, 132, 244, 0.05)",
      hover: "#ececec",
      overlay: "rgba(0, 0, 0, 0.15)",
      overlayContrast: "rgba(255, 255, 255, 0.15)",
      panel: "#fefefe",
      panelContrast: "#ffffff",
      selected: "rgba(66, 133, 244, 1.000)",
      selectedContrast: "#fefefe",
      sponsor: "#ec6cb9",
      sponsorContrast: "#ec6cb944",
      text: "#333333",
      tooltip: "#1d1d1d",
      tooltipContrast: "#ffffff",
      warn: "rgba(255, 100, 100, 1)"
    },
    shadows: {
      2: "0px 1px 1px rgba(0, 0, 0, 0.14)",
      3: "0px 2px 3px rgba(0, 0, 0, 0.14)",
      4: "0px 4px 5px -1px rgba(0, 0, 0, 0.14)",
      8: "0px 12px 17px rgba(0, 0, 0, 0.14)",
      12: "0px 12px 17px rgba(0, 0, 0, 0.14)",
      24: "0px 24px 38px rgba(0, 0, 0, 0.14)",
      key: "1px 1px rgba(0,0,0,1)",
      panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), 
        0px 0px 16px -8px rgba(0, 0, 0, 0.05), 
        0px 0px 16px -12px rgba(0, 0, 0, 0.12),
        0px 0px 2px 0px rgba(0, 0, 0, 0.08)`
    },
    space: {
      0: "2px",
      1: "3px",
      2: "4px",
      3: "8px",
      4: "12px",
      5: "16px"
    },
    fontSizes: {
      0: "10px",
      1: "12px",
      2: "13px",
      3: "16px",
      4: "18px"
    },
    fonts: {
      ui: '"Recursive", system-ui, sans-serif',
      body: '"Recursive", system-ui, sans-serif',
      mono: '"Recursive Mono", monospace'
    },
    fontWeights: {},
    lineHeights: {},
    letterSpacings: {},
    sizes: {},
    borderWidths: {
      0: "$1"
    },
    borderStyles: {},
    radii: {
      0: "2px",
      1: "4px",
      2: "8px",
      3: "12px",
      4: "16px"
    },
    zIndices: {},
    transitions: {}
  },
  media: {
    micro: "(max-width: 370px)",
    sm: "(min-width: 640px)",
    md: "(min-width: 768px)",
    lg: "(min-width: 1024px)"
  },
  utils: {
    zStrokeWidth: () => (value) => {
      if (Array.isArray(value)) {
        return {
          strokeWidth: `calc(${value[0]}px / var(--camera-zoom))`
        };
      }
      return {
        strokeWidth: `calc(${value}px / var(--camera-zoom))`
      };
    }
  }
});
var dark = createTheme({
  colors: {
    bounds: "rgba(38, 150, 255, 1.000)",
    boundsBg: "rgba(38, 150, 255, 0.05)",
    hover: "#444A50",
    overlay: "rgba(0, 0, 0, 0.15)",
    overlayContrast: "rgba(255, 255, 255, 0.15)",
    panel: "#363D44",
    panelContrast: "#49555f",
    selected: "rgba(38, 150, 255, 1.000)",
    selectedContrast: "#fefefe",
    text: "#f8f9fa",
    tooltip: "#1d1d1d",
    tooltipContrast: "#ffffff"
  },
  shadows: {
    2: "0px 1px 1px rgba(0, 0, 0, 0.24)",
    3: "0px 2px 3px rgba(0, 0, 0, 0.24)",
    4: "0px 4px 5px -1px rgba(0, 0, 0, 0.24)",
    8: "0px 12px 17px rgba(0, 0, 0, 0.24)",
    12: "0px 12px 17px rgba(0, 0, 0, 0.24)",
    24: "0px 24px 38px rgba(0, 0, 0, 0.24)",
    panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), 
      0px 0px 16px -8px rgba(0, 0, 0, 0.09), 
      0px 0px 16px -12px rgba(0, 0, 0, 0.2)`
  }
});
var TDEventHandler = class {
};
var TDUserStatus;
(function(TDUserStatus2) {
  TDUserStatus2["Idle"] = "idle";
  TDUserStatus2["Connecting"] = "connecting";
  TDUserStatus2["Connected"] = "connected";
  TDUserStatus2["Disconnected"] = "disconnected";
})(TDUserStatus || (TDUserStatus = {}));
var SessionType;
(function(SessionType2) {
  SessionType2["Transform"] = "transform";
  SessionType2["Translate"] = "translate";
  SessionType2["TransformSingle"] = "transformSingle";
  SessionType2["Brush"] = "brush";
  SessionType2["Arrow"] = "arrow";
  SessionType2["Draw"] = "draw";
  SessionType2["Erase"] = "erase";
  SessionType2["Rotate"] = "rotate";
  SessionType2["Handle"] = "handle";
  SessionType2["Grid"] = "grid";
})(SessionType || (SessionType = {}));
var TDStatus;
(function(TDStatus2) {
  TDStatus2["Idle"] = "idle";
  TDStatus2["PointingHandle"] = "pointingHandle";
  TDStatus2["PointingBounds"] = "pointingBounds";
  TDStatus2["PointingBoundsHandle"] = "pointingBoundsHandle";
  TDStatus2["TranslatingHandle"] = "translatingHandle";
  TDStatus2["Translating"] = "translating";
  TDStatus2["Transforming"] = "transforming";
  TDStatus2["Rotating"] = "rotating";
  TDStatus2["Pinching"] = "pinching";
  TDStatus2["Brushing"] = "brushing";
  TDStatus2["Creating"] = "creating";
  TDStatus2["EditingText"] = "editing-text";
})(TDStatus || (TDStatus = {}));
var MoveType;
(function(MoveType2) {
  MoveType2["Backward"] = "backward";
  MoveType2["Forward"] = "forward";
  MoveType2["ToFront"] = "toFront";
  MoveType2["ToBack"] = "toBack";
})(MoveType || (MoveType = {}));
var AlignType;
(function(AlignType3) {
  AlignType3["Top"] = "top";
  AlignType3["CenterVertical"] = "centerVertical";
  AlignType3["Bottom"] = "bottom";
  AlignType3["Left"] = "left";
  AlignType3["CenterHorizontal"] = "centerHorizontal";
  AlignType3["Right"] = "right";
})(AlignType || (AlignType = {}));
var StretchType;
(function(StretchType3) {
  StretchType3["Horizontal"] = "horizontal";
  StretchType3["Vertical"] = "vertical";
})(StretchType || (StretchType = {}));
var DistributeType;
(function(DistributeType3) {
  DistributeType3["Horizontal"] = "horizontal";
  DistributeType3["Vertical"] = "vertical";
})(DistributeType || (DistributeType = {}));
var FlipType;
(function(FlipType2) {
  FlipType2["Horizontal"] = "horizontal";
  FlipType2["Vertical"] = "vertical";
})(FlipType || (FlipType = {}));
var TDShapeType;
(function(TDShapeType2) {
  TDShapeType2["Sticky"] = "sticky";
  TDShapeType2["Ellipse"] = "ellipse";
  TDShapeType2["Rectangle"] = "rectangle";
  TDShapeType2["Triangle"] = "triangle";
  TDShapeType2["Draw"] = "draw";
  TDShapeType2["Arrow"] = "arrow";
  TDShapeType2["Line"] = "line";
  TDShapeType2["Text"] = "text";
  TDShapeType2["Group"] = "group";
})(TDShapeType || (TDShapeType = {}));
var Decoration;
(function(Decoration2) {
  Decoration2["Arrow"] = "arrow";
})(Decoration || (Decoration = {}));
var ColorStyle;
(function(ColorStyle3) {
  ColorStyle3["White"] = "white";
  ColorStyle3["LightGray"] = "lightGray";
  ColorStyle3["Gray"] = "gray";
  ColorStyle3["Black"] = "black";
  ColorStyle3["Green"] = "green";
  ColorStyle3["Cyan"] = "cyan";
  ColorStyle3["Blue"] = "blue";
  ColorStyle3["Indigo"] = "indigo";
  ColorStyle3["Violet"] = "violet";
  ColorStyle3["Red"] = "red";
  ColorStyle3["Orange"] = "orange";
  ColorStyle3["Yellow"] = "yellow";
})(ColorStyle || (ColorStyle = {}));
var SizeStyle;
(function(SizeStyle2) {
  SizeStyle2["Small"] = "small";
  SizeStyle2["Medium"] = "medium";
  SizeStyle2["Large"] = "large";
})(SizeStyle || (SizeStyle = {}));
var DashStyle;
(function(DashStyle2) {
  DashStyle2["Draw"] = "draw";
  DashStyle2["Solid"] = "solid";
  DashStyle2["Dashed"] = "dashed";
  DashStyle2["Dotted"] = "dotted";
})(DashStyle || (DashStyle = {}));
var FontSize;
(function(FontSize2) {
  FontSize2["Small"] = "small";
  FontSize2["Medium"] = "medium";
  FontSize2["Large"] = "large";
  FontSize2["ExtraLarge"] = "extraLarge";
})(FontSize || (FontSize = {}));
var AlignStyle;
(function(AlignStyle2) {
  AlignStyle2["Start"] = "start";
  AlignStyle2["Middle"] = "middle";
  AlignStyle2["End"] = "end";
  AlignStyle2["Justify"] = "justify";
})(AlignStyle || (AlignStyle = {}));
var FontStyle;
(function(FontStyle2) {
  FontStyle2["Script"] = "script";
  FontStyle2["Sans"] = "sans";
  FontStyle2["Serif"] = "erif";
  FontStyle2["Mono"] = "mono";
})(FontStyle || (FontStyle = {}));
var data_exports = {};
__export(data_exports, {
  loadFileHandle: () => loadFileHandle,
  migrate: () => migrate,
  openFromFileSystem: () => openFromFileSystem,
  saveFileHandle: () => saveFileHandle,
  saveToFileSystem: () => saveToFileSystem
});
function migrate(document2, newVersion) {
  const { version = 0 } = document2;
  if (version === newVersion)
    return document2;
  if (version < 14) {
    Object.values(document2.pages).forEach((page) => {
      Object.values(page.shapes).filter((shape) => shape.type === TDShapeType.Text).forEach((shape) => shape.style.font === FontStyle.Script);
    });
  }
  if (version <= 13) {
    Object.values(document2.pages).forEach((page) => {
      Object.values(page.bindings).forEach((binding) => {
        Object.assign(binding, binding.meta);
      });
      Object.values(page.shapes).forEach((shape) => {
        Object.entries(shape.style).forEach(([id, style]) => {
          if (typeof style === "string") {
            shape.style[id] = style.toLowerCase();
          }
        });
        if (shape.type === TDShapeType.Arrow) {
          if (shape.decorations) {
            Object.entries(shape.decorations).forEach(([id, decoration]) => {
              if (decoration === "Arrow") {
                shape.decorations = __spreadProps4(__spreadValues4({}, shape.decorations), {
                  [id]: Decoration.Arrow
                });
              }
            });
          }
        }
      });
    });
  }
  if (version <= 13.1) {
    document2.name = "New Document";
  }
  Object.values(document2.pageStates).forEach((pageState) => {
    pageState.selectedIds = pageState.selectedIds.filter((id) => {
      return document2.pages[pageState.id].shapes[id] !== void 0;
    });
    pageState.bindingId = void 0;
    pageState.editingId = void 0;
    pageState.hoveredId = void 0;
    pageState.pointedId = void 0;
  });
  document2.version = newVersion;
  return document2;
}
var import_browser_fs_access = __toModule2(require_browser_fs_access());
var options = { mode: "readwrite" };
var checkPermissions = (handle) => __async(void 0, null, function* () {
  return (yield handle.queryPermission(options)) === "granted" || (yield handle.requestPermission(options)) === "granted";
});
function loadFileHandle() {
  return __async(this, null, function* () {
    const fileHandle = yield get4(`Tldraw_file_handle_${window.location.origin}`);
    if (!fileHandle)
      return null;
    return fileHandle;
  });
}
function saveFileHandle(fileHandle) {
  return __async(this, null, function* () {
    return set5(`Tldraw_file_handle_${window.location.origin}`, fileHandle);
  });
}
function saveToFileSystem(document2, fileHandle) {
  return __async(this, null, function* () {
    const file = {
      name: document2.name || "New Document",
      fileHandle: fileHandle != null ? fileHandle : null,
      document: document2,
      assets: {}
    };
    const json = JSON.stringify(file, null, 2);
    const blob = new Blob([json], {
      type: "application/json"
    });
    if (fileHandle) {
      const hasPermissions = yield checkPermissions(fileHandle);
      if (!hasPermissions)
        return null;
    }
    const newFileHandle = yield (0, import_browser_fs_access.fileSave)(blob, {
      fileName: `${file.name}.json`,
      description: "Draw File",
      extensions: [`.json`]
    }, fileHandle);
    yield saveFileHandle(newFileHandle);
    return newFileHandle;
  });
}
function openFromFileSystem() {
  return __async(this, null, function* () {
    var _a2;
    const blob = yield (0, import_browser_fs_access.fileOpen)({
      description: "Draw File",
      extensions: [`.json`],
      multiple: false
    });
    if (!blob)
      return null;
    const json = yield new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (reader.readyState === FileReader.DONE) {
          resolve(reader.result);
        }
      };
      reader.readAsText(blob, "utf8");
    });
    const file = JSON.parse(json);
    const fileHandle = (_a2 = blob.handle) != null ? _a2 : null;
    yield saveFileHandle(fileHandle);
    return {
      fileHandle,
      document: file.document
    };
  });
}
__reExport2(data_exports, __toModule2(require_browser_fs_access()));
var GRID_SIZE = 8;
var BINDING_DISTANCE = 16;
var CLONING_DISTANCE = 32;
var FIT_TO_SCREEN_PADDING = 128;
var SNAP_DISTANCE = 5;
var SLOW_SPEED = 10;
var GHOSTED_OPACITY = 0.3;
var DEAD_ZONE = 3;
var PI2 = Math.PI * 2;
var EASINGS = {
  linear: (t14) => t14,
  easeInQuad: (t14) => t14 * t14,
  easeOutQuad: (t14) => t14 * (2 - t14),
  easeInOutQuad: (t14) => t14 < 0.5 ? 2 * t14 * t14 : -1 + (4 - 2 * t14) * t14,
  easeInCubic: (t14) => t14 * t14 * t14,
  easeOutCubic: (t14) => --t14 * t14 * t14 + 1,
  easeInOutCubic: (t14) => t14 < 0.5 ? 4 * t14 * t14 * t14 : (t14 - 1) * (2 * t14 - 2) * (2 * t14 - 2) + 1,
  easeInQuart: (t14) => t14 * t14 * t14 * t14,
  easeOutQuart: (t14) => 1 - --t14 * t14 * t14 * t14,
  easeInOutQuart: (t14) => t14 < 0.5 ? 8 * t14 * t14 * t14 * t14 : 1 - 8 * --t14 * t14 * t14 * t14,
  easeInQuint: (t14) => t14 * t14 * t14 * t14 * t14,
  easeOutQuint: (t14) => 1 + --t14 * t14 * t14 * t14 * t14,
  easeInOutQuint: (t14) => t14 < 0.5 ? 16 * t14 * t14 * t14 * t14 * t14 : 1 + 16 * --t14 * t14 * t14 * t14 * t14,
  easeInSine: (t14) => 1 - Math.cos(t14 * Math.PI / 2),
  easeOutSine: (t14) => Math.sin(t14 * Math.PI / 2),
  easeInOutSine: (t14) => -(Math.cos(Math.PI * t14) - 1) / 2,
  easeInExpo: (t14) => t14 <= 0 ? 0 : Math.pow(2, 10 * t14 - 10),
  easeOutExpo: (t14) => t14 >= 1 ? 1 : 1 - Math.pow(2, -10 * t14),
  easeInOutExpo: (t14) => t14 <= 0 ? 0 : t14 >= 1 ? 1 : t14 < 0.5 ? Math.pow(2, 20 * t14 - 10) / 2 : (2 - Math.pow(2, -20 * t14 + 10)) / 2
};
var USER_COLORS = [
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467",
  "#FF802B"
];
var TDShapeUtil = class extends TLShapeUtil {
  constructor() {
    super(...arguments);
    this.canBind = false;
    this.canEdit = false;
    this.canClone = false;
    this.isAspectRatioLocked = false;
    this.hideResizeHandles = false;
    this.bindingDistance = BINDING_DISTANCE;
    this.hitTestPoint = (shape, point) => {
      return Utils.pointInBounds(point, this.getRotatedBounds(shape));
    };
    this.hitTestLineSegment = (shape, A4, B3) => {
      const box3 = Utils.getBoundsFromPoints([A4, B3]);
      const bounds = this.getBounds(shape);
      return Utils.boundsContain(bounds, box3) || shape.rotation ? intersectLineSegmentPolyline(A4, B3, Utils.getRotatedCorners(this.getBounds(shape))).didIntersect : intersectLineSegmentBounds(A4, B3, this.getBounds(shape)).length > 0;
    };
    this.create = (props) => {
      this.refMap.set(props.id, (0, import_react63.createRef)());
      return this.getShape(props);
    };
    this.getCenter = (shape) => {
      return Utils.getBoundsCenter(this.getBounds(shape));
    };
    this.getExpandedBounds = (shape) => {
      return Utils.expandBounds(this.getBounds(shape), this.bindingDistance);
    };
    this.getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {
      const bounds = this.getBounds(shape);
      const expandedBounds = this.getExpandedBounds(shape);
      if (!Utils.pointInBounds(point, expandedBounds))
        return;
      const intersections = intersectRayBounds(origin, direction, expandedBounds).filter((int) => int.didIntersect).map((int) => int.points[0]);
      if (!intersections.length)
        return;
      const center = this.getCenter(shape);
      const intersection = intersections.sort((a9, b7) => Vec.dist(b7, origin) - Vec.dist(a9, origin))[0];
      const middlePoint = Vec.med(point, intersection);
      let anchor;
      let distance;
      if (bindAnywhere) {
        anchor = Vec.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;
        distance = 0;
      } else {
        if (Vec.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {
          anchor = center;
        } else {
          anchor = middlePoint;
        }
        if (Utils.pointInBounds(point, bounds)) {
          distance = this.bindingDistance;
        } else {
          distance = Math.max(this.bindingDistance, Utils.getBoundsSides(bounds).map((side) => Vec.distanceToLineSegment(side[1][0], side[1][1], point)).sort((a9, b7) => a9 - b7)[0]);
        }
      }
      const bindingPoint = Vec.divV(Vec.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [
        expandedBounds.width,
        expandedBounds.height
      ]);
      return {
        point: Vec.clampV(bindingPoint, 0, 1),
        distance
      };
    };
    this.mutate = (shape, props) => {
      return props;
    };
    this.transform = (shape, bounds, info) => {
      return __spreadProps4(__spreadValues4({}, shape), { point: [bounds.minX, bounds.minY] });
    };
    this.transformSingle = (shape, bounds, info) => {
      return this.transform(shape, bounds, info);
    };
    this.getSvgElement = (shape) => {
      var _a2;
      return (_a2 = document.getElementById(shape.id + "_svg")) == null ? void 0 : _a2.cloneNode(true);
    };
  }
};
function getBoundsRectangle(shape, boundsCache) {
  const bounds = Utils.getFromCache(boundsCache, shape, () => {
    const [width, height] = shape.size;
    return {
      minX: 0,
      maxX: width,
      minY: 0,
      maxY: height,
      width,
      height
    };
  });
  return Utils.translateBounds(bounds, shape.point);
}
function transformRectangle(shape, bounds, { initialShape, transformOrigin, scaleX, scaleY }) {
  if (shape.rotation || initialShape.isAspectRatioLocked) {
    const size = src_default.toFixed(src_default.mul(initialShape.size, Math.min(Math.abs(scaleX), Math.abs(scaleY))));
    const point = src_default.toFixed([
      bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),
      bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])
    ]);
    const rotation = scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? initialShape.rotation ? -initialShape.rotation : 0 : initialShape.rotation;
    return {
      size,
      point,
      rotation
    };
  } else {
    return {
      point: src_default.toFixed([bounds.minX, bounds.minY]),
      size: src_default.toFixed([bounds.width, bounds.height])
    };
  }
}
function transformSingleRectangle(shape, bounds) {
  return {
    size: src_default.toFixed([bounds.width, bounds.height]),
    point: src_default.toFixed([bounds.minX, bounds.minY])
  };
}
var INDENT = "  ";
var TextAreaUtils = class {
  static insertTextFirefox(field, text) {
    field.setRangeText(text, field.selectionStart || 0, field.selectionEnd || 0, "end");
    field.dispatchEvent(new InputEvent("input", {
      data: text,
      inputType: "insertText",
      isComposing: false
    }));
  }
  static insert(field, text) {
    const document2 = field.ownerDocument;
    const initialFocus = document2.activeElement;
    if (initialFocus !== field) {
      field.focus();
    }
    if (!document2.execCommand("insertText", false, text)) {
      TextAreaUtils.insertTextFirefox(field, text);
    }
    if (initialFocus === document2.body) {
      field.blur();
    } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {
      initialFocus.focus();
    }
  }
  static set(field, text) {
    field.select();
    TextAreaUtils.insert(field, text);
  }
  static getSelection(field) {
    const { selectionStart, selectionEnd } = field;
    return field.value.slice(selectionStart ? selectionStart : void 0, selectionEnd ? selectionEnd : void 0);
  }
  static wrapSelection(field, wrap, wrapEnd) {
    const { selectionStart, selectionEnd } = field;
    const selection = TextAreaUtils.getSelection(field);
    TextAreaUtils.insert(field, wrap + selection + (wrapEnd != null ? wrapEnd : wrap));
    field.selectionStart = (selectionStart || 0) + wrap.length;
    field.selectionEnd = (selectionEnd || 0) + wrap.length;
  }
  static replace(field, searchValue, replacer) {
    let drift = 0;
    field.value.replace(searchValue, (...args) => {
      const matchStart = drift + args[args.length - 2];
      const matchLength = args[0].length;
      field.selectionStart = matchStart;
      field.selectionEnd = matchStart + matchLength;
      const replacement = typeof replacer === "string" ? replacer : replacer(...args);
      TextAreaUtils.insert(field, replacement);
      field.selectionStart = matchStart;
      drift += replacement.length - matchLength;
      return replacement;
    });
  }
  static findLineEnd(value, currentEnd) {
    const lastLineStart = value.lastIndexOf("\n", currentEnd - 1) + 1;
    if (value.charAt(lastLineStart) !== "	") {
      return currentEnd;
    }
    return lastLineStart + 1;
  }
  static indent(element) {
    var _a2;
    const { selectionStart, selectionEnd, value } = element;
    const selectedContrast = value.slice(selectionStart, selectionEnd);
    const lineBreakCount = (_a2 = /\n/g.exec(selectedContrast)) == null ? void 0 : _a2.length;
    if (lineBreakCount && lineBreakCount > 0) {
      const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
      const newSelection = element.value.slice(firstLineStart, selectionEnd - 1);
      const indentedText = newSelection.replace(/^|\n/g, `$&${INDENT}`);
      const replacementsCount = indentedText.length - newSelection.length;
      element.setSelectionRange(firstLineStart, selectionEnd - 1);
      TextAreaUtils.insert(element, indentedText);
      element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount);
    } else {
      TextAreaUtils.insert(element, INDENT);
    }
  }
  static unindent(element) {
    const { selectionStart, selectionEnd, value } = element;
    const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
    const minimumSelectionEnd = TextAreaUtils.findLineEnd(value, selectionEnd);
    const newSelection = element.value.slice(firstLineStart, minimumSelectionEnd);
    const indentedText = newSelection.replace(/(^|\n)(\t| {1,2})/g, "$1");
    const replacementsCount = newSelection.length - indentedText.length;
    element.setSelectionRange(firstLineStart, minimumSelectionEnd);
    TextAreaUtils.insert(element, indentedText);
    const firstLineIndentation = /\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));
    const difference = firstLineIndentation ? firstLineIndentation[0].length : 0;
    const newSelectionStart = selectionStart - difference;
    element.setSelectionRange(selectionStart - difference, Math.max(newSelectionStart, selectionEnd - replacementsCount));
  }
};
var canvasLight = "#fafafa";
var canvasDark = "#343d45";
var colors = {
  [ColorStyle.White]: "#f0f1f3",
  [ColorStyle.LightGray]: "#c6cbd1",
  [ColorStyle.Gray]: "#788492",
  [ColorStyle.Black]: "#1d1d1d",
  [ColorStyle.Green]: "#36b24d",
  [ColorStyle.Cyan]: "#0e98ad",
  [ColorStyle.Blue]: "#1c7ed6",
  [ColorStyle.Indigo]: "#4263eb",
  [ColorStyle.Violet]: "#7746f1",
  [ColorStyle.Red]: "#ff2133",
  [ColorStyle.Orange]: "#ff9433",
  [ColorStyle.Yellow]: "#ffc936"
};
var stickyFills = {
  light: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k3, v6]) => [k3, Utils.lerpColor(v6, canvasLight, 0.45)]))), {
    [ColorStyle.White]: "#ffffff",
    [ColorStyle.Black]: "#3d3d3d"
  }),
  dark: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k3, v6]) => [
    k3,
    Utils.lerpColor(Utils.lerpColor(v6, "#999999", 0.3), canvasDark, 0.4)
  ]))), {
    [ColorStyle.White]: "#1d1d1d",
    [ColorStyle.Black]: "#bbbbbb"
  })
};
var strokes = {
  light: __spreadProps4(__spreadValues4({}, colors), {
    [ColorStyle.White]: "#1d1d1d"
  }),
  dark: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k3, v6]) => [k3, Utils.lerpColor(v6, canvasDark, 0.1)]))), {
    [ColorStyle.White]: "#cecece",
    [ColorStyle.Black]: "#cecece"
  })
};
var fills = {
  light: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k3, v6]) => [k3, Utils.lerpColor(v6, canvasLight, 0.82)]))), {
    [ColorStyle.White]: "#fefefe",
    [ColorStyle.Black]: "#4d4d4d"
  }),
  dark: __spreadProps4(__spreadValues4({}, Object.fromEntries(Object.entries(colors).map(([k3, v6]) => [k3, Utils.lerpColor(v6, canvasDark, 0.618)]))), {
    [ColorStyle.White]: "rgb(30,33,37)",
    [ColorStyle.Black]: "#1e1e1f"
  })
};
var strokeWidths = {
  [SizeStyle.Small]: 2,
  [SizeStyle.Medium]: 3.5,
  [SizeStyle.Large]: 5
};
var fontSizes = {
  [SizeStyle.Small]: 28,
  [SizeStyle.Medium]: 48,
  [SizeStyle.Large]: 96,
  auto: "auto"
};
var fontFaces = {
  [FontStyle.Script]: '"Caveat Brush"',
  [FontStyle.Sans]: '"Source Sans Pro", sans-serif',
  [FontStyle.Serif]: '"Source Serif Pro", serif',
  [FontStyle.Mono]: '"Source Code Pro", monospace'
};
var fontSizeModifiers = {
  [FontStyle.Script]: 1,
  [FontStyle.Sans]: 1,
  [FontStyle.Serif]: 1,
  [FontStyle.Mono]: 1
};
var stickyFontSizes = {
  [SizeStyle.Small]: 24,
  [SizeStyle.Medium]: 36,
  [SizeStyle.Large]: 48,
  auto: "auto"
};
function getStrokeWidth(size) {
  return strokeWidths[size];
}
function getFontSize(size, fontStyle = FontStyle.Script) {
  return fontSizes[size] * fontSizeModifiers[fontStyle];
}
function getFontFace(font = FontStyle.Script) {
  return fontFaces[font];
}
function getStickyFontSize(size) {
  return stickyFontSizes[size];
}
function getFontStyle(style) {
  const fontSize = getFontSize(style.size, style.font);
  const fontFace = getFontFace(style.font);
  const { scale = 1 } = style;
  return `${fontSize * scale}px/1 ${fontFace}`;
}
function getStickyFontStyle(style) {
  const fontSize = getStickyFontSize(style.size);
  const fontFace = getFontFace(style.font);
  const { scale = 1 } = style;
  return `${fontSize * scale}px/1 ${fontFace}`;
}
function getStickyShapeStyle(style, isDarkMode = false) {
  const { color } = style;
  const theme = isDarkMode ? "dark" : "light";
  const adjustedColor = color === ColorStyle.White || color === ColorStyle.Black ? ColorStyle.Yellow : color;
  return {
    fill: stickyFills[theme][adjustedColor],
    stroke: strokes[theme][adjustedColor],
    color: isDarkMode ? "#1d1d1d" : "#0d0d0d"
  };
}
function getShapeStyle(style, isDarkMode) {
  const { color, size, isFilled } = style;
  const strokeWidth = getStrokeWidth(size);
  const theme = isDarkMode ? "dark" : "light";
  return {
    stroke: strokes[theme][color],
    fill: isFilled ? fills[theme][color] : "none",
    strokeWidth
  };
}
var defaultStyle = {
  color: ColorStyle.Black,
  size: SizeStyle.Small,
  isFilled: false,
  dash: DashStyle.Draw,
  scale: 1
};
var defaultTextStyle = __spreadProps4(__spreadValues4({}, defaultStyle), {
  font: FontStyle.Script,
  textAlign: AlignStyle.Middle
});
var RectangleUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Rectangle;
    this.canBind = true;
    this.canClone = true;
    this.getShape = (props) => {
      return Utils.deepMerge({
        id: "id",
        type: TDShapeType.Rectangle,
        name: "Rectangle",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: defaultStyle
      }, props);
    };
    this.Component = TDShapeUtil.Component(({ shape, isBinding, isSelected, isGhost, meta, events }, ref) => {
      const { id, size, style } = shape;
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const { strokeWidth } = styles22;
      if (style.dash === DashStyle.Draw) {
        const pathTDSnapshot = getRectanglePath(shape);
        const indicatorPath = getRectangleIndicatorPathTDSnapshot(shape);
        return /* @__PURE__ */ (0, import_react62.createElement)(SVGContainer, __spreadValues4({
          ref,
          id: shape.id + "_svg"
        }, events), isBinding && /* @__PURE__ */ (0, import_react62.createElement)("rect", {
          className: "tl-binding-indicator",
          x: strokeWidth,
          y: strokeWidth,
          width: Math.max(0, size[0] - strokeWidth / 2),
          height: Math.max(0, size[1] - strokeWidth / 2),
          strokeWidth: this.bindingDistance * 2
        }), /* @__PURE__ */ (0, import_react62.createElement)("path", {
          className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
          d: indicatorPath
        }), /* @__PURE__ */ (0, import_react62.createElement)("path", {
          d: indicatorPath,
          fill: style.isFilled ? styles22.fill : "none",
          pointerEvents: "none"
        }), /* @__PURE__ */ (0, import_react62.createElement)("path", {
          d: pathTDSnapshot,
          fill: styles22.stroke,
          stroke: styles22.stroke,
          strokeWidth: styles22.strokeWidth,
          pointerEvents: "none",
          opacity: isGhost ? GHOSTED_OPACITY : 1
        }));
      }
      const sw = 1 + strokeWidth * 1.618;
      const w6 = Math.max(0, size[0] - sw / 2);
      const h3 = Math.max(0, size[1] - sw / 2);
      const strokes2 = [
        [[sw / 2, sw / 2], [w6, sw / 2], w6 - sw / 2],
        [[w6, sw / 2], [w6, h3], h3 - sw / 2],
        [[w6, h3], [sw / 2, h3], w6 - sw / 2],
        [[sw / 2, h3], [sw / 2, sw / 2], h3 - sw / 2]
      ];
      const paths = strokes2.map(([start, end, length], i8) => {
        const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(length, strokeWidth * 1.618, shape.style.dash);
        return /* @__PURE__ */ (0, import_react62.createElement)("line", {
          key: id + "_" + i8,
          x1: start[0],
          y1: start[1],
          x2: end[0],
          y2: end[1],
          strokeDasharray,
          strokeDashoffset
        });
      });
      return /* @__PURE__ */ (0, import_react62.createElement)(SVGContainer, __spreadValues4({
        ref,
        id: shape.id + "_svg"
      }, events), /* @__PURE__ */ (0, import_react62.createElement)("g", {
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, isBinding && /* @__PURE__ */ (0, import_react62.createElement)("rect", {
        className: "tl-binding-indicator",
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        strokeWidth: this.bindingDistance
      }), /* @__PURE__ */ (0, import_react62.createElement)("rect", {
        className: isSelected || style.isFilled ? "tl-fill-hitarea" : "tl-stroke-hitarea",
        x: sw / 2,
        y: sw / 2,
        width: w6,
        height: h3,
        strokeWidth: this.bindingDistance
      }), style.isFilled && /* @__PURE__ */ (0, import_react62.createElement)("rect", {
        x: sw / 2,
        y: sw / 2,
        width: w6,
        height: h3,
        fill: styles22.fill,
        pointerEvents: "none"
      }), /* @__PURE__ */ (0, import_react62.createElement)("g", {
        pointerEvents: "none",
        stroke: styles22.stroke,
        strokeWidth: sw,
        strokeLinecap: "round"
      }, paths)));
    });
    this.Indicator = TDShapeUtil.Indicator(({ shape }) => {
      const {
        style,
        size: [width, height]
      } = shape;
      const styles22 = getShapeStyle(style, false);
      const sw = styles22.strokeWidth;
      if (style.dash === DashStyle.Draw) {
        return /* @__PURE__ */ (0, import_react62.createElement)("path", {
          d: getRectangleIndicatorPathTDSnapshot(shape)
        });
      }
      return /* @__PURE__ */ (0, import_react62.createElement)("rect", {
        x: sw,
        y: sw,
        rx: 1,
        ry: 1,
        width: Math.max(1, width - sw * 2),
        height: Math.max(1, height - sw * 2)
      });
    });
    this.getBounds = (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    };
    this.shouldRender = (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style;
    };
    this.transform = transformRectangle;
    this.transformSingle = transformSingleRectangle;
  }
};
function getRectangleDrawPoints(shape) {
  const styles22 = getShapeStyle(shape.style);
  const getRandom = Utils.rng(shape.id);
  const sw = styles22.strokeWidth;
  const w6 = Math.max(0, shape.size[0]);
  const h3 = Math.max(0, shape.size[1]);
  const offsets = Array.from(Array(4)).map(() => {
    return [getRandom() * sw * 0.75, getRandom() * sw * 0.75];
  });
  const tl = Vec.add([sw / 2, sw / 2], offsets[0]);
  const tr = Vec.add([w6 - sw / 2, sw / 2], offsets[1]);
  const br = Vec.add([w6 - sw / 2, h3 - sw / 2], offsets[2]);
  const bl = Vec.add([sw / 2, h3 - sw / 2], offsets[3]);
  const rm = Math.round(Math.abs(getRandom() * 2 * 4));
  const rx = Math.min(w6 / 2, sw * 2);
  const ry = Math.min(h3 / 2, sw * 2);
  const px = Math.max(8, Math.floor(w6 / 16));
  const py = Math.max(8, Math.floor(h3 / 16));
  const lines = Utils.rotateArray([
    Vec.pointsBetween(Vec.add(tl, [rx, 0]), Vec.sub(tr, [rx, 0]), px),
    Vec.pointsBetween(Vec.add(tr, [0, ry]), Vec.sub(br, [0, ry]), py),
    Vec.pointsBetween(Vec.sub(br, [rx, 0]), Vec.add(bl, [rx, 0]), px),
    Vec.pointsBetween(Vec.sub(bl, [0, ry]), Vec.add(tl, [0, ry]), py)
  ], rm);
  const points = [...lines.flat(), ...lines[0]].slice(5, Math.floor((rm % 2 === 0 ? px : py) / -2) + 3);
  return {
    points
  };
}
function getDrawStrokeInfo(shape) {
  const { points } = getRectangleDrawPoints(shape);
  const { strokeWidth } = getShapeStyle(shape.style);
  const options2 = {
    size: strokeWidth,
    thinning: 0.65,
    streamline: 0.3,
    smoothing: 1,
    simulatePressure: false,
    last: true
  };
  return { points, options: options2 };
}
function getRectanglePath(shape) {
  const { points, options: options2 } = getDrawStrokeInfo(shape);
  const stroke = me(points, options2);
  return Utils.getSvgPathFromStroke(stroke);
}
function getRectangleIndicatorPathTDSnapshot(shape) {
  const { points, options: options2 } = getDrawStrokeInfo(shape);
  const strokePoints = ce(points, options2);
  return Utils.getSvgPathFromStroke(strokePoints.map((pt) => pt.point.slice(0, 2)), false);
}
var PI22 = Math.PI * 2;
var _PolygonUtils = class {
  static inwardEdgeNormal(edge) {
    const delta = src_default.sub(edge[1], edge[0]);
    const len = src_default.len2(delta);
    return [-delta[0] / len, delta[1] / len];
  }
  static outwardEdgeNormal(edge) {
    return src_default.neg(_PolygonUtils.inwardEdgeNormal(edge));
  }
  static isReflexVertex(polygon, index2) {
    const len = polygon.length;
    const v0 = polygon[(index2 + len - 1) % len];
    const v1 = polygon[index2];
    const v22 = polygon[(index2 + 1) % len];
    if (_PolygonUtils.leftSide(v0, v22, v1) < 0)
      return true;
    return false;
  }
  static getEdges(vertices) {
    return vertices.map((vert, i8) => [vert, vertices[(i8 + 1) % vertices.length]]);
  }
  static edgesIntersection([A1, A22], [B1, B22]) {
    const den = (B22[1] - B1[1]) * (A22[0] - A1[0]) - (B22[0] - B1[0]) * (A22[1] - A1[1]);
    if (den == 0)
      return null;
    const ua = ((B22[0] - B1[0]) * (A1[1] - B1[1]) - (B22[1] - B1[1]) * (A1[0] - B1[0])) / den;
    const ub = ((A22[0] - A1[0]) * (A1[1] - B1[1]) - (A22[1] - A1[1]) * (A1[0] - B1[0])) / den;
    if (ua < 0 || ub < 0 || ua > 1 || ub > 1)
      return null;
    return [A1[0] + ua * (A22[0] - A1[0]), A1[1] + ua * (A22[1] - A1[1])];
  }
  static appendArc(polygon, center, radius, startVertex, endVertex, isPaddingBoundary = false) {
    const vertices = [...polygon];
    let startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]);
    let endAngle = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);
    if (startAngle < 0)
      startAngle += PI22;
    if (endAngle < 0)
      endAngle += PI22;
    const arcSegmentCount = 5;
    const angle = startAngle > endAngle ? startAngle - endAngle : startAngle + PI22 - endAngle;
    const angle5 = (isPaddingBoundary ? -angle : PI22 - angle) / arcSegmentCount;
    vertices.push(startVertex);
    for (let i8 = 1; i8 < arcSegmentCount; ++i8) {
      const angle2 = startAngle + angle5 * i8;
      vertices.push([center[0] + Math.cos(angle2) * radius, center[1] + Math.sin(angle2) * radius]);
    }
    vertices.push(endVertex);
    return vertices;
  }
  static createOffsetEdge(edge, offset) {
    return edge.map((vert) => src_default.add(vert, offset));
  }
  static getOffsetPolygon(polygon, offset = 0) {
    const edges = _PolygonUtils.getEdges(polygon);
    const offsetEdges = edges.map((edge) => _PolygonUtils.createOffsetEdge(edge, src_default.mul(_PolygonUtils.outwardEdgeNormal(edge), offset)));
    const vertices = [];
    for (let i8 = 0; i8 < offsetEdges.length; i8++) {
      const thisEdge = offsetEdges[i8];
      const prevEdge = offsetEdges[(i8 + offsetEdges.length - 1) % offsetEdges.length];
      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);
      if (vertex)
        vertices.push(vertex);
      else {
        _PolygonUtils.appendArc(vertices, edges[i8][0], offset, prevEdge[1], thisEdge[0], false);
      }
    }
    return vertices;
  }
  static createPaddingPolygon(polygon, shapePadding = 0) {
    const offsetEdges = polygon.map((edge) => _PolygonUtils.createOffsetEdge(edge, _PolygonUtils.inwardEdgeNormal(edge)));
    const vertices = [];
    for (let i8 = 0; i8 < offsetEdges.length; i8++) {
      const thisEdge = offsetEdges[i8];
      const prevEdge = offsetEdges[(i8 + offsetEdges.length - 1) % offsetEdges.length];
      const vertex = _PolygonUtils.edgesIntersection(prevEdge, thisEdge);
      if (vertex)
        vertices.push(vertex);
      else {
        _PolygonUtils.appendArc(vertices, polygon[i8][0], shapePadding, prevEdge[1], thisEdge[0], true);
      }
    }
    return vertices;
  }
};
var PolygonUtils = _PolygonUtils;
PolygonUtils.leftSide = src_default.isLeft;
function getOffsetPolygon(points, offset) {
  if (points.length < 3)
    throw Error("Polygon must have at least 3 points");
  const len = points.length;
  return points.map((point, i8) => [point, points[(i8 + 1) % len]]).map(([A4, B3]) => {
    const offsetVector = src_default.mul(src_default.per(src_default.uni(src_default.sub(B3, A4))), offset);
    return [src_default.add(A4, offsetVector), src_default.add(B3, offsetVector)];
  }).map((edge, i8, edges) => {
    const intersection = intersectLineLine(edge, edges[(i8 + 1) % edges.length]);
    if (intersection === void 0)
      throw Error("Expected an intersection");
    return intersection;
  });
}
var TriangleUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Triangle;
    this.canBind = true;
    this.canClone = true;
    this.getShape = (props) => {
      return Utils.deepMerge({
        id: "id",
        type: TDShapeType.Triangle,
        name: "Triangle",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [1, 1],
        rotation: 0,
        style: defaultStyle
      }, props);
    };
    this.Component = TDShapeUtil.Component(({ shape, isBinding, isSelected, isGhost, meta, events }, ref) => {
      const { id, style } = shape;
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const { strokeWidth } = styles22;
      const sw = 1 + strokeWidth * 1.618;
      if (style.dash === DashStyle.Draw) {
        const pathTDSnapshot = getTrianglePath(shape);
        const indicatorPath = getTriangleIndicatorPathTDSnapshot(shape);
        const trianglePoints = getTrianglePoints(shape).join();
        return /* @__PURE__ */ (0, import_react64.createElement)(SVGContainer, __spreadValues4({
          ref,
          id: shape.id + "_svg"
        }, events), isBinding && /* @__PURE__ */ (0, import_react64.createElement)("polygon", {
          className: "tl-binding-indicator",
          points: trianglePoints,
          strokeWidth: this.bindingDistance * 2
        }), /* @__PURE__ */ (0, import_react64.createElement)("path", {
          className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
          d: indicatorPath
        }), /* @__PURE__ */ (0, import_react64.createElement)("path", {
          d: indicatorPath,
          fill: style.isFilled ? styles22.fill : "none",
          pointerEvents: "none"
        }), /* @__PURE__ */ (0, import_react64.createElement)("path", {
          d: pathTDSnapshot,
          fill: styles22.stroke,
          stroke: styles22.stroke,
          strokeWidth: styles22.strokeWidth,
          pointerEvents: "none",
          opacity: isGhost ? GHOSTED_OPACITY : 1
        }));
      }
      const points = getTrianglePoints(shape);
      const sides = Utils.pointsToLineSegments(points, true);
      const paths = sides.map(([start, end], i8) => {
        const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(src_default.dist(start, end), strokeWidth * 1.618, shape.style.dash);
        return /* @__PURE__ */ (0, import_react64.createElement)("line", {
          key: id + "_" + i8,
          x1: start[0],
          y1: start[1],
          x2: end[0],
          y2: end[1],
          stroke: styles22.stroke,
          strokeWidth: sw,
          strokeLinecap: "round",
          strokeDasharray,
          strokeDashoffset
        });
      });
      return /* @__PURE__ */ (0, import_react64.createElement)(SVGContainer, __spreadValues4({
        ref,
        id: shape.id + "_svg"
      }, events), isBinding && /* @__PURE__ */ (0, import_react64.createElement)("polygon", {
        className: "tl-binding-indicator",
        points: points.join(),
        strokeWidth: this.bindingDistance * 2
      }), /* @__PURE__ */ (0, import_react64.createElement)("polygon", {
        className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
        points: points.join()
      }), /* @__PURE__ */ (0, import_react64.createElement)("g", {
        pointerEvents: "stroke"
      }, paths));
    });
    this.Indicator = TDShapeUtil.Indicator(({ shape }) => {
      const { style } = shape;
      const styles22 = getShapeStyle(style, false);
      const sw = styles22.strokeWidth;
      return /* @__PURE__ */ (0, import_react64.createElement)("polygon", {
        points: getTrianglePoints(shape).join()
      });
    });
    this.shouldRender = (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style;
    };
    this.getBounds = (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    };
    this.getExpandedBounds = (shape) => {
      return Utils.getBoundsFromPoints(getTrianglePoints(shape, this.bindingDistance).map((pt) => src_default.add(pt, shape.point)));
    };
    this.hitTestLineSegment = (shape, A4, B3) => {
      return intersectLineSegmentPolyline(A4, B3, this.getPoints(shape)).didIntersect;
    };
    this.hitTestBounds = (shape, bounds) => {
      return Utils.boundsContained(this.getBounds(shape), bounds) || intersectBoundsPolygon(bounds, this.getPoints(shape)).length > 0;
    };
    this.getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {
      const expandedBounds = this.getExpandedBounds(shape);
      if (!Utils.pointInBounds(point, expandedBounds))
        return;
      const points = getTrianglePoints(shape).map((pt) => src_default.add(pt, shape.point));
      const expandedPoints = getTrianglePoints(shape, this.bindingDistance).map((pt) => src_default.add(pt, shape.point));
      const closestDistanceToEdge = Utils.pointsToLineSegments(points, true).map(([a9, b7]) => src_default.distanceToLineSegment(a9, b7, point)).sort((a9, b7) => a9 - b7)[0];
      if (!(Utils.pointInPolygon(point, expandedPoints) || closestDistanceToEdge < this.bindingDistance))
        return;
      const intersections = Utils.pointsToLineSegments(expandedPoints.concat([expandedPoints[0]])).map((segment) => intersectRayLineSegment(origin, direction, segment[0], segment[1])).filter((intersection2) => intersection2.didIntersect).flatMap((intersection2) => intersection2.points);
      if (!intersections.length)
        return;
      const center = src_default.add(getTriangleCentroid(shape), shape.point);
      const intersection = intersections.sort((a9, b7) => src_default.dist(b7, origin) - src_default.dist(a9, origin))[0];
      const middlePoint = src_default.med(point, intersection);
      let anchor;
      let distance;
      if (bindAnywhere) {
        anchor = src_default.dist(point, center) < BINDING_DISTANCE / 2 ? center : point;
        distance = 0;
      } else {
        if (src_default.distanceToLineSegment(point, middlePoint, center) < BINDING_DISTANCE / 2) {
          anchor = center;
        } else {
          anchor = middlePoint;
        }
        if (Utils.pointInPolygon(point, points)) {
          distance = this.bindingDistance;
        } else {
          distance = Math.max(this.bindingDistance, closestDistanceToEdge);
        }
      }
      const bindingPoint = src_default.divV(src_default.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [
        expandedBounds.width,
        expandedBounds.height
      ]);
      return {
        point: src_default.clampV(bindingPoint, 0, 1),
        distance
      };
    };
    this.transform = transformRectangle;
    this.transformSingle = transformSingleRectangle;
  }
  getPoints(shape) {
    const {
      rotation = 0,
      point: [x5, y4],
      size: [w6, h3]
    } = shape;
    return [
      [x5 + w6 / 2, y4],
      [x5, y4 + h3],
      [x5 + w6, y4 + h3]
    ].map((pt) => src_default.rotWith(pt, this.getCenter(shape), rotation));
  }
};
function getTrianglePoints(shape, offset = 0, rotation = 0) {
  const {
    size: [w6, h3]
  } = shape;
  let points = [
    [w6 / 2, 0],
    [w6, h3],
    [0, h3]
  ];
  if (offset)
    points = getOffsetPolygon(points, offset);
  if (rotation)
    points = points.map((pt) => src_default.rotWith(pt, [w6 / 2, h3 / 2], rotation));
  return points;
}
function getTriangleCentroid(shape) {
  const {
    size: [w6, h3]
  } = shape;
  const points = [
    [w6 / 2, 0],
    [w6, h3],
    [0, h3]
  ];
  return [
    (points[0][0] + points[1][0] + points[2][0]) / 3,
    (points[0][1] + points[1][1] + points[2][1]) / 3
  ];
}
function getTriangleDrawPoints(shape) {
  const styles22 = getShapeStyle(shape.style);
  const {
    size: [w6, h3]
  } = shape;
  const getRandom = Utils.rng(shape.id);
  const sw = styles22.strokeWidth;
  const offsets = Array.from(Array(3)).map(() => {
    return [getRandom() * sw * 0.75, getRandom() * sw * 0.75];
  });
  const corners = [
    src_default.add([w6 / 2, 0], offsets[0]),
    src_default.add([w6, h3], offsets[1]),
    src_default.add([0, h3], offsets[2])
  ];
  const rm = Math.round(Math.abs(getRandom() * 2 * 3));
  const lines = Utils.rotateArray([
    src_default.pointsBetween(corners[0], corners[1], 32),
    src_default.pointsBetween(corners[1], corners[2], 32),
    src_default.pointsBetween(corners[2], corners[0], 32)
  ], rm);
  const points = [...lines.flat(), ...lines[0]];
  return {
    points
  };
}
function getDrawStrokeInfo2(shape) {
  const { points } = getTriangleDrawPoints(shape);
  const { strokeWidth } = getShapeStyle(shape.style);
  const options2 = {
    size: strokeWidth,
    thinning: 0.65,
    streamline: 0.3,
    smoothing: 1,
    simulatePressure: false,
    last: true
  };
  return { points, options: options2 };
}
function getTrianglePath(shape) {
  const { points, options: options2 } = getDrawStrokeInfo2(shape);
  const stroke = Te(points, options2);
  return Utils.getSvgPathFromStroke(stroke);
}
function getTriangleIndicatorPathTDSnapshot(shape) {
  const { points, options: options2 } = getDrawStrokeInfo2(shape);
  const strokePoints = ce(points, options2);
  return Utils.getSvgPathFromStroke(strokePoints.map((pt) => pt.point.slice(0, 2)), false);
}
function getEllipseStrokePoints(shape, boundsCenter) {
  const {
    id,
    radius: [radiusX, radiusY],
    point,
    style
  } = shape;
  const { strokeWidth } = getShapeStyle(style);
  const getRandom = Utils.rng(id);
  const center = src_default.sub(boundsCenter, point);
  const rx = radiusX + getRandom() * strokeWidth * 2;
  const ry = radiusY + getRandom() * strokeWidth * 2;
  const perimeter = Utils.perimeterOfEllipse(rx, ry);
  const points = [];
  const start = Math.PI + Math.PI * getRandom();
  const extra = Math.abs(getRandom());
  const count = Math.max(16, perimeter / 10);
  for (let i8 = 0; i8 < count; i8++) {
    const t14 = EASINGS.easeInOutSine(i8 / (count + 1));
    const rads = start * 2 + Math.PI * (2 + extra) * t14;
    const c7 = Math.cos(rads);
    const s8 = Math.sin(rads);
    points.push([rx * c7 + center[0], ry * s8 + center[1], t14 + 0.5 + getRandom() / 2]);
  }
  return ce(points, {
    size: 1 + strokeWidth * 2,
    thinning: 0.618,
    end: { taper: perimeter / 8 },
    start: { taper: perimeter / 12 },
    streamline: 0,
    simulatePressure: true
  });
}
function getEllipsePath(shape, boundsCenter) {
  const {
    id,
    radius: [radiusX, radiusY],
    style
  } = shape;
  const { strokeWidth } = getShapeStyle(style);
  const getRandom = Utils.rng(id);
  const rx = radiusX + getRandom() * strokeWidth * 2;
  const ry = radiusY + getRandom() * strokeWidth * 2;
  const perimeter = Utils.perimeterOfEllipse(rx, ry);
  return Utils.getSvgPathFromStroke(ie(getEllipseStrokePoints(shape, boundsCenter), {
    size: 2 + strokeWidth * 2,
    thinning: 0.618,
    end: { taper: perimeter / 8 },
    start: { taper: perimeter / 12 },
    streamline: 0,
    simulatePressure: true
  }));
}
function getEllipseIndicatorPathTDSnapshot(shape, boundsCenter) {
  return Utils.getSvgPathFromStroke(getEllipseStrokePoints(shape, boundsCenter).map((pt) => pt.point.slice(0, 2)), false);
}
var EllipseUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Ellipse;
    this.canBind = true;
    this.getShape = (props) => {
      return Utils.deepMerge({
        id: "id",
        type: TDShapeType.Ellipse,
        name: "Ellipse",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        radius: [1, 1],
        rotation: 0,
        style: defaultStyle
      }, props);
    };
    this.Component = TDShapeUtil.Component(({ shape, isGhost, isSelected, isBinding, meta, events }, ref) => {
      const {
        radius: [radiusX, radiusY],
        style
      } = shape;
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const strokeWidth = styles22.strokeWidth;
      const sw = 1 + strokeWidth * 1.618;
      const rx = Math.max(0, radiusX - sw / 2);
      const ry = Math.max(0, radiusY - sw / 2);
      if (style.dash === DashStyle.Draw) {
        const path = getEllipsePath(shape, this.getCenter(shape));
        return /* @__PURE__ */ (0, import_react65.createElement)(SVGContainer, __spreadValues4({
          ref,
          id: shape.id + "_svg"
        }, events), isBinding && /* @__PURE__ */ (0, import_react65.createElement)("ellipse", {
          className: "tl-binding-indicator",
          cx: radiusX,
          cy: radiusY,
          rx,
          ry,
          strokeWidth: this.bindingDistance
        }), /* @__PURE__ */ (0, import_react65.createElement)("ellipse", {
          className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
          cx: radiusX,
          cy: radiusY,
          rx: radiusX,
          ry: radiusY
        }), /* @__PURE__ */ (0, import_react65.createElement)("path", {
          d: getEllipseIndicatorPathTDSnapshot(shape, this.getCenter(shape)),
          stroke: "none",
          fill: style.isFilled ? styles22.fill : "none",
          pointerEvents: "none"
        }), /* @__PURE__ */ (0, import_react65.createElement)("path", {
          d: path,
          fill: styles22.stroke,
          stroke: styles22.stroke,
          strokeWidth: styles22.strokeWidth,
          pointerEvents: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          opacity: isGhost ? GHOSTED_OPACITY : 1
        }));
      }
      const perimeter = Utils.perimeterOfEllipse(rx, ry);
      const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(perimeter < 64 ? perimeter * 2 : perimeter, strokeWidth * 1.618, shape.style.dash, 4);
      return /* @__PURE__ */ (0, import_react65.createElement)(SVGContainer, __spreadValues4({
        ref,
        id: shape.id + "_svg"
      }, events), isBinding && /* @__PURE__ */ (0, import_react65.createElement)("ellipse", {
        className: "tl-binding-indicator",
        cx: radiusX,
        cy: radiusY,
        rx: radiusX,
        ry: radiusY,
        strokeWidth: this.bindingDistance
      }), /* @__PURE__ */ (0, import_react65.createElement)("ellipse", {
        className: style.isFilled || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
        cx: radiusX,
        cy: radiusY,
        rx: radiusX,
        ry: radiusY
      }), /* @__PURE__ */ (0, import_react65.createElement)("ellipse", {
        cx: radiusX,
        cy: radiusY,
        rx,
        ry,
        fill: styles22.fill,
        stroke: styles22.stroke,
        strokeWidth: sw,
        strokeDasharray,
        strokeDashoffset,
        pointerEvents: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }));
    });
    this.Indicator = TDShapeUtil.Indicator(({ shape }) => {
      const {
        radius: [radiusX, radiusY],
        style
      } = shape;
      const styles22 = getShapeStyle(style);
      const strokeWidth = styles22.strokeWidth;
      const sw = 1 + strokeWidth * 1.618;
      const rx = Math.max(0, radiusX - sw / 2);
      const ry = Math.max(0, radiusY - sw / 2);
      return style.dash === DashStyle.Draw ? /* @__PURE__ */ (0, import_react65.createElement)("path", {
        d: getEllipseIndicatorPathTDSnapshot(shape, this.getCenter(shape))
      }) : /* @__PURE__ */ (0, import_react65.createElement)("ellipse", {
        cx: radiusX,
        cy: radiusY,
        rx,
        ry
      });
    });
    this.hitTestPoint = (shape, point) => {
      return Utils.pointInBounds(point, this.getRotatedBounds(shape)) && Utils.pointInEllipse(point, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0);
    };
    this.hitTestLineSegment = (shape, A4, B3) => {
      return intersectLineSegmentEllipse(A4, B3, this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0).didIntersect;
    };
    this.getBounds = (shape) => {
      return Utils.getFromCache(this.boundsCache, shape, () => {
        return Utils.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], 0);
      });
    };
    this.getRotatedBounds = (shape) => {
      return Utils.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], shape.rotation);
    };
    this.hitTestBounds = (shape, bounds) => {
      const shapeBounds = this.getBounds(shape);
      return Utils.boundsContained(shapeBounds, bounds) || intersectEllipseBounds(this.getCenter(shape), shape.radius[0], shape.radius[1], shape.rotation || 0, bounds).length > 0;
    };
    this.shouldRender = (prev, next) => {
      return next.radius !== prev.radius || next.style !== prev.style;
    };
    this.getCenter = (shape) => {
      return Vec.add(shape.point, shape.radius);
    };
    this.getBindingPoint = (shape, fromShape, point, origin, direction, bindAnywhere) => {
      {
        const expandedBounds = this.getExpandedBounds(shape);
        const center = this.getCenter(shape);
        let bindingPoint;
        let distance;
        if (!Utils.pointInEllipse(point, center, shape.radius[0] + this.bindingDistance, shape.radius[1] + this.bindingDistance))
          return;
        if (bindAnywhere) {
          if (Vec.dist(point, this.getCenter(shape)) < 12) {
            bindingPoint = [0.5, 0.5];
          } else {
            bindingPoint = Vec.divV(Vec.sub(point, [expandedBounds.minX, expandedBounds.minY]), [
              expandedBounds.width,
              expandedBounds.height
            ]);
          }
          distance = 0;
        } else {
          let intersection = intersectRayEllipse(origin, direction, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort((a9, b7) => Vec.dist(a9, origin) - Vec.dist(b7, origin))[0];
          if (!intersection) {
            intersection = intersectLineSegmentEllipse(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points.sort((a9, b7) => Vec.dist(a9, point) - Vec.dist(b7, point))[0];
          }
          if (!intersection) {
            return void 0;
          }
          const anchor = Vec.med(point, intersection);
          if (Vec.distanceToLineSegment(point, anchor, this.getCenter(shape)) < 12) {
            bindingPoint = [0.5, 0.5];
          } else {
            bindingPoint = Vec.divV(Vec.sub(anchor, [expandedBounds.minX, expandedBounds.minY]), [
              expandedBounds.width,
              expandedBounds.height
            ]);
          }
          if (Utils.pointInEllipse(point, center, shape.radius[0], shape.radius[1], shape.rotation || 0)) {
            distance = this.bindingDistance / 2;
          } else {
            const innerIntersection = intersectLineSegmentEllipse(point, center, center, shape.radius[0], shape.radius[1], shape.rotation || 0).points[0];
            if (!innerIntersection) {
              return void 0;
            }
            distance = Math.max(this.bindingDistance / 2, Vec.dist(point, innerIntersection));
          }
        }
        return {
          point: bindingPoint,
          distance
        };
      }
    };
    this.transform = (shape, bounds, { scaleX, scaleY, initialShape }) => {
      const { rotation = 0 } = initialShape;
      return {
        point: [bounds.minX, bounds.minY],
        radius: [bounds.width / 2, bounds.height / 2],
        rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation || 0
      };
    };
    this.transformSingle = (shape, bounds) => {
      return {
        point: Vec.toFixed([bounds.minX, bounds.minY]),
        radius: Vec.div([bounds.width, bounds.height], 2)
      };
    };
  }
};
function getArrowArcPath(start, end, circle, bend) {
  return [
    "M",
    start.point[0],
    start.point[1],
    "A",
    circle[2],
    circle[2],
    0,
    0,
    bend < 0 ? 0 : 1,
    end.point[0],
    end.point[1]
  ].join(" ");
}
function getBendPoint(handles, bend) {
  const { start, end } = handles;
  const dist = src_default.dist(start.point, end.point);
  const midPoint = src_default.med(start.point, end.point);
  const bendDist = dist / 2 * bend;
  const u4 = src_default.uni(src_default.vec(start.point, end.point));
  const point = src_default.toFixed(Math.abs(bendDist) < 10 ? midPoint : src_default.add(midPoint, src_default.mul(src_default.per(u4), bendDist)));
  return point;
}
function renderFreehandArrowShaft(shape) {
  var _a2, _b;
  const { style, id } = shape;
  const { start, end } = shape.handles;
  const getRandom = Utils.rng(id);
  const strokeWidth = getShapeStyle(style).strokeWidth;
  const startPoint = ((_a2 = shape.decorations) == null ? void 0 : _a2.start) ? src_default.nudge(start.point, end.point, strokeWidth) : start.point;
  const endPoint = ((_b = shape.decorations) == null ? void 0 : _b.end) ? src_default.nudge(end.point, start.point, strokeWidth) : end.point;
  const stroke = Te([startPoint, endPoint], {
    size: strokeWidth,
    thinning: 0.618 + getRandom() * 0.2,
    easing: EASINGS.easeOutQuad,
    simulatePressure: true,
    streamline: 0,
    last: true
  });
  const path = Utils.getSvgPathFromStroke(stroke);
  return path;
}
function renderCurvedFreehandArrowShaft(shape, circle, length, easing) {
  var _a2, _b;
  const { style, id } = shape;
  const { start, end } = shape.handles;
  const getRandom = Utils.rng(id);
  const strokeWidth = getShapeStyle(style).strokeWidth;
  const center = [circle[0], circle[1]];
  const radius = circle[2];
  const startPoint = ((_a2 = shape.decorations) == null ? void 0 : _a2.start) ? src_default.rotWith(start.point, center, strokeWidth / length) : start.point;
  const endPoint = ((_b = shape.decorations) == null ? void 0 : _b.end) ? src_default.rotWith(end.point, center, -(strokeWidth / length)) : end.point;
  const startAngle = src_default.angle(center, startPoint);
  const endAngle = src_default.angle(center, endPoint);
  const points = [];
  const count = 8 + Math.floor(Math.abs(length) / 20 * 1 + getRandom() / 2);
  for (let i8 = 0; i8 < count; i8++) {
    const t14 = easing(i8 / count);
    const angle = Utils.lerpAngles(startAngle, endAngle, t14);
    points.push(src_default.toFixed(src_default.nudgeAtAngle(center, angle, radius)));
  }
  const stroke = Te([startPoint, ...points, endPoint], {
    size: 1 + strokeWidth,
    thinning: 0.618 + getRandom() * 0.2,
    easing: EASINGS.easeOutQuad,
    simulatePressure: false,
    streamline: 0,
    last: true
  });
  const path = Utils.getSvgPathFromStroke(stroke);
  return path;
}
function getCtp(shape) {
  const { start, end, bend } = shape.handles;
  return Utils.circleFromThreePoints(start.point, end.point, bend.point);
}
function getArrowArc(shape) {
  const { start, end, bend } = shape.handles;
  const [cx, cy, radius] = Utils.circleFromThreePoints(start.point, end.point, bend.point);
  const center = [cx, cy];
  const length = getArcLength(center, radius, start.point, end.point);
  return { center, radius, length };
}
function getCurvedArrowHeadPoints(A4, r1, C6, r22, sweep) {
  const ints = intersectCircleCircle(A4, r1 * 0.618, C6, r22).points;
  if (!ints) {
    TLDR.warn("Could not find an intersection for the arrow head.");
    return { left: A4, right: A4 };
  }
  const int = sweep ? ints[0] : ints[1];
  const left = int ? src_default.nudge(src_default.rotWith(int, A4, Math.PI / 6), A4, r1 * -0.382) : A4;
  const right = int ? src_default.nudge(src_default.rotWith(int, A4, -Math.PI / 6), A4, r1 * -0.382) : A4;
  return { left, right };
}
function getStraightArrowHeadPoints(A4, B3, r13) {
  const ints = intersectCircleLineSegment(A4, r13, A4, B3).points;
  if (!ints) {
    TLDR.warn("Could not find an intersection for the arrow head.");
    return { left: A4, right: A4 };
  }
  const int = ints[0];
  const left = int ? src_default.rotWith(int, A4, Math.PI / 6) : A4;
  const right = int ? src_default.rotWith(int, A4, -Math.PI / 6) : A4;
  return { left, right };
}
function getCurvedArrowHeadPath(A4, r1, C6, r22, sweep) {
  const { left, right } = getCurvedArrowHeadPoints(A4, r1, C6, r22, sweep);
  return `M ${left} L ${A4} ${right}`;
}
function getStraightArrowHeadPath(A4, B3, r13) {
  const { left, right } = getStraightArrowHeadPoints(A4, B3, r13);
  return `M ${left} L ${A4} ${right}`;
}
function getArrowPath(shape) {
  const {
    decorations,
    handles: { start, end, bend: _bend },
    style
  } = shape;
  const { strokeWidth } = getShapeStyle(style, false);
  const arrowDist = src_default.dist(start.point, end.point);
  const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);
  const path = [];
  const isStraightLine = src_default.dist(_bend.point, src_default.toFixed(src_default.med(start.point, end.point))) < 1;
  if (isStraightLine) {
    path.push(`M ${start.point} L ${end.point}`);
    if (decorations == null ? void 0 : decorations.start) {
      path.push(getStraightArrowHeadPath(start.point, end.point, arrowHeadLength));
    }
    if (decorations == null ? void 0 : decorations.end) {
      path.push(getStraightArrowHeadPath(end.point, start.point, arrowHeadLength));
    }
  } else {
    const { center, radius, length } = getArrowArc(shape);
    path.push(`M ${start.point} A ${radius} ${radius} 0 0 ${length > 0 ? "1" : "0"} ${end.point}`);
    if (decorations == null ? void 0 : decorations.start) {
      path.push(getCurvedArrowHeadPath(start.point, arrowHeadLength, center, radius, length < 0));
    }
    if (decorations == null ? void 0 : decorations.end) {
      path.push(getCurvedArrowHeadPath(end.point, arrowHeadLength, center, radius, length >= 0));
    }
  }
  return path.join(" ");
}
function getArcPoints(shape) {
  const { start, bend, end } = shape.handles;
  if (src_default.dist2(bend.point, src_default.med(start.point, end.point)) > 4) {
    const points = [];
    const { center, radius } = getArrowArc(shape);
    const startAngle = src_default.angle(center, start.point);
    const endAngle = src_default.angle(center, end.point);
    for (let i8 = 1 / 20; i8 < 1; i8 += 1 / 20) {
      const angle = Utils.lerpAngles(startAngle, endAngle, i8);
      points.push(src_default.nudgeAtAngle(center, angle, radius));
    }
    return points;
  } else {
    return [start.point, end.point];
  }
}
function isAngleBetween2(a9, b7, c7) {
  if (c7 === a9 || c7 === b7)
    return true;
  const PI24 = Math.PI * 2;
  const AB = (b7 - a9 + PI24) % PI24;
  const AC = (c7 - a9 + PI24) % PI24;
  return AB <= Math.PI !== AC > AB;
}
function getArcLength(C6, r13, A4, B3) {
  const sweep = Utils.getSweep(C6, A4, B3);
  return r13 * (2 * Math.PI) * (sweep / (2 * Math.PI));
}
var ArrowUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Arrow;
    this.hideBounds = true;
    this.pathCache = new WeakMap();
    this.getShape = (props) => {
      var _a2, _b, _c, _d;
      return __spreadValues4({
        id: "id",
        type: TDShapeType.Arrow,
        name: "Arrow",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        rotation: 0,
        bend: 0,
        handles: {
          start: __spreadValues4({
            id: "start",
            index: 0,
            point: [0, 0],
            canBind: true
          }, (_a2 = props.handles) == null ? void 0 : _a2.start),
          end: __spreadValues4({
            id: "end",
            index: 1,
            point: [1, 1],
            canBind: true
          }, (_b = props.handles) == null ? void 0 : _b.end),
          bend: __spreadValues4({
            id: "bend",
            index: 2,
            point: [0.5, 0.5]
          }, (_c = props.handles) == null ? void 0 : _c.bend)
        },
        decorations: (_d = props.decorations) != null ? _d : {
          end: Decoration.Arrow
        },
        style: __spreadValues4(__spreadProps4(__spreadValues4({}, defaultStyle), {
          isFilled: false
        }), props.style)
      }, props);
    };
    this.Component = TDShapeUtil.Component(({ shape, isGhost, meta, events }, ref) => {
      const {
        handles: { start, bend, end },
        decorations = {},
        style
      } = shape;
      const isDraw = style.dash === DashStyle.Draw;
      const isStraightLine = Vec.dist(bend.point, Vec.toFixed(Vec.med(start.point, end.point))) < 1;
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const { strokeWidth } = styles22;
      const arrowDist = Vec.dist(start.point, end.point);
      const arrowHeadLength = Math.min(arrowDist / 3, strokeWidth * 8);
      const sw = 1 + strokeWidth * 1.618;
      let shaftPath;
      let startArrowHead;
      let endArrowHead;
      const getRandom = Utils.rng(shape.id);
      const easing = EASINGS[getRandom() > 0 ? "easeInOutSine" : "easeInOutCubic"];
      if (isStraightLine) {
        const path = isDraw ? renderFreehandArrowShaft(shape) : "M" + Vec.toFixed(start.point) + "L" + Vec.toFixed(end.point);
        const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(arrowDist, strokeWidth * 1.618, shape.style.dash, 2, false);
        if (decorations.start) {
          startArrowHead = getStraightArrowHeadPoints(start.point, end.point, arrowHeadLength);
        }
        if (decorations.end) {
          endArrowHead = getStraightArrowHeadPoints(end.point, start.point, arrowHeadLength);
        }
        shaftPath = arrowDist > 2 ? /* @__PURE__ */ (0, import_react66.createElement)(import_react66.Fragment, null, /* @__PURE__ */ (0, import_react66.createElement)("path", {
          className: "tl-stroke-hitarea",
          d: path
        }), /* @__PURE__ */ (0, import_react66.createElement)("path", {
          d: path,
          fill: styles22.stroke,
          stroke: styles22.stroke,
          strokeWidth: isDraw ? sw / 2 : sw,
          strokeDasharray,
          strokeDashoffset,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          pointerEvents: "stroke"
        })) : null;
      } else {
        const circle = getCtp(shape);
        const { center, radius, length } = getArrowArc(shape);
        const path = isDraw ? renderCurvedFreehandArrowShaft(shape, circle, length, easing) : getArrowArcPath(start, end, circle, shape.bend);
        const { strokeDasharray, strokeDashoffset } = Utils.getPerfectDashProps(Math.abs(length), sw, shape.style.dash, 2, false);
        if (decorations.start) {
          startArrowHead = getCurvedArrowHeadPoints(start.point, arrowHeadLength, center, radius, length < 0);
        }
        if (decorations.end) {
          endArrowHead = getCurvedArrowHeadPoints(end.point, arrowHeadLength, center, radius, length >= 0);
        }
        shaftPath = /* @__PURE__ */ (0, import_react66.createElement)(import_react66.Fragment, null, /* @__PURE__ */ (0, import_react66.createElement)("path", {
          className: "tl-stroke-hitarea",
          d: path
        }), /* @__PURE__ */ (0, import_react66.createElement)("path", {
          d: path,
          fill: isDraw ? styles22.stroke : "none",
          stroke: styles22.stroke,
          strokeWidth: isDraw ? 0 : sw,
          strokeDasharray,
          strokeDashoffset,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          pointerEvents: "none"
        }));
      }
      return /* @__PURE__ */ (0, import_react66.createElement)(SVGContainer, __spreadValues4({
        ref,
        id: shape.id + "_svg"
      }, events), /* @__PURE__ */ (0, import_react66.createElement)("g", {
        pointerEvents: "none",
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, shaftPath, startArrowHead && /* @__PURE__ */ (0, import_react66.createElement)(import_react66.Fragment, null, /* @__PURE__ */ (0, import_react66.createElement)("path", {
        className: "tl-stroke-hitarea",
        d: `M ${startArrowHead.left} L ${start.point} ${startArrowHead.right}`
      }), /* @__PURE__ */ (0, import_react66.createElement)("path", {
        d: `M ${startArrowHead.left} L ${start.point} ${startArrowHead.right}`,
        fill: "none",
        stroke: styles22.stroke,
        strokeWidth: sw,
        strokeLinecap: "round",
        strokeLinejoin: "round",
        pointerEvents: "none"
      })), endArrowHead && /* @__PURE__ */ (0, import_react66.createElement)(import_react66.Fragment, null, /* @__PURE__ */ (0, import_react66.createElement)("path", {
        className: "tl-stroke-hitarea",
        d: `M ${endArrowHead.left} L ${end.point} ${endArrowHead.right}`
      }), /* @__PURE__ */ (0, import_react66.createElement)("path", {
        d: `M ${endArrowHead.left} L ${end.point} ${endArrowHead.right}`,
        fill: "none",
        stroke: styles22.stroke,
        strokeWidth: sw,
        strokeLinecap: "round",
        strokeLinejoin: "round",
        pointerEvents: "none"
      }))));
    });
    this.Indicator = TDShapeUtil.Indicator(({ shape }) => {
      return /* @__PURE__ */ (0, import_react66.createElement)("path", {
        d: getArrowPath(shape)
      });
    });
    this.getBounds = (shape) => {
      const bounds = Utils.getFromCache(this.boundsCache, shape, () => {
        return Utils.getBoundsFromPoints(getArcPoints(shape));
      });
      return Utils.translateBounds(bounds, shape.point);
    };
    this.getRotatedBounds = (shape) => {
      let points = getArcPoints(shape);
      const { minX, minY, maxX, maxY } = Utils.getBoundsFromPoints(points);
      if (shape.rotation !== 0) {
        points = points.map((pt) => Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], shape.rotation || 0));
      }
      return Utils.translateBounds(Utils.getBoundsFromPoints(points), shape.point);
    };
    this.getCenter = (shape) => {
      const { start, end } = shape.handles;
      return Vec.add(shape.point, Vec.med(start.point, end.point));
    };
    this.shouldRender = (prev, next) => {
      return next.decorations !== prev.decorations || next.handles !== prev.handles || next.style !== prev.style;
    };
    this.hitTestPoint = (shape, point) => {
      const pt = Vec.sub(point, shape.point);
      const points = getArcPoints(shape);
      for (let i8 = 1; i8 < points.length; i8++) {
        if (Vec.distanceToLineSegment(points[i8 - 1], points[i8], pt) < 1) {
          return true;
        }
      }
      return false;
    };
    this.hitTestLineSegment = (shape, A4, B3) => {
      const ptA = Vec.sub(A4, shape.point);
      const ptB = Vec.sub(B3, shape.point);
      const points = getArcPoints(shape);
      for (let i8 = 1; i8 < points.length; i8++) {
        if (intersectLineSegmentLineSegment(points[i8 - 1], points[i8], ptA, ptB).didIntersect) {
          return true;
        }
      }
      return false;
    };
    this.hitTestBounds = (shape, bounds) => {
      const { start, end, bend } = shape.handles;
      const sp = Vec.add(shape.point, start.point);
      const ep = Vec.add(shape.point, end.point);
      if (Utils.pointInBounds(sp, bounds) || Utils.pointInBounds(ep, bounds)) {
        return true;
      }
      if (Vec.isEqual(Vec.med(start.point, end.point), bend.point)) {
        return intersectLineSegmentBounds(sp, ep, bounds).length > 0;
      } else {
        const [cx, cy, r13] = getCtp(shape);
        const cp = Vec.add(shape.point, [cx, cy]);
        return intersectArcBounds(cp, r13, sp, ep, bounds).length > 0;
      }
    };
    this.transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {
      const initialShapeBounds = this.getBounds(initialShape);
      const handles = ["start", "end"];
      const nextHandles = __spreadValues4({}, initialShape.handles);
      handles.forEach((handle) => {
        const [x5, y4] = nextHandles[handle].point;
        const nw = x5 / initialShapeBounds.width;
        const nh = y4 / initialShapeBounds.height;
        nextHandles[handle] = __spreadProps4(__spreadValues4({}, nextHandles[handle]), {
          point: [
            bounds.width * (scaleX < 0 ? 1 - nw : nw),
            bounds.height * (scaleY < 0 ? 1 - nh : nh)
          ]
        });
      });
      const { start, bend, end } = nextHandles;
      const dist = Vec.dist(start.point, end.point);
      const midPoint = Vec.med(start.point, end.point);
      const bendDist = dist / 2 * initialShape.bend;
      const u4 = Vec.uni(Vec.vec(start.point, end.point));
      const point = Vec.add(midPoint, Vec.mul(Vec.per(u4), bendDist));
      nextHandles["bend"] = __spreadProps4(__spreadValues4({}, bend), {
        point: Vec.toFixed(Math.abs(bendDist) < 10 ? midPoint : point)
      });
      return {
        point: Vec.toFixed([bounds.minX, bounds.minY]),
        handles: nextHandles
      };
    };
    this.onDoubleClickHandle = (shape, handle) => {
      var _a2, _b;
      switch (handle) {
        case "bend": {
          return {
            bend: 0,
            handles: __spreadProps4(__spreadValues4({}, shape.handles), {
              bend: __spreadProps4(__spreadValues4({}, shape.handles.bend), {
                point: getBendPoint(shape.handles, shape.bend)
              })
            })
          };
        }
        case "start": {
          return {
            decorations: __spreadProps4(__spreadValues4({}, shape.decorations), {
              start: ((_a2 = shape.decorations) == null ? void 0 : _a2.start) ? void 0 : Decoration.Arrow
            })
          };
        }
        case "end": {
          return {
            decorations: __spreadProps4(__spreadValues4({}, shape.decorations), {
              end: ((_b = shape.decorations) == null ? void 0 : _b.end) ? void 0 : Decoration.Arrow
            })
          };
        }
      }
      return this;
    };
    this.onBindingChange = (shape, binding, target, targetBounds, expandedBounds, center) => {
      const handle = shape.handles[binding.handleId];
      let handlePoint = Vec.sub(Vec.add([expandedBounds.minX, expandedBounds.minY], Vec.mulV([expandedBounds.width, expandedBounds.height], Vec.rotWith(binding.point, [0.5, 0.5], target.rotation || 0))), shape.point);
      if (binding.distance) {
        const intersectBounds = Utils.expandBounds(targetBounds, binding.distance);
        const origin = Vec.add(shape.point, shape.handles[handle.id === "start" ? "end" : "start"].point);
        const direction = Vec.uni(Vec.sub(Vec.add(handlePoint, shape.point), origin));
        if (target.type === TDShapeType.Ellipse) {
          const hits = intersectRayEllipse(origin, direction, center, target.radius[0] + binding.distance, target.radius[1] + binding.distance, target.rotation || 0).points.sort((a9, b7) => Vec.dist(a9, origin) - Vec.dist(b7, origin));
          if (hits[0]) {
            handlePoint = Vec.sub(hits[0], shape.point);
          }
        } else if (target.type === TDShapeType.Triangle) {
          const points = getTrianglePoints(target, BINDING_DISTANCE, target.rotation).map((pt) => Vec.add(pt, target.point));
          const segments = Utils.pointsToLineSegments(points, true);
          const hits = segments.map((segment) => intersectRayLineSegment(origin, direction, segment[0], segment[1])).filter((intersection) => intersection.didIntersect).flatMap((intersection) => intersection.points).sort((a9, b7) => Vec.dist(a9, origin) - Vec.dist(b7, origin));
          if (hits[0]) {
            handlePoint = Vec.sub(hits[0], shape.point);
          }
        } else {
          let hits = intersectRayBounds(origin, direction, intersectBounds, target.rotation).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a9, b7) => Vec.dist(a9, origin) - Vec.dist(b7, origin));
          if (hits.length < 2) {
            hits = intersectRayBounds(origin, Vec.neg(direction), intersectBounds).filter((int) => int.didIntersect).map((int) => int.points[0]).sort((a9, b7) => Vec.dist(a9, origin) - Vec.dist(b7, origin));
          }
          if (hits[0]) {
            handlePoint = Vec.sub(hits[0], shape.point);
          }
        }
      }
      return this.onHandleChange(shape, {
        [handle.id]: __spreadProps4(__spreadValues4({}, handle), {
          point: Vec.toFixed(handlePoint)
        })
      });
    };
    this.onHandleChange = (shape, handles) => {
      let nextHandles = Utils.deepMerge(shape.handles, handles);
      let nextBend = shape.bend;
      nextHandles = __spreadProps4(__spreadValues4({}, nextHandles), {
        start: __spreadProps4(__spreadValues4({}, nextHandles.start), {
          point: Vec.toFixed(nextHandles.start.point)
        }),
        end: __spreadProps4(__spreadValues4({}, nextHandles.end), {
          point: Vec.toFixed(nextHandles.end.point)
        })
      });
      if ("bend" in handles) {
        const { start, end, bend } = nextHandles;
        const distance = Vec.dist(start.point, end.point);
        const midPoint = Vec.med(start.point, end.point);
        const angle = Vec.angle(start.point, end.point);
        const u4 = Vec.uni(Vec.vec(start.point, end.point));
        const ap = Vec.add(midPoint, Vec.mul(Vec.per(u4), distance / 2));
        const bp = Vec.sub(midPoint, Vec.mul(Vec.per(u4), distance / 2));
        const bendPoint = Vec.nearestPointOnLineSegment(ap, bp, bend.point, true);
        const bendDist = Vec.dist(midPoint, bendPoint);
        nextBend = Utils.clamp(bendDist / (distance / 2), -0.99, 0.99);
        const angleToBend = Vec.angle(start.point, bendPoint);
        if (Vec.isEqual(midPoint, getBendPoint(nextHandles, nextBend))) {
          nextBend = 0;
        } else if (isAngleBetween2(angle, angle + Math.PI, angleToBend)) {
          nextBend *= -1;
        }
      }
      const nextShape = {
        point: shape.point,
        bend: nextBend,
        handles: __spreadProps4(__spreadValues4({}, nextHandles), {
          bend: __spreadProps4(__spreadValues4({}, nextHandles.bend), {
            point: getBendPoint(nextHandles, nextBend)
          })
        })
      };
      const topLeft = shape.point;
      const nextBounds = this.getBounds(__spreadValues4({}, nextShape));
      const offset = Vec.sub([nextBounds.minX, nextBounds.minY], topLeft);
      if (!Vec.isEqual(offset, [0, 0])) {
        Object.values(nextShape.handles).forEach((handle) => {
          handle.point = Vec.toFixed(Vec.sub(handle.point, offset));
        });
        nextShape.point = Vec.toFixed(Vec.add(nextShape.point, offset));
      }
      return nextShape;
    };
  }
};
var GroupUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Group;
    this.canBind = true;
    this.getShape = (props) => {
      return Utils.deepMerge({
        id: "id",
        type: TDShapeType.Group,
        name: "Group",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [100, 100],
        rotation: 0,
        children: [],
        style: defaultStyle
      }, props);
    };
    this.Component = TDShapeUtil.Component(({ shape, isBinding, isGhost, isHovered, isSelected, events }, ref) => {
      const { id, size } = shape;
      const sw = 2;
      const w6 = Math.max(0, size[0] - sw / 2);
      const h3 = Math.max(0, size[1] - sw / 2);
      const strokes2 = [
        [[sw / 2, sw / 2], [w6, sw / 2], w6 - sw / 2],
        [[w6, sw / 2], [w6, h3], h3 - sw / 2],
        [[w6, h3], [sw / 2, h3], w6 - sw / 2],
        [[sw / 2, h3], [sw / 2, sw / 2], h3 - sw / 2]
      ];
      const paths = strokes2.map(([start, end], i8) => {
        return /* @__PURE__ */ (0, import_react67.createElement)("line", {
          key: id + "_" + i8,
          x1: start[0],
          y1: start[1],
          x2: end[0],
          y2: end[1]
        });
      });
      return /* @__PURE__ */ (0, import_react67.createElement)(SVGContainer, __spreadValues4({
        ref
      }, events), isBinding && /* @__PURE__ */ (0, import_react67.createElement)("rect", {
        className: "tl-binding-indicator",
        strokeWidth: this.bindingDistance
      }), /* @__PURE__ */ (0, import_react67.createElement)("g", {
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, /* @__PURE__ */ (0, import_react67.createElement)("rect", {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        fill: "transparent",
        pointerEvents: "all"
      }), /* @__PURE__ */ (0, import_react67.createElement)(ScaledLines, {
        stroke: ColorStyle.Black,
        opacity: isHovered || isSelected ? 1 : 0,
        strokeLinecap: "round",
        pointerEvents: "stroke"
      }, paths)));
    });
    this.Indicator = TDShapeUtil.Indicator(({ shape }) => {
      const { id, size } = shape;
      const sw = 2;
      const w6 = Math.max(0, size[0] - sw / 2);
      const h3 = Math.max(0, size[1] - sw / 2);
      const strokes2 = [
        [[sw / 2, sw / 2], [w6, sw / 2], w6 - sw / 2],
        [[w6, sw / 2], [w6, h3], h3 - sw / 2],
        [[w6, h3], [sw / 2, h3], w6 - sw / 2],
        [[sw / 2, h3], [sw / 2, sw / 2], h3 - sw / 2]
      ];
      const paths = strokes2.map(([start, end], i8) => {
        return /* @__PURE__ */ (0, import_react67.createElement)("line", {
          key: id + "_" + i8,
          x1: start[0],
          y1: start[1],
          x2: end[0],
          y2: end[1]
        });
      });
      return /* @__PURE__ */ (0, import_react67.createElement)(ScaledLines, {
        strokeLinecap: "round",
        pointerEvents: "stroke"
      }, paths);
    });
    this.getBounds = (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    };
    this.shouldRender = (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style;
    };
  }
};
var ScaledLines = styled("g", {
  strokeWidth: "calc(1.5px * var(--tl-scale))",
  strokeDasharray: `calc(1px * var(--tl-scale)), calc(3px * var(--tl-scale))`
});
var ALIGN_VALUES = {
  [AlignStyle.Start]: "left",
  [AlignStyle.Middle]: "center",
  [AlignStyle.End]: "right",
  [AlignStyle.Justify]: "justify"
};
function getTextAlign(alignStyle = AlignStyle.Start) {
  return ALIGN_VALUES[alignStyle];
}
function getTextSvgElement(shape, bounds) {
  const { text, style } = shape;
  const fontSize = getFontSize(shape.style.size, shape.style.font);
  const g5 = document.createElementNS("http://www.w3.org/2000/svg", "g");
  const LINE_HEIGHT2 = fontSize * 1.3;
  const textLines = text.split("\n").map((line, i8) => {
    const textElm = document.createElementNS("http://www.w3.org/2000/svg", "text");
    textElm.textContent = line;
    textElm.setAttribute("font-family", getFontFace(style.font));
    textElm.setAttribute("font-size", fontSize + "px");
    textElm.setAttribute("text-anchor", "start");
    textElm.setAttribute("alignment-baseline", "central");
    textElm.setAttribute("text-align", getTextAlign(style.textAlign));
    textElm.setAttribute("y", LINE_HEIGHT2 * (0.5 + i8) + "");
    g5.appendChild(textElm);
    return textElm;
  });
  if (style.textAlign === AlignStyle.Middle) {
    textLines.forEach((textElm) => {
      textElm.setAttribute("x", bounds.width / 2 + "");
      textElm.setAttribute("text-align", "center");
      textElm.setAttribute("text-anchor", "middle");
    });
  } else if (style.textAlign === AlignStyle.End) {
    textLines.forEach((textElm) => {
      textElm.setAttribute("x", bounds.width + "");
      textElm.setAttribute("text-align", "right");
      textElm.setAttribute("text-anchor", "end");
    });
  }
  return g5;
}
var stopPropagation = (e12) => e12.stopPropagation();
var StickyUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Sticky;
    this.canBind = true;
    this.canEdit = true;
    this.canClone = true;
    this.hideResizeHandles = true;
    this.showCloneHandles = true;
    this.getShape = (props) => {
      return Utils.deepMerge({
        id: "id",
        type: TDShapeType.Sticky,
        name: "Sticky",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        size: [200, 200],
        text: "",
        rotation: 0,
        style: defaultTextStyle
      }, props);
    };
    this.Component = TDShapeUtil.Component(({ shape, meta, events, isGhost, isBinding, isEditing, onShapeBlur, onShapeChange }, ref) => {
      const font = getStickyFontStyle(shape.style);
      const { color, fill } = getStickyShapeStyle(shape.style, meta.isDarkMode);
      const rContainer = (0, import_react68.useRef)(null);
      const rTextArea = (0, import_react68.useRef)(null);
      const rText = (0, import_react68.useRef)(null);
      const rIsMounted = (0, import_react68.useRef)(false);
      const handlePointerDown = (0, import_react68.useCallback)((e12) => {
        e12.stopPropagation();
      }, []);
      const handleTextChange = (0, import_react68.useCallback)((e12) => {
        onShapeChange == null ? void 0 : onShapeChange({
          id: shape.id,
          type: shape.type,
          text: TLDR.normalizeText(e12.currentTarget.value)
        });
      }, [onShapeChange]);
      const handleKeyDown = (0, import_react68.useCallback)((e12) => {
        if (e12.key === "Escape")
          return;
        if (e12.key === "Tab" && shape.text.length === 0) {
          e12.preventDefault();
          return;
        }
        if (!(e12.key === "Meta" || e12.metaKey)) {
          e12.stopPropagation();
        } else if (e12.key === "z" && e12.metaKey) {
          if (e12.shiftKey) {
            document.execCommand("redo", false);
          } else {
            document.execCommand("undo", false);
          }
          e12.stopPropagation();
          e12.preventDefault();
          return;
        }
        if (e12.key === "Tab") {
          e12.preventDefault();
          if (e12.shiftKey) {
            TextAreaUtils.unindent(e12.currentTarget);
          } else {
            TextAreaUtils.indent(e12.currentTarget);
          }
          onShapeChange == null ? void 0 : onShapeChange(__spreadProps4(__spreadValues4({}, shape), { text: TLDR.normalizeText(e12.currentTarget.value) }));
        }
      }, [shape, onShapeChange]);
      const handleBlur = (0, import_react68.useCallback)((e12) => {
        e12.currentTarget.setSelectionRange(0, 0);
        onShapeBlur == null ? void 0 : onShapeBlur();
      }, []);
      const handleFocus = (0, import_react68.useCallback)((e12) => {
        if (!isEditing)
          return;
        if (!rIsMounted.current)
          return;
        e12.currentTarget.select();
      }, [isEditing]);
      (0, import_react68.useEffect)(() => {
        if (isEditing) {
          rIsMounted.current = true;
          const elm = rTextArea.current;
          elm.focus();
          elm.select();
        }
      }, [isEditing]);
      (0, import_react68.useEffect)(() => {
        const text = rText.current;
        const { size } = shape;
        const { offsetHeight: currTextHeight } = text;
        const minTextHeight = MIN_CONTAINER_HEIGHT - PADDING * 2;
        const prevTextHeight = size[1] - PADDING * 2;
        if (currTextHeight === prevTextHeight)
          return;
        if (currTextHeight > minTextHeight) {
          onShapeChange == null ? void 0 : onShapeChange({ id: shape.id, size: [size[0], currTextHeight + PADDING * 2] });
          return;
        }
        if (currTextHeight < minTextHeight && size[1] > MIN_CONTAINER_HEIGHT) {
          onShapeChange == null ? void 0 : onShapeChange({ id: shape.id, size: [size[0], MIN_CONTAINER_HEIGHT] });
          return;
        }
        const textarea = rTextArea.current;
        textarea == null ? void 0 : textarea.focus();
      }, [shape.text, shape.size[1], shape.style]);
      const style = {
        font,
        color,
        textShadow: meta.isDarkMode ? `0.5px 0.5px 2px rgba(255, 255, 255,.25)` : `0.5px 0.5px 2px rgba(255, 255, 255,.5)`
      };
      return /* @__PURE__ */ (0, import_react68.createElement)(HTMLContainer, __spreadValues4({
        ref
      }, events), /* @__PURE__ */ (0, import_react68.createElement)(StyledStickyContainer, {
        ref: rContainer,
        isDarkMode: meta.isDarkMode,
        isGhost,
        style: __spreadValues4({ backgroundColor: fill }, style)
      }, isBinding && /* @__PURE__ */ (0, import_react68.createElement)("div", {
        className: "tl-binding-indicator",
        style: {
          position: "absolute",
          top: -this.bindingDistance,
          left: -this.bindingDistance,
          width: `calc(100% + ${this.bindingDistance * 2}px)`,
          height: `calc(100% + ${this.bindingDistance * 2}px)`,
          backgroundColor: "var(--tl-selectFill)"
        }
      }), /* @__PURE__ */ (0, import_react68.createElement)(StyledText, {
        ref: rText,
        isEditing,
        alignment: shape.style.textAlign
      }, shape.text, "\u200B"), isEditing && /* @__PURE__ */ (0, import_react68.createElement)(StyledTextArea, {
        ref: rTextArea,
        onPointerDown: handlePointerDown,
        value: shape.text,
        onChange: handleTextChange,
        onKeyDown: handleKeyDown,
        onFocus: handleFocus,
        onBlur: handleBlur,
        tabIndex: -1,
        autoComplete: "false",
        autoCapitalize: "false",
        autoCorrect: "false",
        autoSave: "false",
        autoFocus: true,
        spellCheck: true,
        alignment: shape.style.textAlign,
        onContextMenu: stopPropagation
      })));
    });
    this.Indicator = TDShapeUtil.Indicator(({ shape }) => {
      const {
        size: [width, height]
      } = shape;
      return /* @__PURE__ */ (0, import_react68.createElement)("rect", {
        x: 0,
        y: 0,
        rx: 3,
        ry: 3,
        width: Math.max(1, width),
        height: Math.max(1, height)
      });
    });
    this.getBounds = (shape) => {
      return getBoundsRectangle(shape, this.boundsCache);
    };
    this.shouldRender = (prev, next) => {
      return next.size !== prev.size || next.style !== prev.style || next.text !== prev.text;
    };
    this.transform = (shape, bounds, { scaleX, scaleY, transformOrigin }) => {
      const point = Vec.toFixed([
        bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]),
        bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])
      ]);
      return {
        point
      };
    };
    this.transformSingle = (shape) => {
      return shape;
    };
    this.getSvgElement = (shape) => {
      const bounds = this.getBounds(shape);
      const textElm = getTextSvgElement(shape, bounds);
      const style = getStickyShapeStyle(shape.style);
      textElm.setAttribute("fill", style.color);
      const g5 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("width", bounds.width + "");
      rect.setAttribute("height", bounds.height + "");
      rect.setAttribute("fill", style.fill);
      g5.appendChild(rect);
      g5.appendChild(textElm);
      return g5;
    };
  }
};
var PADDING = 16;
var MIN_CONTAINER_HEIGHT = 200;
var StyledStickyContainer = styled("div", {
  pointerEvents: "all",
  position: "relative",
  backgroundColor: "rgba(255, 220, 100)",
  fontFamily: "sans-serif",
  height: "100%",
  width: "100%",
  padding: PADDING + "px",
  borderRadius: "3px",
  perspective: "800px",
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    },
    isDarkMode: {
      true: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)"
      },
      false: {
        boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)"
      }
    }
  }
});
var commonTextWrapping = {
  whiteSpace: "pre-wrap",
  overflowWrap: "break-word"
};
var StyledText = styled("div", __spreadValues4({
  position: "absolute",
  top: PADDING,
  left: PADDING,
  width: `calc(100% - ${PADDING * 2}px)`,
  height: "fit-content",
  font: "inherit",
  pointerEvents: "none",
  userSelect: "none",
  variants: {
    isEditing: {
      true: {
        opacity: 1
      },
      false: {
        opacity: 1
      }
    },
    alignment: {
      [AlignStyle.Start]: {
        textAlign: "left"
      },
      [AlignStyle.Middle]: {
        textAlign: "center"
      },
      [AlignStyle.End]: {
        textAlign: "right"
      },
      [AlignStyle.Justify]: {
        textAlign: "justify"
      }
    }
  }
}, commonTextWrapping));
var StyledTextArea = styled("textarea", __spreadProps4(__spreadValues4({
  width: "100%",
  height: "100%",
  border: "none",
  overflow: "hidden",
  background: "none",
  outline: "none",
  textAlign: "left",
  font: "inherit",
  padding: 0,
  color: "transparent",
  verticalAlign: "top",
  resize: "none",
  caretColor: "black"
}, commonTextWrapping), {
  variants: {
    alignment: {
      [AlignStyle.Start]: {
        textAlign: "left"
      },
      [AlignStyle.Middle]: {
        textAlign: "center"
      },
      [AlignStyle.End]: {
        textAlign: "right"
      },
      [AlignStyle.Justify]: {
        textAlign: "justify"
      }
    }
  }
}));
var TextUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Text;
    this.isAspectRatioLocked = true;
    this.canEdit = true;
    this.canBind = true;
    this.canClone = true;
    this.bindingDistance = BINDING_DISTANCE / 2;
    this.getShape = (props) => {
      return Utils.deepMerge({
        id: "id",
        type: TDShapeType.Text,
        name: "Text",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        rotation: 0,
        text: " ",
        style: defaultTextStyle
      }, props);
    };
    this.Component = TDShapeUtil.Component(({ shape, isBinding, isGhost, isEditing, onShapeBlur, onShapeChange, meta, events }, ref) => {
      const rInput = (0, import_react69.useRef)(null);
      const { text, style } = shape;
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const font = getFontStyle(shape.style);
      const rIsMounted = (0, import_react69.useRef)(false);
      const handleChange = (0, import_react69.useCallback)((e12) => {
        let delta = [0, 0];
        const currentBounds = this.getBounds(shape);
        switch (shape.style.textAlign) {
          case AlignStyle.Start: {
            break;
          }
          case AlignStyle.Middle: {
            const nextBounds = this.getBounds(__spreadProps4(__spreadValues4({}, shape), {
              text: TLDR.normalizeText(e12.currentTarget.value)
            }));
            delta = Vec.div([nextBounds.width - currentBounds.width, 0], 2);
            break;
          }
          case AlignStyle.End: {
            const nextBounds = this.getBounds(__spreadProps4(__spreadValues4({}, shape), {
              text: TLDR.normalizeText(e12.currentTarget.value)
            }));
            delta = [nextBounds.width - currentBounds.width, 0];
            break;
          }
        }
        onShapeChange == null ? void 0 : onShapeChange(__spreadProps4(__spreadValues4({}, shape), {
          point: Vec.sub(shape.point, delta),
          text: TLDR.normalizeText(e12.currentTarget.value)
        }));
      }, [shape]);
      const handleKeyDown = (0, import_react69.useCallback)((e12) => {
        if (!(e12.key === "Meta" || e12.metaKey)) {
          e12.stopPropagation();
        } else if (e12.key === "z" && e12.metaKey) {
          if (e12.shiftKey) {
            document.execCommand("redo", false);
          } else {
            document.execCommand("undo", false);
          }
          e12.stopPropagation();
          e12.preventDefault();
          return;
        }
        if (e12.key === "Escape" || e12.key === "Enter" && (e12.ctrlKey || e12.metaKey)) {
          e12.currentTarget.blur();
          return;
        }
        if (e12.key === "Tab") {
          e12.preventDefault();
          if (e12.shiftKey) {
            TextAreaUtils.unindent(e12.currentTarget);
          } else {
            TextAreaUtils.indent(e12.currentTarget);
          }
          onShapeChange == null ? void 0 : onShapeChange(__spreadProps4(__spreadValues4({}, shape), { text: TLDR.normalizeText(e12.currentTarget.value) }));
        }
      }, [shape, onShapeChange]);
      const handleBlur = (0, import_react69.useCallback)((e12) => {
        e12.currentTarget.setSelectionRange(0, 0);
        onShapeBlur == null ? void 0 : onShapeBlur();
      }, []);
      const handleFocus = (0, import_react69.useCallback)((e12) => {
        if (!isEditing)
          return;
        if (!rIsMounted.current)
          return;
        if (document.activeElement === e12.currentTarget) {
          e12.currentTarget.select();
        }
      }, [isEditing]);
      const handlePointerDown = (0, import_react69.useCallback)((e12) => {
        if (isEditing) {
          e12.stopPropagation();
        }
      }, [isEditing]);
      (0, import_react69.useEffect)(() => {
        if (isEditing) {
          requestAnimationFrame(() => {
            rIsMounted.current = true;
            const elm = rInput.current;
            if (elm) {
              elm.focus();
              elm.select();
            }
          });
        } else {
          onShapeBlur == null ? void 0 : onShapeBlur();
        }
      }, [isEditing]);
      return /* @__PURE__ */ (0, import_react69.createElement)(HTMLContainer, __spreadValues4({
        ref
      }, events), /* @__PURE__ */ (0, import_react69.createElement)(Wrapper, {
        isGhost,
        isEditing,
        onPointerDown: handlePointerDown
      }, /* @__PURE__ */ (0, import_react69.createElement)(InnerWrapper, {
        style: {
          font,
          color: styles22.stroke,
          textAlign: getTextAlign(style.textAlign)
        }
      }, isBinding && /* @__PURE__ */ (0, import_react69.createElement)("div", {
        className: "tl-binding-indicator",
        style: {
          position: "absolute",
          top: -this.bindingDistance,
          left: -this.bindingDistance,
          width: `calc(100% + ${this.bindingDistance * 2}px)`,
          height: `calc(100% + ${this.bindingDistance * 2}px)`,
          backgroundColor: "var(--tl-selectFill)"
        }
      }), isEditing ? /* @__PURE__ */ (0, import_react69.createElement)(TextArea, {
        ref: rInput,
        style: {
          font,
          color: styles22.stroke
        },
        name: "text",
        defaultValue: text,
        tabIndex: -1,
        autoComplete: "false",
        autoCapitalize: "false",
        autoCorrect: "false",
        autoSave: "false",
        autoFocus: true,
        placeholder: "",
        color: styles22.stroke,
        onFocus: handleFocus,
        onChange: handleChange,
        onKeyDown: handleKeyDown,
        onBlur: handleBlur,
        onPointerDown: handlePointerDown,
        spellCheck: "true",
        wrap: "off",
        dir: "auto",
        datatype: "wysiwyg",
        onContextMenu: stopPropagation
      }) : text, "\u200B")));
    });
    this.Indicator = TDShapeUtil.Indicator(({ shape }) => {
      const { width, height } = this.getBounds(shape);
      return /* @__PURE__ */ (0, import_react69.createElement)("rect", {
        x: 0,
        y: 0,
        width,
        height
      });
    });
    this.getBounds = (shape) => {
      const bounds = Utils.getFromCache(this.boundsCache, shape, () => {
        if (!melm) {
          return { minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10 };
        }
        melm.innerHTML = `${shape.text}&zwj;`;
        melm.style.font = getFontStyle(shape.style);
        const width = melm.offsetWidth || 1;
        const height = melm.offsetHeight || 1;
        return {
          minX: 0,
          maxX: width,
          minY: 0,
          maxY: height,
          width,
          height
        };
      });
      return Utils.translateBounds(bounds, shape.point);
    };
    this.shouldRender = (prev, next) => {
      return next.text !== prev.text || next.style.scale !== prev.style.scale || next.style !== prev.style;
    };
    this.transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {
      const {
        rotation = 0,
        style: { scale = 1 }
      } = initialShape;
      const nextScale = scale * Math.abs(Math.min(scaleX, scaleY));
      return {
        point: [bounds.minX, bounds.minY],
        rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation,
        style: __spreadProps4(__spreadValues4({}, initialShape.style), {
          scale: nextScale
        })
      };
    };
    this.transformSingle = (shape, bounds, { initialShape, scaleX, scaleY }) => {
      const {
        style: { scale = 1 }
      } = initialShape;
      return {
        point: Vec.toFixed([bounds.minX, bounds.minY]),
        style: __spreadProps4(__spreadValues4({}, initialShape.style), {
          scale: scale * Math.max(Math.abs(scaleY), Math.abs(scaleX))
        })
      };
    };
    this.onDoubleClickBoundsHandle = (shape) => {
      const center = this.getCenter(shape);
      const newCenter = this.getCenter(__spreadProps4(__spreadValues4({}, shape), {
        style: __spreadProps4(__spreadValues4({}, shape.style), {
          scale: 1
        })
      }));
      return {
        style: __spreadProps4(__spreadValues4({}, shape.style), {
          scale: 1
        }),
        point: Vec.toFixed(Vec.add(shape.point, Vec.sub(center, newCenter)))
      };
    };
    this.getSvgElement = (shape) => {
      const bounds = this.getBounds(shape);
      const elm = getTextSvgElement(shape, bounds);
      elm.setAttribute("fill", getShapeStyle(shape.style).stroke);
      return elm;
    };
  }
};
var LETTER_SPACING = -1.5;
var melm;
function getMeasurementDiv() {
  var _a2;
  (_a2 = document.getElementById("__textMeasure")) == null ? void 0 : _a2.remove();
  const pre = document.createElement("pre");
  pre.id = "__textMeasure";
  Object.assign(pre.style, {
    whiteSpace: "pre",
    width: "auto",
    border: "1px solid transparent",
    padding: "4px",
    margin: "0px",
    letterSpacing: `${LETTER_SPACING}px`,
    opacity: "0",
    position: "absolute",
    top: "-500px",
    left: "0px",
    zIndex: "9999",
    pointerEvents: "none",
    userSelect: "none",
    alignmentBaseline: "mathematical",
    dominantBaseline: "mathematical"
  });
  pre.tabIndex = -1;
  document.body.appendChild(pre);
  return pre;
}
if (typeof window !== "undefined") {
  melm = getMeasurementDiv();
}
var Wrapper = styled("div", {
  width: "100%",
  height: "100%",
  variants: {
    isGhost: {
      false: { opacity: 1 },
      true: { transition: "opacity .2s", opacity: GHOSTED_OPACITY }
    },
    isEditing: {
      false: {
        pointerEvents: "all",
        userSelect: "all"
      },
      true: {
        pointerEvents: "none",
        userSelect: "none"
      }
    }
  }
});
var commonTextWrapping2 = {
  whiteSpace: "pre-wrap",
  overflowWrap: "break-word"
};
var InnerWrapper = styled("div", __spreadValues4({
  position: "absolute",
  top: "var(--tl-padding)",
  left: "var(--tl-padding)",
  width: "calc(100% - (var(--tl-padding) * 2))",
  height: "calc(100% - (var(--tl-padding) * 2))",
  padding: "4px",
  zIndex: 1,
  minHeight: 1,
  minWidth: 1,
  lineHeight: 1,
  letterSpacing: LETTER_SPACING,
  outline: 0,
  fontWeight: "500",
  backfaceVisibility: "hidden",
  userSelect: "none",
  pointerEvents: "none",
  WebkitUserSelect: "none",
  WebkitTouchCallout: "none",
  isEditing: {
    false: {},
    true: {
      pointerEvents: "all",
      background: "$boundsBg",
      userSelect: "text",
      WebkitUserSelect: "text"
    }
  }
}, commonTextWrapping2));
var TextArea = styled("textarea", __spreadValues4({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  width: "100%",
  height: "100%",
  border: "none",
  padding: "4px",
  resize: "none",
  textAlign: "inherit",
  minHeight: "inherit",
  minWidth: "inherit",
  lineHeight: "inherit",
  letterSpacing: "inherit",
  outline: 0,
  fontWeight: "inherit",
  overflow: "hidden",
  backfaceVisibility: "hidden",
  display: "inline-block",
  pointerEvents: "all",
  background: "$boundsBg",
  userSelect: "text",
  WebkitUserSelect: "text"
}, commonTextWrapping2));
var simulatePressureSettings = {
  easing: (t14) => Math.sin(t14 * Math.PI / 2),
  simulatePressure: true
};
var realPressureSettings = {
  easing: (t14) => t14 * t14,
  simulatePressure: false
};
function getFreehandOptions(shape) {
  const styles22 = getShapeStyle(shape.style);
  const options2 = __spreadProps4(__spreadValues4({
    size: 1 + styles22.strokeWidth * 1.5,
    thinning: 0.65,
    streamline: 0.65,
    smoothing: 0.65
  }, shape.points[1][2] === 0.5 ? simulatePressureSettings : realPressureSettings), {
    last: shape.isComplete
  });
  return options2;
}
function getFillPath(shape) {
  if (shape.points.length < 2)
    return "";
  return Utils.getSvgPathFromStroke(ce(shape.points, getFreehandOptions(shape)).map((pt) => pt.point));
}
function getDrawStrokePoints(shape, options2) {
  return ce(shape.points, options2);
}
function getDrawStrokePathTDSnapshot(shape) {
  if (shape.points.length < 2)
    return "";
  const options2 = getFreehandOptions(shape);
  const strokePoints = getDrawStrokePoints(shape, options2);
  const stroke = ie(strokePoints, options2);
  const path = Utils.getSvgPathFromStroke(stroke);
  return path;
}
function getSolidStrokePathTDSnapshot(shape) {
  const { points } = shape;
  if (points.length < 2)
    return "M 0 0 L 0 0";
  const options2 = getFreehandOptions(shape);
  const strokePoints = getDrawStrokePoints(shape, options2).map((pt) => pt.point.slice(0, 2));
  const path = Utils.getSvgPathFromStroke(strokePoints, false);
  return path;
}
var DrawUtil = class extends TDShapeUtil {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Draw;
    this.pointsBoundsCache = new WeakMap([]);
    this.shapeBoundsCache = new Map();
    this.rotatedCache = new WeakMap([]);
    this.pointCache = {};
    this.canClone = true;
    this.getShape = (props) => {
      return Utils.deepMerge({
        id: "id",
        type: TDShapeType.Draw,
        name: "Draw",
        parentId: "page",
        childIndex: 1,
        point: [0, 0],
        rotation: 0,
        style: defaultStyle,
        points: [],
        isComplete: false
      }, props);
    };
    this.Component = TDShapeUtil.Component(({ shape, meta, isSelected, isGhost, events }, ref) => {
      const { points, style, isComplete } = shape;
      const polygonPathTDSnapshot = (0, import_react70.useMemo)(() => {
        return getFillPath(shape);
      }, [points, style.size]);
      const pathTDSnapshot = (0, import_react70.useMemo)(() => {
        return style.dash === DashStyle.Draw ? getDrawStrokePathTDSnapshot(shape) : getSolidStrokePathTDSnapshot(shape);
      }, [points, style.size, style.dash, isComplete]);
      const styles22 = getShapeStyle(style, meta.isDarkMode);
      const { stroke, fill, strokeWidth } = styles22;
      const bounds = this.getBounds(shape);
      const verySmall = bounds.width <= strokeWidth / 2 && bounds.height <= strokeWidth / 2;
      if (verySmall) {
        const sw2 = 1 + strokeWidth;
        return /* @__PURE__ */ (0, import_react70.createElement)(SVGContainer, __spreadValues4({
          ref,
          id: shape.id + "_svg"
        }, events), /* @__PURE__ */ (0, import_react70.createElement)("circle", {
          r: sw2,
          fill: stroke,
          stroke,
          pointerEvents: "all",
          opacity: isGhost ? GHOSTED_OPACITY : 1
        }));
      }
      const shouldFill = style.isFilled && points.length > 3 && Vec.dist(points[0], points[points.length - 1]) < strokeWidth * 2;
      if (shape.style.dash === DashStyle.Draw) {
        return /* @__PURE__ */ (0, import_react70.createElement)(SVGContainer, __spreadValues4({
          ref,
          id: shape.id + "_svg"
        }, events), /* @__PURE__ */ (0, import_react70.createElement)("g", {
          opacity: isGhost ? GHOSTED_OPACITY : 1
        }, /* @__PURE__ */ (0, import_react70.createElement)("path", {
          className: shouldFill || isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
          d: pathTDSnapshot
        }), shouldFill && /* @__PURE__ */ (0, import_react70.createElement)("path", {
          d: polygonPathTDSnapshot,
          stroke: "none",
          fill,
          strokeLinejoin: "round",
          strokeLinecap: "round",
          pointerEvents: "none"
        }), /* @__PURE__ */ (0, import_react70.createElement)("path", {
          d: pathTDSnapshot,
          fill: stroke,
          stroke,
          strokeWidth: strokeWidth / 2,
          strokeLinejoin: "round",
          strokeLinecap: "round",
          pointerEvents: "none"
        })));
      }
      const strokeDasharray = {
        [DashStyle.Draw]: "none",
        [DashStyle.Solid]: `none`,
        [DashStyle.Dotted]: `0.1 ${strokeWidth * 4}`,
        [DashStyle.Dashed]: `${strokeWidth * 4} ${strokeWidth * 4}`
      }[style.dash];
      const strokeDashoffset = {
        [DashStyle.Draw]: "none",
        [DashStyle.Solid]: `none`,
        [DashStyle.Dotted]: `0`,
        [DashStyle.Dashed]: `0`
      }[style.dash];
      const sw = 1 + strokeWidth * 1.5;
      return /* @__PURE__ */ (0, import_react70.createElement)(SVGContainer, __spreadValues4({
        ref,
        id: shape.id + "_svg"
      }, events), /* @__PURE__ */ (0, import_react70.createElement)("g", {
        opacity: isGhost ? GHOSTED_OPACITY : 1
      }, /* @__PURE__ */ (0, import_react70.createElement)("path", {
        className: shouldFill && isSelected ? "tl-fill-hitarea" : "tl-stroke-hitarea",
        d: pathTDSnapshot
      }), /* @__PURE__ */ (0, import_react70.createElement)("path", {
        d: pathTDSnapshot,
        fill: shouldFill ? fill : "none",
        stroke: "none",
        strokeWidth: Math.min(4, strokeWidth * 2),
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none"
      }), /* @__PURE__ */ (0, import_react70.createElement)("path", {
        d: pathTDSnapshot,
        fill: "none",
        stroke,
        strokeWidth: sw,
        strokeDasharray,
        strokeDashoffset,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none"
      })));
    });
    this.Indicator = TDShapeUtil.Indicator(({ shape }) => {
      const { points } = shape;
      const pathTDSnapshot = (0, import_react70.useMemo)(() => {
        return getSolidStrokePathTDSnapshot(shape);
      }, [points]);
      const bounds = this.getBounds(shape);
      const verySmall = bounds.width < 4 && bounds.height < 4;
      if (verySmall) {
        return /* @__PURE__ */ (0, import_react70.createElement)("circle", {
          x: bounds.width / 2,
          y: bounds.height / 2,
          r: 1
        });
      }
      return /* @__PURE__ */ (0, import_react70.createElement)("path", {
        d: pathTDSnapshot
      });
    });
    this.transform = (shape, bounds, { initialShape, scaleX, scaleY }) => {
      const initialShapeBounds = Utils.getFromCache(this.boundsCache, initialShape, () => Utils.getBoundsFromPoints(initialShape.points));
      const points = initialShape.points.map(([x5, y4, r13]) => {
        return [
          bounds.width * (scaleX < 0 ? 1 - x5 / initialShapeBounds.width : x5 / initialShapeBounds.width),
          bounds.height * (scaleY < 0 ? 1 - y4 / initialShapeBounds.height : y4 / initialShapeBounds.height),
          r13
        ];
      });
      const newBounds = Utils.getBoundsFromPoints(shape.points);
      const point = Vec.sub([bounds.minX, bounds.minY], [newBounds.minX, newBounds.minY]);
      return {
        points,
        point
      };
    };
    this.getBounds = (shape) => {
      const pointsHaveChanged = !this.pointsBoundsCache.has(shape.points);
      const pointHasChanged = !(this.pointCache[shape.id] === shape.point);
      if (pointsHaveChanged) {
        const bounds = Utils.getBoundsFromPoints(shape.points);
        this.pointsBoundsCache.set(shape.points, bounds);
        this.shapeBoundsCache.set(shape.id, Utils.translateBounds(bounds, shape.point));
        this.pointCache[shape.id] = shape.point;
      } else if (pointHasChanged && !pointsHaveChanged) {
        this.pointCache[shape.id] = shape.point;
        this.shapeBoundsCache.set(shape.id, Utils.translateBounds(this.pointsBoundsCache.get(shape.points), shape.point));
      }
      return this.shapeBoundsCache.get(shape.id);
    };
    this.shouldRender = (prev, next) => {
      return next.points !== prev.points || next.style !== prev.style || next.isComplete !== prev.isComplete;
    };
    this.hitTestPoint = (shape, point) => {
      const ptA = Vec.sub(point, shape.point);
      return Utils.pointInPolyline(ptA, shape.points);
    };
    this.hitTestLineSegment = (shape, A4, B3) => {
      const { points, point } = shape;
      const ptA = Vec.sub(A4, point);
      const ptB = Vec.sub(B3, point);
      const bounds = this.getBounds(shape);
      if (points.length <= 2) {
        return Vec.distanceToLineSegment(A4, B3, shape.point) < 4;
      }
      if (intersectLineSegmentBounds(ptA, ptB, bounds)) {
        for (let i8 = 1; i8 < points.length; i8++) {
          if (intersectLineSegmentLineSegment(points[i8 - 1], points[i8], ptA, ptB).didIntersect) {
            return true;
          }
        }
      }
      return false;
    };
    this.hitTestBounds = (shape, bounds) => {
      if (!shape.rotation) {
        const shapeBounds = this.getBounds(shape);
        return Utils.boundsContain(bounds, shapeBounds) || (Utils.boundsContain(shapeBounds, bounds) || intersectBoundsBounds(shapeBounds, bounds).length > 0) && intersectBoundsPolyline(Utils.translateBounds(bounds, Vec.neg(shape.point)), shape.points).length > 0;
      }
      const rBounds = this.getRotatedBounds(shape);
      const rotatedBounds = Utils.getFromCache(this.rotatedCache, shape, () => {
        const c7 = Utils.getBoundsCenter(Utils.getBoundsFromPoints(shape.points));
        return shape.points.map((pt) => Vec.rotWith(pt, c7, shape.rotation || 0));
      });
      return Utils.boundsContain(bounds, rBounds) || intersectBoundsPolyline(Utils.translateBounds(bounds, Vec.neg(shape.point)), rotatedBounds).length > 0;
    };
  }
};
var Rectangle = new RectangleUtil();
var Triangle = new TriangleUtil();
var Ellipse = new EllipseUtil();
var Draw = new DrawUtil();
var Arrow6 = new ArrowUtil();
var Text = new TextUtil();
var Group2 = new GroupUtil();
var Sticky = new StickyUtil();
var shapeUtils = {
  [TDShapeType.Rectangle]: Rectangle,
  [TDShapeType.Triangle]: Triangle,
  [TDShapeType.Ellipse]: Ellipse,
  [TDShapeType.Draw]: Draw,
  [TDShapeType.Arrow]: Arrow6,
  [TDShapeType.Text]: Text,
  [TDShapeType.Group]: Group2,
  [TDShapeType.Sticky]: Sticky
};
var getShapeUtil = (shape) => {
  if (typeof shape === "string")
    return shapeUtils[shape];
  return shapeUtils[shape.type];
};
var isDev = true;
var _TLDR = class {
  static getShapeUtil(shape) {
    return getShapeUtil(shape);
  }
  static getSelectedShapes(data, pageId) {
    const page = _TLDR.getPage(data, pageId);
    const selectedIds = _TLDR.getSelectedIds(data, pageId);
    return selectedIds.map((id) => page.shapes[id]);
  }
  static screenToWorld(data, point) {
    const camera = _TLDR.getPageState(data, data.appState.currentPageId).camera;
    return Vec.sub(Vec.div(point, camera.zoom), camera.point);
  }
  static getCameraZoom(zoom) {
    return Utils.clamp(zoom, 0.1, 5);
  }
  static getPage(data, pageId) {
    return data.document.pages[pageId];
  }
  static getPageState(data, pageId) {
    return data.document.pageStates[pageId];
  }
  static getSelectedIds(data, pageId) {
    return _TLDR.getPageState(data, pageId).selectedIds;
  }
  static getShapes(data, pageId) {
    return Object.values(_TLDR.getPage(data, pageId).shapes);
  }
  static getCamera(data, pageId) {
    return _TLDR.getPageState(data, pageId).camera;
  }
  static getShape(data, shapeId, pageId) {
    return _TLDR.getPage(data, pageId).shapes[shapeId];
  }
  static getCenter(shape) {
    return _TLDR.getShapeUtil(shape).getCenter(shape);
  }
  static getBounds(shape) {
    return _TLDR.getShapeUtil(shape).getBounds(shape);
  }
  static getRotatedBounds(shape) {
    return _TLDR.getShapeUtil(shape).getRotatedBounds(shape);
  }
  static getSelectedBounds(data) {
    return Utils.getCommonBounds(_TLDR.getSelectedShapes(data, data.appState.currentPageId).map((shape) => _TLDR.getShapeUtil(shape).getBounds(shape)));
  }
  static getParentId(data, id, pageId) {
    return _TLDR.getShape(data, id, pageId).parentId;
  }
  static getDocumentBranch(data, id, pageId) {
    const shape = _TLDR.getShape(data, id, pageId);
    if (shape.children === void 0)
      return [id];
    return [
      id,
      ...shape.children.flatMap((childId) => _TLDR.getDocumentBranch(data, childId, pageId))
    ];
  }
  static getSelectedBranchSnapshot(data, pageId, fn) {
    const page = _TLDR.getPage(data, pageId);
    const copies = _TLDR.getSelectedIds(data, pageId).flatMap((id) => _TLDR.getDocumentBranch(data, id, pageId).map((id2) => page.shapes[id2])).filter((shape) => !shape.isLocked).map(Utils.deepClone);
    if (fn !== void 0) {
      return copies.map((shape) => __spreadValues4({ id: shape.id }, fn(shape)));
    }
    return copies;
  }
  static getSelectedShapeSnapshot(data, pageId, fn) {
    const copies = _TLDR.getSelectedShapes(data, pageId).filter((shape) => !shape.isLocked).map(Utils.deepClone);
    if (fn !== void 0) {
      return copies.map((shape) => __spreadValues4({ id: shape.id }, fn(shape)));
    }
    return copies;
  }
  static getAllEffectedShapeIds(data, ids, pageId) {
    const page = _TLDR.getPage(data, pageId);
    const visited = new Set(ids);
    ids.forEach((id) => {
      const shape = page.shapes[id];
      function collectDescendants(shape2) {
        if (shape2.children === void 0)
          return;
        shape2.children.filter((childId) => !visited.has(childId)).forEach((childId) => {
          visited.add(childId);
          collectDescendants(page.shapes[childId]);
        });
      }
      collectDescendants(shape);
      function collectAscendants(shape2) {
        const parentId = shape2.parentId;
        if (parentId === page.id)
          return;
        if (visited.has(parentId))
          return;
        visited.add(parentId);
        collectAscendants(page.shapes[parentId]);
      }
      collectAscendants(shape);
      visited.forEach((id2) => {
        Object.values(page.bindings).filter((binding) => binding.fromId === id2 || binding.toId === id2).forEach((binding) => visited.add(binding.fromId === id2 ? binding.toId : binding.fromId));
      });
    });
    return Array.from(visited.values());
  }
  static updateBindings(data, id, beforeShapes = {}, afterShapes = {}, pageId) {
    const page = __spreadValues4({}, _TLDR.getPage(data, pageId));
    return Object.values(page.bindings).filter((binding) => binding.fromId === id || binding.toId === id).reduce((cTDSnapshot, binding) => {
      if (!beforeShapes[binding.fromId]) {
        beforeShapes[binding.fromId] = Utils.deepClone(_TLDR.getShape(cTDSnapshot, binding.fromId, pageId));
      }
      if (!beforeShapes[binding.toId]) {
        beforeShapes[binding.toId] = Utils.deepClone(_TLDR.getShape(cTDSnapshot, binding.toId, pageId));
      }
      _TLDR.onBindingChange(_TLDR.getShape(cTDSnapshot, binding.fromId, pageId), binding, _TLDR.getShape(cTDSnapshot, binding.toId, pageId));
      afterShapes[binding.fromId] = Utils.deepClone(_TLDR.getShape(cTDSnapshot, binding.fromId, pageId));
      afterShapes[binding.toId] = Utils.deepClone(_TLDR.getShape(cTDSnapshot, binding.toId, pageId));
      return cTDSnapshot;
    }, data);
  }
  static getLinkedShapeIds(data, pageId, direction, includeArrows = true) {
    const selectedIds = _TLDR.getSelectedIds(data, pageId);
    const page = _TLDR.getPage(data, pageId);
    const linkedIds = new Set(selectedIds);
    const checkedIds = new Set();
    const idsToCheck = [...selectedIds];
    const arrows = new Set(Object.values(page.shapes).filter((shape) => {
      var _a2;
      return shape.type === TDShapeType.Arrow && (shape.handles.start.bindingId || ((_a2 = shape.handles) == null ? void 0 : _a2.end.bindingId));
    }));
    while (idsToCheck.length) {
      const id = idsToCheck.pop();
      if (!(id && arrows.size))
        break;
      if (checkedIds.has(id))
        continue;
      checkedIds.add(id);
      arrows.forEach((arrow) => {
        var _a2, _b;
        const {
          handles: {
            start: { bindingId: startBindingId },
            end: { bindingId: endBindingId }
          }
        } = arrow;
        const startBinding = startBindingId ? page.bindings[startBindingId] : null;
        const endBinding = endBindingId ? page.bindings[endBindingId] : null;
        let hit = false;
        if (startBinding && startBinding.toId === id) {
          if (direction === "center") {
            hit = true;
          } else if (((_a2 = arrow.decorations) == null ? void 0 : _a2.start) && endBinding) {
            hit = direction === "left";
          } else {
            hit = direction === "right";
          }
          if (hit) {
            if (includeArrows)
              linkedIds.add(arrow.id);
            linkedIds.add(id);
            if (endBinding) {
              linkedIds.add(endBinding.toId);
              idsToCheck.push(endBinding.toId);
            }
          }
        } else if (endBinding && endBinding.toId === id) {
          if (direction === "center") {
            hit = true;
          } else if (((_b = arrow.decorations) == null ? void 0 : _b.end) && startBinding) {
            hit = direction === "left";
          } else {
            hit = direction === "right";
          }
          if (hit) {
            if (includeArrows)
              linkedIds.add(arrow.id);
            linkedIds.add(id);
            if (startBinding) {
              linkedIds.add(startBinding.toId);
              idsToCheck.push(startBinding.toId);
            }
          }
        }
        if ((!startBinding || linkedIds.has(startBinding.toId)) && (!endBinding || linkedIds.has(endBinding.toId))) {
          arrows.delete(arrow);
        }
      });
    }
    return Array.from(linkedIds.values());
  }
  static getChildIndexAbove(data, id, pageId) {
    const page = data.document.pages[pageId];
    const shape = page.shapes[id];
    let siblings;
    if (shape.parentId === page.id) {
      siblings = Object.values(page.shapes).filter((shape2) => shape2.parentId === page.id).sort((a9, b7) => a9.childIndex - b7.childIndex);
    } else {
      const parent = page.shapes[shape.parentId];
      if (!parent.children)
        throw Error("No children in parent!");
      siblings = parent.children.map((childId) => page.shapes[childId]).sort((a9, b7) => a9.childIndex - b7.childIndex);
    }
    const index2 = siblings.indexOf(shape);
    const nextSibling = siblings[index2 + 1];
    if (!nextSibling)
      return shape.childIndex + 1;
    return nextSibling.childIndex;
  }
  static getBeforeShape(shape, change) {
    return Object.fromEntries(Object.keys(change).map((k3) => [k3, shape[k3]]));
  }
  static mutateShapes(data, ids, fn, pageId) {
    const beforeShapes = {};
    const afterShapes = {};
    ids.forEach((id, i8) => {
      const shape = _TLDR.getShape(data, id, pageId);
      if (shape.isLocked)
        return;
      const change = fn(shape, i8);
      if (change) {
        beforeShapes[id] = _TLDR.getBeforeShape(shape, change);
        afterShapes[id] = change;
      }
    });
    const dataWithMutations = Utils.deepMerge(data, {
      document: {
        pages: {
          [data.appState.currentPageId]: {
            shapes: afterShapes
          }
        }
      }
    });
    const dataWithBindingChanges = ids.reduce((cTDSnapshot, id) => {
      return _TLDR.updateBindings(cTDSnapshot, id, beforeShapes, afterShapes, pageId);
    }, dataWithMutations);
    return {
      before: beforeShapes,
      after: afterShapes,
      data: dataWithBindingChanges
    };
  }
  static createShapes(data, shapes, pageId) {
    const before = {
      document: {
        pages: {
          [pageId]: {
            shapes: __spreadValues4({}, Object.fromEntries(shapes.flatMap((shape) => {
              const results = [[shape.id, void 0]];
              if (shape.parentId !== pageId) {
                const parent = _TLDR.getShape(data, shape.parentId, pageId);
                if (!parent.children)
                  throw Error("No children in parent!");
                results.push([parent.id, { children: parent.children }]);
              }
              return results;
            })))
          }
        }
      }
    };
    const after = {
      document: {
        pages: {
          [pageId]: {
            shapes: {
              shapes: __spreadValues4({}, Object.fromEntries(shapes.flatMap((shape) => {
                const results = [[shape.id, shape]];
                if (shape.parentId !== pageId) {
                  const parent = _TLDR.getShape(data, shape.parentId, pageId);
                  if (!parent.children)
                    throw Error("No children in parent!");
                  results.push([parent.id, { children: [...parent.children, shape.id] }]);
                }
                return results;
              })))
            }
          }
        }
      }
    };
    return {
      before,
      after
    };
  }
  static deleteShapes(data, shapes, pageId) {
    pageId = pageId ? pageId : data.appState.currentPageId;
    const page = _TLDR.getPage(data, pageId);
    const shapeIds = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    const before = {
      document: {
        pages: {
          [pageId]: {
            shapes: __spreadValues4({}, Object.fromEntries(shapeIds.flatMap((id) => {
              const shape = page.shapes[id];
              const results = [[shape.id, shape]];
              if (shape.parentId !== pageId) {
                const parent = page.shapes[shape.parentId];
                if (!parent.children)
                  throw Error("No children in parent!");
                results.push([parent.id, { children: parent.children }]);
              }
              return results;
            }))),
            bindings: __spreadValues4({}, Object.fromEntries(Object.values(page.bindings).filter((binding) => {
              return shapeIds.includes(binding.fromId) || shapeIds.includes(binding.toId);
            }).map((binding) => {
              return [binding.id, binding];
            })))
          }
        }
      }
    };
    const after = {
      document: {
        pages: {
          [pageId]: {
            shapes: __spreadValues4({}, Object.fromEntries(shapeIds.flatMap((id) => {
              const shape = page.shapes[id];
              const results = [[shape.id, void 0]];
              if (shape.parentId !== page.id) {
                const parent = page.shapes[shape.parentId];
                if (!parent.children)
                  throw Error("No children in parent!");
                results.push([
                  parent.id,
                  { children: parent.children.filter((id2) => id2 !== shape.id) }
                ]);
              }
              return results;
            })))
          }
        }
      }
    };
    return {
      before,
      after
    };
  }
  static onSessionComplete(shape) {
    var _a2, _b;
    const delta = (_b = (_a2 = _TLDR.getShapeUtil(shape)).onSessionComplete) == null ? void 0 : _b.call(_a2, shape);
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static onChildrenChange(data, shape, pageId) {
    var _a2, _b;
    if (!shape.children)
      return;
    const delta = (_b = (_a2 = _TLDR.getShapeUtil(shape)).onChildrenChange) == null ? void 0 : _b.call(_a2, shape, shape.children.map((id) => _TLDR.getShape(data, id, pageId)));
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static onBindingChange(shape, binding, otherShape) {
    var _a2, _b;
    const delta = (_b = (_a2 = _TLDR.getShapeUtil(shape)).onBindingChange) == null ? void 0 : _b.call(_a2, shape, binding, otherShape, _TLDR.getShapeUtil(otherShape).getBounds(otherShape), _TLDR.getShapeUtil(otherShape).getExpandedBounds(otherShape), _TLDR.getShapeUtil(otherShape).getCenter(otherShape));
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static transform(shape, bounds, info) {
    const delta = _TLDR.getShapeUtil(shape).transform(shape, bounds, info);
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static transformSingle(shape, bounds, info) {
    const delta = _TLDR.getShapeUtil(shape).transformSingle(shape, bounds, info);
    if (!delta)
      return shape;
    return __spreadValues4(__spreadValues4({}, shape), delta);
  }
  static getRotatedShapeMutation(shape, center, origin, delta) {
    var _a2, _b;
    const relativeCenter = Vec.sub(center, shape.point);
    const rotatedCenter = Vec.rotWith(center, origin, delta);
    const nextPoint = Vec.toFixed(Vec.sub(rotatedCenter, relativeCenter));
    if (shape.handles !== void 0) {
      const change = (_b = (_a2 = this.getShapeUtil(shape)).onHandleChange) == null ? void 0 : _b.call(_a2, __spreadProps4(__spreadValues4({}, shape), { point: nextPoint }), Object.fromEntries(Object.entries(shape.handles).map(([handleId, handle]) => {
        const point = Vec.toFixed(Vec.rotWith(handle.point, relativeCenter, delta));
        return [handleId, __spreadProps4(__spreadValues4({}, handle), { point })];
      })), { shiftKey: false });
      return change;
    }
    const nextRotation = Utils.clampRadians((shape.rotation || 0) + delta);
    return {
      point: nextPoint,
      rotation: nextRotation
    };
  }
  static updateParents(data, pageId, changedShapeIds) {
    const page = _TLDR.getPage(data, pageId);
    if (changedShapeIds.length === 0)
      return;
    const { shapes } = _TLDR.getPage(data, pageId);
    const parentToUpdateIds = Array.from(new Set(changedShapeIds.map((id) => shapes[id].parentId).values())).filter((id) => id !== page.id);
    for (const parentId of parentToUpdateIds) {
      const parent = shapes[parentId];
      if (!parent.children) {
        throw Error("A shape is parented to a shape without a children array.");
      }
      _TLDR.onChildrenChange(data, parent, pageId);
    }
    _TLDR.updateParents(data, pageId, parentToUpdateIds);
  }
  static getBinding(data, id, pageId) {
    return _TLDR.getPage(data, pageId).bindings[id];
  }
  static getBindings(data, pageId) {
    const page = _TLDR.getPage(data, pageId);
    return Object.values(page.bindings);
  }
  static getBindableShapeIds(data) {
    return _TLDR.getShapes(data, data.appState.currentPageId).filter((shape) => _TLDR.getShapeUtil(shape).canBind).sort((a9, b7) => b7.childIndex - a9.childIndex).map((shape) => shape.id);
  }
  static getBindingsWithShapeIds(data, ids, pageId) {
    return Array.from(new Set(_TLDR.getBindings(data, pageId).filter((binding) => {
      return ids.includes(binding.toId) || ids.includes(binding.fromId);
    })).values());
  }
  static getRelatedBindings(data, ids, pageId) {
    const changedShapeIds = new Set(ids);
    const page = _TLDR.getPage(data, pageId);
    const bindingsArr = Object.values(page.bindings);
    const bindingsToUpdate = new Set(bindingsArr.filter((binding) => changedShapeIds.has(binding.toId) || changedShapeIds.has(binding.fromId)));
    let prevSize = bindingsToUpdate.size;
    let delta = -1;
    while (delta !== 0) {
      bindingsToUpdate.forEach((binding) => {
        const fromId = binding.fromId;
        for (const otherBinding of bindingsArr) {
          if (otherBinding.fromId === fromId) {
            bindingsToUpdate.add(otherBinding);
          }
          if (otherBinding.toId === fromId) {
            bindingsToUpdate.add(otherBinding);
          }
        }
      });
      delta = bindingsToUpdate.size - prevSize;
      prevSize = bindingsToUpdate.size;
    }
    return Array.from(bindingsToUpdate.values());
  }
  static normalizeText(text) {
    return text.replace(_TLDR.fixNewLines, "\n");
  }
  static assertShapeHasProperty(shape, prop) {
    if (shape[prop] === void 0) {
      throw new Error();
    }
  }
  static warn(e12) {
    if (isDev) {
      console.warn(e12);
    }
  }
  static error(e12) {
    if (isDev) {
      console.error(e12);
    }
  }
};
var TLDR = _TLDR;
TLDR.copyStringToClipboard = (string) => {
  try {
    navigator.clipboard.writeText(string);
  } catch (e12) {
    const textarea = document.createElement("textarea");
    textarea.setAttribute("position", "fixed");
    textarea.setAttribute("top", "0");
    textarea.setAttribute("readonly", "true");
    textarea.setAttribute("contenteditable", "true");
    textarea.style.position = "fixed";
    textarea.value = string;
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    try {
      const range = document.createRange();
      range.selectNodeContents(textarea);
      const sel = window.getSelection();
      if (sel) {
        sel.removeAllRanges();
        sel.addRange(range);
        textarea.setSelectionRange(0, textarea.value.length);
      }
    } catch (err) {
      null;
    } finally {
      document.body.removeChild(textarea);
    }
  }
};
TLDR.flattenShape = (data, shape) => {
  var _a2;
  return [
    shape,
    ...((_a2 = shape.children) != null ? _a2 : []).map((childId) => _TLDR.getShape(data, childId, data.appState.currentPageId)).sort((a9, b7) => a9.childIndex - b7.childIndex).flatMap((shape2) => _TLDR.flattenShape(data, shape2))
  ];
};
TLDR.flattenPage = (data, pageId) => {
  return Object.values(data.document.pages[pageId].shapes).sort((a9, b7) => a9.childIndex - b7.childIndex).reduce((acc, shape) => [...acc, ..._TLDR.flattenShape(data, shape)], []);
};
TLDR.getTopChildIndex = (data, pageId) => {
  const shapes = _TLDR.getShapes(data, pageId);
  return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === pageId).sort((a9, b7) => b7.childIndex - a9.childIndex)[0].childIndex + 1;
};
TLDR.fixNewLines = /\r?\n|\r/g;
function alignShapes(app, ids, type) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const boundsForShapes = initialShapes.map((shape) => {
    return {
      id: shape.id,
      point: [...shape.point],
      bounds: TLDR.getBounds(shape)
    };
  });
  const commonBounds = Utils.getCommonBounds(boundsForShapes.map(({ bounds }) => bounds));
  const midX = commonBounds.minX + commonBounds.width / 2;
  const midY = commonBounds.minY + commonBounds.height / 2;
  const deltaMap = Object.fromEntries(boundsForShapes.map(({ id, point, bounds }) => {
    return [
      id,
      {
        prev: point,
        next: {
          [AlignType.CenterVertical]: [point[0], midY - bounds.height / 2],
          [AlignType.CenterHorizontal]: [midX - bounds.width / 2, point[1]],
          [AlignType.Top]: [point[0], commonBounds.minY],
          [AlignType.Bottom]: [point[0], commonBounds.maxY - bounds.height],
          [AlignType.Left]: [commonBounds.minX, point[1]],
          [AlignType.Right]: [commonBounds.maxX - bounds.width, point[1]]
        }[type]
      }
    ];
  }));
  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => {
    if (!deltaMap[shape.id])
      return shape;
    return { point: deltaMap[shape.id].next };
  }, currentPageId);
  initialShapes.forEach((shape) => {
    if (shape.type === TDShapeType.Group) {
      const delta = Vec.sub(after[shape.id].point, before[shape.id].point);
      shape.children.forEach((id) => {
        const child = app.getShape(id);
        before[child.id] = { point: child.point };
        after[child.id] = { point: Vec.add(child.point, delta) };
      });
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "align",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function changePage(app, pageId) {
  return {
    id: "change_page",
    before: {
      appState: {
        currentPageId: app.currentPageId
      }
    },
    after: {
      appState: {
        currentPageId: pageId
      }
    }
  };
}
function createPage(app, center, pageId = Utils.uniqueId()) {
  const { currentPageId } = app;
  const topPage = Object.values(app.state.document.pages).sort((a9, b7) => (b7.childIndex || 0) - (a9.childIndex || 0))[0];
  const nextChildIndex = (topPage == null ? void 0 : topPage.childIndex) ? (topPage == null ? void 0 : topPage.childIndex) + 1 : 1;
  const nextName = `New Page`;
  const page = {
    id: pageId,
    name: nextName,
    childIndex: nextChildIndex,
    shapes: {},
    bindings: {}
  };
  const pageState = {
    id: pageId,
    selectedIds: [],
    camera: { point: center, zoom: 1 },
    editingId: void 0,
    bindingId: void 0,
    hoveredId: void 0,
    pointedId: void 0
  };
  return {
    id: "create_page",
    before: {
      appState: {
        currentPageId
      },
      document: {
        pages: {
          [pageId]: void 0
        },
        pageStates: {
          [pageId]: void 0
        }
      }
    },
    after: {
      appState: {
        currentPageId: page.id
      },
      document: {
        pages: {
          [pageId]: page
        },
        pageStates: {
          [pageId]: pageState
        }
      }
    }
  };
}
function createShapes(app, shapes, bindings = []) {
  const { currentPageId } = app;
  const beforeShapes = {};
  const afterShapes = {};
  shapes.forEach((shape) => {
    beforeShapes[shape.id] = void 0;
    afterShapes[shape.id] = shape;
  });
  const beforeBindings = {};
  const afterBindings = {};
  bindings.forEach((binding) => {
    beforeBindings[binding.id] = void 0;
    afterBindings[binding.id] = binding;
  });
  return {
    id: "create",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: [...app.selectedIds]
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: afterShapes,
            bindings: afterBindings
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: shapes.map((shape) => shape.id)
          }
        }
      }
    }
  };
}
function deletePage(app, pageId) {
  const {
    currentPageId,
    document: { pages, pageStates }
  } = app;
  const pagesArr = Object.values(pages).sort((a9, b7) => (a9.childIndex || 0) - (b7.childIndex || 0));
  const currentIndex = pagesArr.findIndex((page) => page.id === pageId);
  let nextCurrentPageId;
  if (pageId === currentPageId) {
    if (currentIndex === pagesArr.length - 1) {
      nextCurrentPageId = pagesArr[pagesArr.length - 2].id;
    } else {
      nextCurrentPageId = pagesArr[currentIndex + 1].id;
    }
  } else {
    nextCurrentPageId = currentPageId;
  }
  return {
    id: "delete_page",
    before: {
      appState: {
        currentPageId: pageId
      },
      document: {
        pages: {
          [pageId]: __spreadValues4({}, pages[pageId])
        },
        pageStates: {
          [pageId]: __spreadValues4({}, pageStates[pageId])
        }
      }
    },
    after: {
      appState: {
        currentPageId: nextCurrentPageId
      },
      document: {
        pages: {
          [pageId]: void 0
        },
        pageStates: {
          [pageId]: void 0
        }
      }
    }
  };
}
function removeShapesFromPage(data, ids, pageId) {
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const parentsToUpdate = [];
  const deletedIds = new Set();
  ids.filter((id) => !TLDR.getShape(data, id, pageId).isLocked).forEach((id) => {
    deletedIds.add(id);
    const shape = TLDR.getShape(data, id, pageId);
    before.shapes[id] = shape;
    after.shapes[id] = void 0;
    if (shape.children !== void 0) {
      shape.children.forEach((childId) => {
        deletedIds.add(childId);
        const child = TLDR.getShape(data, childId, pageId);
        before.shapes[childId] = child;
        after.shapes[childId] = void 0;
      });
    }
    if (shape.parentId !== pageId) {
      parentsToUpdate.push(TLDR.getShape(data, shape.parentId, pageId));
    }
  });
  parentsToUpdate.forEach((parent) => {
    var _a2;
    if (ids.includes(parent.id))
      return;
    deletedIds.add(parent.id);
    before.shapes[parent.id] = { children: parent.children };
    after.shapes[parent.id] = { children: parent.children.filter((id) => !ids.includes(id)) };
    if (((_a2 = after.shapes[parent.id]) == null ? void 0 : _a2.children.length) === 0) {
      after.shapes[parent.id] = void 0;
      before.shapes[parent.id] = TLDR.getShape(data, parent.id, pageId);
    }
  });
  const page = TLDR.getPage(data, pageId);
  Object.values(page.bindings).filter((binding) => deletedIds.has(binding.fromId) || deletedIds.has(binding.toId)).forEach((binding) => {
    for (const id of [binding.toId, binding.fromId]) {
      if (after.shapes[id] === void 0) {
        before.bindings[binding.id] = binding;
        after.bindings[binding.id] = void 0;
        const shape = page.shapes[id];
        if (shape && shape.handles) {
          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
            var _a2, _b, _c, _d, _e, _f;
            before.shapes[id] = __spreadProps4(__spreadValues4({}, before.shapes[id]), {
              handles: __spreadProps4(__spreadValues4({}, (_a2 = before.shapes[id]) == null ? void 0 : _a2.handles), {
                [handle.id]: __spreadProps4(__spreadValues4({}, (_c = (_b = before.shapes[id]) == null ? void 0 : _b.handles) == null ? void 0 : _c[handle.id]), {
                  bindingId: binding.id
                })
              })
            });
            if (!deletedIds.has(id)) {
              after.shapes[id] = __spreadProps4(__spreadValues4({}, after.shapes[id]), {
                handles: __spreadProps4(__spreadValues4({}, (_d = after.shapes[id]) == null ? void 0 : _d.handles), {
                  [handle.id]: __spreadProps4(__spreadValues4({}, (_f = (_e = after.shapes[id]) == null ? void 0 : _e.handles) == null ? void 0 : _f[handle.id]), {
                    bindingId: void 0
                  })
                })
              });
            }
          });
        }
      }
    }
  });
  return { before, after };
}
function deleteShapes(app, ids, pageId = app.currentPageId) {
  const { pageState, selectedIds } = app;
  const { before, after } = removeShapesFromPage(app.state, ids, pageId);
  return {
    id: "delete",
    before: {
      document: {
        pages: {
          [pageId]: before
        },
        pageStates: {
          [pageId]: { selectedIds: [...app.selectedIds] }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: after
        },
        pageStates: {
          [pageId]: {
            selectedIds: selectedIds.filter((id) => !ids.includes(id)),
            hoveredId: pageState.hoveredId && ids.includes(pageState.hoveredId) ? void 0 : pageState.hoveredId
          }
        }
      }
    }
  };
}
function distributeShapes(app, ids, type) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const deltaMap = Object.fromEntries(getDistributions(initialShapes, type).map((d8) => [d8.id, d8]));
  const { before, after } = TLDR.mutateShapes(app.state, ids.filter((id) => deltaMap[id] !== void 0), (shape) => ({ point: deltaMap[shape.id].next }), currentPageId);
  initialShapes.forEach((shape) => {
    if (shape.type === TDShapeType.Group) {
      const delta = src_default.sub(after[shape.id].point, before[shape.id].point);
      shape.children.forEach((id) => {
        const child = app.getShape(id);
        before[child.id] = { point: child.point };
        after[child.id] = { point: src_default.add(child.point, delta) };
      });
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "distribute",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function getDistributions(initialShapes, type) {
  const entries = initialShapes.map((shape) => {
    const utils = TLDR.getShapeUtil(shape);
    return {
      id: shape.id,
      point: [...shape.point],
      bounds: utils.getBounds(shape),
      center: utils.getCenter(shape)
    };
  });
  const len = entries.length;
  const commonBounds = Utils.getCommonBounds(entries.map(({ bounds }) => bounds));
  const results = [];
  switch (type) {
    case DistributeType.Horizontal: {
      const span = entries.reduce((a9, c7) => a9 + c7.bounds.width, 0);
      if (span > commonBounds.width) {
        const left = entries.sort((a9, b7) => a9.bounds.minX - b7.bounds.minX)[0];
        const right = entries.sort((a9, b7) => b7.bounds.maxX - a9.bounds.maxX)[0];
        const entriesToMove = entries.filter((a9) => a9 !== left && a9 !== right).sort((a9, b7) => a9.center[0] - b7.center[0]);
        const step = (right.center[0] - left.center[0]) / (len - 1);
        const x5 = left.center[0] + step;
        entriesToMove.forEach(({ id, point, bounds }, i8) => {
          results.push({
            id,
            prev: point,
            next: [x5 + step * i8 - bounds.width / 2, bounds.minY]
          });
        });
      } else {
        const entriesToMove = entries.sort((a9, b7) => a9.center[0] - b7.center[0]);
        let x5 = commonBounds.minX;
        const step = (commonBounds.width - span) / (len - 1);
        entriesToMove.forEach(({ id, point, bounds }) => {
          results.push({ id, prev: point, next: [x5, bounds.minY] });
          x5 += bounds.width + step;
        });
      }
      break;
    }
    case DistributeType.Vertical: {
      const span = entries.reduce((a9, c7) => a9 + c7.bounds.height, 0);
      if (span > commonBounds.height) {
        const top2 = entries.sort((a9, b7) => a9.bounds.minY - b7.bounds.minY)[0];
        const bottom = entries.sort((a9, b7) => b7.bounds.maxY - a9.bounds.maxY)[0];
        const entriesToMove = entries.filter((a9) => a9 !== top2 && a9 !== bottom).sort((a9, b7) => a9.center[1] - b7.center[1]);
        const step = (bottom.center[1] - top2.center[1]) / (len - 1);
        const y4 = top2.center[1] + step;
        entriesToMove.forEach(({ id, point, bounds }, i8) => {
          results.push({
            id,
            prev: point,
            next: [bounds.minX, y4 + step * i8 - bounds.height / 2]
          });
        });
      } else {
        const entriesToMove = entries.sort((a9, b7) => a9.center[1] - b7.center[1]);
        let y4 = commonBounds.minY;
        const step = (commonBounds.height - span) / (len - 1);
        entriesToMove.forEach(({ id, point, bounds }) => {
          results.push({ id, prev: point, next: [bounds.minX, y4] });
          y4 += bounds.height + step;
        });
      }
      break;
    }
  }
  return results;
}
function duplicatePage(app, pageId) {
  const newId = Utils.uniqueId();
  const {
    currentPageId,
    page,
    pageState: { camera }
  } = app;
  const nextPage = __spreadProps4(__spreadValues4({}, page), {
    id: newId,
    name: page.name + " Copy",
    shapes: Object.fromEntries(Object.entries(page.shapes).map(([id, shape]) => {
      return [
        id,
        __spreadProps4(__spreadValues4({}, shape), {
          parentId: shape.parentId === pageId ? newId : shape.parentId
        })
      ];
    }))
  });
  return {
    id: "duplicate_page",
    before: {
      appState: {
        currentPageId
      },
      document: {
        pages: {
          [newId]: void 0
        },
        pageStates: {
          [newId]: void 0
        }
      }
    },
    after: {
      appState: {
        currentPageId: newId
      },
      document: {
        pages: {
          [newId]: nextPage
        },
        pageStates: {
          [newId]: __spreadProps4(__spreadValues4({}, page), {
            id: newId,
            selectedIds: [],
            camera: __spreadValues4({}, camera),
            editingId: void 0,
            bindingId: void 0,
            hoveredId: void 0,
            pointedId: void 0
          })
        }
      }
    }
  };
}
function duplicateShapes(app, ids, point) {
  const { selectedIds, currentPageId, page, shapes } = app;
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const duplicateMap = {};
  const shapesToDuplicate = ids.map((id) => app.getShape(id)).filter((shape) => !ids.includes(shape.parentId));
  shapesToDuplicate.forEach((shape) => {
    const duplicatedId = Utils.uniqueId();
    before.shapes[duplicatedId] = void 0;
    after.shapes[duplicatedId] = __spreadProps4(__spreadValues4({}, Utils.deepClone(shape)), {
      id: duplicatedId,
      childIndex: TLDR.getChildIndexAbove(app.state, shape.id, currentPageId)
    });
    if (shape.children) {
      after.shapes[duplicatedId].children = [];
    }
    if (shape.parentId !== currentPageId) {
      const parent = app.getShape(shape.parentId);
      before.shapes[parent.id] = __spreadProps4(__spreadValues4({}, before.shapes[parent.id]), {
        children: parent.children
      });
      after.shapes[parent.id] = __spreadProps4(__spreadValues4({}, after.shapes[parent.id]), {
        children: [...(after.shapes[parent.id] || parent).children, duplicatedId]
      });
    }
    duplicateMap[shape.id] = duplicatedId;
  });
  shapesToDuplicate.forEach((shape) => {
    if (shape.children) {
      shape.children.forEach((childId) => {
        var _a2, _b;
        const child = app.getShape(childId);
        const duplicatedId = Utils.uniqueId();
        const duplicatedParentId = duplicateMap[shape.id];
        before.shapes[duplicatedId] = void 0;
        after.shapes[duplicatedId] = __spreadProps4(__spreadValues4({}, Utils.deepClone(child)), {
          id: duplicatedId,
          parentId: duplicatedParentId,
          childIndex: TLDR.getChildIndexAbove(app.state, child.id, currentPageId)
        });
        duplicateMap[childId] = duplicatedId;
        (_b = (_a2 = after.shapes[duplicateMap[shape.id]]) == null ? void 0 : _a2.children) == null ? void 0 : _b.push(duplicatedId);
      });
    }
  });
  const dupedShapeIds = new Set(Object.keys(duplicateMap));
  Object.values(page.bindings).filter((binding) => dupedShapeIds.has(binding.fromId) || dupedShapeIds.has(binding.toId)).forEach((binding) => {
    if (dupedShapeIds.has(binding.fromId)) {
      if (dupedShapeIds.has(binding.toId)) {
        const duplicatedBindingId = Utils.uniqueId();
        const duplicatedBinding = __spreadProps4(__spreadValues4({}, Utils.deepClone(binding)), {
          id: duplicatedBindingId,
          fromId: duplicateMap[binding.fromId],
          toId: duplicateMap[binding.toId]
        });
        before.bindings[duplicatedBindingId] = void 0;
        after.bindings[duplicatedBindingId] = duplicatedBinding;
        const boundShape = after.shapes[duplicatedBinding.fromId];
        Object.values(boundShape.handles).forEach((handle) => {
          if (handle.bindingId === binding.id) {
            handle.bindingId = duplicatedBindingId;
          }
        });
      } else {
        const boundShape = after.shapes[duplicateMap[binding.fromId]];
        Object.values(boundShape.handles).forEach((handle) => {
          if (handle.bindingId === binding.id) {
            handle.bindingId = void 0;
          }
        });
      }
    }
  });
  const shapesToMove = Object.values(after.shapes);
  if (point) {
    const commonBounds = Utils.getCommonBounds(shapesToMove.map((shape) => TLDR.getBounds(shape)));
    const center = Utils.getBoundsCenter(commonBounds);
    shapesToMove.forEach((shape) => {
      if (!shape.point)
        return;
      shape.point = Vec.sub(point, Vec.sub(center, shape.point));
    });
  } else {
    const offset = [16, 16];
    shapesToMove.forEach((shape) => {
      if (!shape.point)
        return;
      shape.point = Vec.add(shape.point, offset);
    });
  }
  shapesToMove.forEach((shape) => {
    if (shape.isLocked) {
      shape.isLocked = false;
    }
  });
  return {
    id: "duplicate",
    before: {
      document: {
        pages: {
          [currentPageId]: before
        },
        pageStates: {
          [currentPageId]: { selectedIds }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: after
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: Array.from(dupedShapeIds.values()).map((id) => duplicateMap[id])
          }
        }
      }
    }
  };
}
function flipShapes(app, ids, type) {
  const { selectedIds, currentPageId, shapes } = app;
  const boundsForShapes = shapes.map((shape) => TLDR.getBounds(shape));
  const commonBounds = Utils.getCommonBounds(boundsForShapes);
  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => {
    const shapeBounds = TLDR.getBounds(shape);
    switch (type) {
      case FlipType.Horizontal: {
        const newShapeBounds = Utils.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, true, false);
        return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {
          type: TLBoundsCorner.TopLeft,
          scaleX: -1,
          scaleY: 1,
          initialShape: shape,
          transformOrigin: [0.5, 0.5]
        });
      }
      case FlipType.Vertical: {
        const newShapeBounds = Utils.getRelativeTransformedBoundingBox(commonBounds, commonBounds, shapeBounds, false, true);
        return TLDR.getShapeUtil(shape).transform(shape, newShapeBounds, {
          type: TLBoundsCorner.TopLeft,
          scaleX: 1,
          scaleY: -1,
          initialShape: shape,
          transformOrigin: [0.5, 0.5]
        });
      }
    }
  }, currentPageId);
  return {
    id: "flip",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function groupShapes(app, ids, groupId, pageId) {
  var _a2, _b;
  const beforeShapes = {};
  const afterShapes = {};
  const beforeBindings = {};
  const afterBindings = {};
  const idsToGroup = [...ids];
  const shapesToGroup = [];
  const deletedGroupIds = [];
  const otherEffectedGroups = [];
  for (const id of ids) {
    const shape = app.getShape(id);
    if (shape.isLocked)
      continue;
    if (shape.children === void 0) {
      shapesToGroup.push(shape);
    } else {
      const childIds = shape.children.filter((id2) => !app.getShape(id2).isLocked);
      otherEffectedGroups.push(shape);
      idsToGroup.push(...childIds);
      shapesToGroup.push(...childIds.map((id2) => app.getShape(id2)));
    }
  }
  if (shapesToGroup.every((shape) => shape.parentId === shapesToGroup[0].parentId)) {
    if (shapesToGroup[0].parentId !== pageId) {
      const commonParent = app.getShape(shapesToGroup[0].parentId);
      if (((_a2 = commonParent.children) == null ? void 0 : _a2.length) === idsToGroup.length) {
        return;
      }
    }
  }
  const flattenedShapes = TLDR.flattenPage(app.state, pageId);
  const shapeIndexMap = Object.fromEntries(shapesToGroup.map((shape) => [shape.id, flattenedShapes.indexOf(shape)]));
  const sortedShapes = shapesToGroup.sort((a9, b7) => shapeIndexMap[a9.id] - shapeIndexMap[b7.id]);
  const groupParentId = pageId;
  const groupChildIndex = (sortedShapes.filter((shape) => shape.parentId === pageId)[0] || sortedShapes[0]).childIndex;
  const groupBounds = Utils.getCommonBounds(shapesToGroup.map((shape) => TLDR.getBounds(shape)));
  beforeShapes[groupId] = void 0;
  afterShapes[groupId] = TLDR.getShapeUtil(TDShapeType.Group).create({
    id: groupId,
    childIndex: groupChildIndex,
    parentId: groupParentId,
    point: [groupBounds.minX, groupBounds.minY],
    size: [groupBounds.width, groupBounds.height],
    children: sortedShapes.map((shape) => shape.id)
  });
  sortedShapes.forEach((shape, index2) => {
    if (shape.parentId !== pageId) {
      const parentShape = app.getShape(shape.parentId);
      otherEffectedGroups.push(parentShape);
    }
    beforeShapes[shape.id] = __spreadProps4(__spreadValues4({}, beforeShapes[shape.id]), {
      parentId: shape.parentId,
      childIndex: shape.childIndex
    });
    afterShapes[shape.id] = __spreadProps4(__spreadValues4({}, afterShapes[shape.id]), {
      parentId: groupId,
      childIndex: index2 + 1
    });
  });
  while (otherEffectedGroups.length > 0) {
    const shape = otherEffectedGroups.pop();
    if (!shape)
      break;
    const nextChildren = (((_b = beforeShapes[shape.id]) == null ? void 0 : _b.children) || shape.children).filter((childId) => childId && !(idsToGroup.includes(childId) || deletedGroupIds.includes(childId)));
    if (nextChildren.length === 0) {
      beforeShapes[shape.id] = shape;
      afterShapes[shape.id] = void 0;
      if (shape.parentId !== pageId) {
        deletedGroupIds.push(shape.id);
        otherEffectedGroups.push(app.getShape(shape.parentId));
      }
    } else {
      beforeShapes[shape.id] = __spreadProps4(__spreadValues4({}, beforeShapes[shape.id]), {
        children: shape.children
      });
      afterShapes[shape.id] = __spreadProps4(__spreadValues4({}, afterShapes[shape.id]), {
        children: nextChildren
      });
    }
  }
  const { bindings } = app;
  bindings.forEach((binding) => {
    for (const id of [binding.toId, binding.fromId]) {
      if (afterShapes[id] === void 0) {
        beforeBindings[binding.id] = binding;
        afterBindings[binding.id] = void 0;
        const shape = app.getShape(id);
        if (shape.handles) {
          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
            var _a22, _b2;
            beforeShapes[id] = __spreadProps4(__spreadValues4({}, beforeShapes[id]), {
              handles: __spreadProps4(__spreadValues4({}, (_a22 = beforeShapes[id]) == null ? void 0 : _a22.handles), {
                [handle.id]: { bindingId: binding.id }
              })
            });
            if (!deletedGroupIds.includes(id)) {
              afterShapes[id] = __spreadProps4(__spreadValues4({}, afterShapes[id]), {
                handles: __spreadProps4(__spreadValues4({}, (_b2 = afterShapes[id]) == null ? void 0 : _b2.handles), {
                  [handle.id]: { bindingId: void 0 }
                })
              });
            }
          });
        }
      }
    }
  });
  return {
    id: "group",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: afterShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: [groupId]
          }
        }
      }
    }
  };
}
function moveShapesToPage(app, ids, viewportBounds, fromPageId, toPageId) {
  const { page } = app;
  const fromPage = {
    before: {
      shapes: {},
      bindings: {}
    },
    after: {
      shapes: {},
      bindings: {}
    }
  };
  const toPage = {
    before: {
      shapes: {},
      bindings: {}
    },
    after: {
      shapes: {},
      bindings: {}
    }
  };
  const movingShapeIds = new Set();
  const shapesToMove = new Set();
  ids.map((id) => app.getShape(id, fromPageId)).filter((shape) => !shape.isLocked).forEach((shape) => {
    movingShapeIds.add(shape.id);
    shapesToMove.add(shape);
    if (shape.children !== void 0) {
      shape.children.forEach((childId) => {
        movingShapeIds.add(childId);
        shapesToMove.add(app.getShape(childId, fromPageId));
      });
    }
  });
  const startingChildIndex = TLDR.getTopChildIndex(app.state, toPageId);
  const movingShapes = Array.from(shapesToMove.values());
  movingShapes.forEach((shape, i8) => {
    fromPage.before.shapes[shape.id] = shape;
    fromPage.after.shapes[shape.id] = void 0;
    toPage.before.shapes[shape.id] = void 0;
    toPage.after.shapes[shape.id] = shape;
    if (!movingShapeIds.has(shape.parentId)) {
      toPage.after.shapes[shape.id] = __spreadProps4(__spreadValues4({}, shape), {
        parentId: toPageId,
        childIndex: startingChildIndex + i8
      });
      if (shape.parentId !== fromPageId) {
        const parent = app.getShape(shape.parentId, fromPageId);
        fromPage.before.shapes[parent.id] = {
          children: parent.children
        };
        fromPage.after.shapes[parent.id] = {
          children: parent.children.filter((childId) => childId !== shape.id)
        };
      }
    }
  });
  Object.values(page.bindings).filter((binding) => movingShapeIds.has(binding.fromId) || movingShapeIds.has(binding.toId)).forEach((binding) => {
    fromPage.before.bindings[binding.id] = binding;
    fromPage.after.bindings[binding.id] = void 0;
    const fromBoundShape = app.getShape(binding.fromId, fromPageId);
    const shouldCopy = movingShapeIds.has(binding.fromId) && movingShapeIds.has(binding.toId);
    if (shouldCopy) {
      toPage.before.bindings[binding.id] = void 0;
      toPage.after.bindings[binding.id] = binding;
    } else {
      if (movingShapeIds.has(binding.fromId)) {
        const fromShape = app.getShape(binding.fromId, fromPageId);
        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);
        const handleId = handle.id;
        const toPageShape = toPage.after.shapes[fromShape.id];
        toPageShape.handles = __spreadProps4(__spreadValues4({}, toPageShape.handles), {
          [handleId]: __spreadProps4(__spreadValues4({}, toPageShape.handles[handleId]), {
            bindingId: void 0
          })
        });
      } else {
        const fromShape = app.getShape(binding.fromId, fromPageId);
        const handle = Object.values(fromBoundShape.handles).find((handle2) => handle2.bindingId === binding.id);
        fromPage.before.shapes[fromShape.id] = {
          handles: { [handle.id]: { bindingId: binding.id } }
        };
        fromPage.after.shapes[fromShape.id] = {
          handles: { [handle.id]: { bindingId: void 0 } }
        };
      }
    }
  });
  const toPageState = app.state.document.pageStates[toPageId];
  const bounds = Utils.getCommonBounds(movingShapes.map((shape) => TLDR.getBounds(shape)));
  const zoom = TLDR.getCameraZoom(viewportBounds.width < viewportBounds.height ? (viewportBounds.width - 128) / bounds.width : (viewportBounds.height - 128) / bounds.height);
  const mx = (viewportBounds.width - bounds.width * zoom) / 2 / zoom;
  const my = (viewportBounds.height - bounds.height * zoom) / 2 / zoom;
  const point = Vec.toFixed(Vec.add([-bounds.minX, -bounds.minY], [mx, my]));
  return {
    id: "move_to_page",
    before: {
      appState: {
        currentPageId: fromPageId
      },
      document: {
        pages: {
          [fromPageId]: fromPage.before,
          [toPageId]: toPage.before
        },
        pageStates: {
          [fromPageId]: { selectedIds: ids },
          [toPageId]: {
            selectedIds: toPageState.selectedIds,
            camera: toPageState.camera
          }
        }
      }
    },
    after: {
      appState: {
        currentPageId: toPageId
      },
      document: {
        pages: {
          [fromPageId]: fromPage.after,
          [toPageId]: toPage.after
        },
        pageStates: {
          [fromPageId]: { selectedIds: [] },
          [toPageId]: {
            selectedIds: ids,
            camera: {
              zoom,
              point
            }
          }
        }
      }
    }
  };
}
function reorderShapes(app, ids, type) {
  const { currentPageId, page } = app;
  const parentIds = new Set(ids.map((id) => app.getShape(id).parentId));
  let result = { before: {}, after: {} };
  let startIndex;
  let startChildIndex;
  let step;
  Array.from(parentIds.values()).forEach((parentId) => {
    let sortedChildren = [];
    if (parentId === page.id) {
      sortedChildren = Object.values(page.shapes).sort((a9, b7) => a9.childIndex - b7.childIndex);
    } else {
      const parent = app.getShape(parentId);
      if (!parent.children)
        throw Error("No children in parent!");
      sortedChildren = parent.children.map((childId) => app.getShape(childId)).sort((a9, b7) => a9.childIndex - b7.childIndex);
    }
    const sortedChildIds = sortedChildren.map((shape) => shape.id);
    const sortedIndicesToMove = ids.filter((id) => sortedChildIds.includes(id)).map((id) => sortedChildIds.indexOf(id)).sort((a9, b7) => a9 - b7);
    if (sortedIndicesToMove.length === sortedChildIds.length)
      return;
    switch (type) {
      case MoveType.ToBack: {
        for (let i8 = 0; i8 < sortedChildIds.length; i8++) {
          if (sortedIndicesToMove.includes(i8))
            continue;
          startIndex = i8;
          break;
        }
        startChildIndex = sortedChildren[startIndex].childIndex;
        step = startChildIndex / (sortedIndicesToMove.length + 1);
        result = TLDR.mutateShapes(app.state, sortedIndicesToMove.map((i8) => sortedChildren[i8].id).reverse(), (_shape, i8) => ({
          childIndex: startChildIndex - (i8 + 1) * step
        }), currentPageId);
        break;
      }
      case MoveType.ToFront: {
        for (let i8 = sortedChildIds.length - 1; i8 >= 0; i8--) {
          if (sortedIndicesToMove.includes(i8))
            continue;
          startIndex = i8;
          break;
        }
        startChildIndex = sortedChildren[startIndex].childIndex;
        step = 1;
        result = TLDR.mutateShapes(app.state, sortedIndicesToMove.map((i8) => sortedChildren[i8].id), (_shape, i8) => ({
          childIndex: startChildIndex + (i8 + 1)
        }), currentPageId);
        break;
      }
      case MoveType.Backward: {
        const indexMap = {};
        for (let i8 = sortedChildIds.length - 1; i8 >= 0; i8--) {
          if (sortedIndicesToMove.includes(i8)) {
            for (let j4 = i8; j4 >= 0; j4--) {
              if (!sortedIndicesToMove.includes(j4)) {
                const endChildIndex = sortedChildren[j4].childIndex;
                let startChildIndex2;
                let step2;
                if (j4 === 0) {
                  startChildIndex2 = endChildIndex / 2;
                  step2 = endChildIndex / 2 / (i8 - j4 + 1);
                } else {
                  startChildIndex2 = sortedChildren[j4 - 1].childIndex;
                  step2 = (endChildIndex - startChildIndex2) / (i8 - j4 + 1);
                  startChildIndex2 += step2;
                }
                for (let k3 = 0; k3 < i8 - j4; k3++) {
                  indexMap[sortedChildren[j4 + k3 + 1].id] = startChildIndex2 + step2 * k3;
                }
                break;
              }
            }
          }
        }
        if (Object.values(indexMap).length > 0) {
          result = TLDR.mutateShapes(app.state, sortedIndicesToMove.map((i8) => sortedChildren[i8].id), (shape) => ({
            childIndex: indexMap[shape.id]
          }), currentPageId);
        }
        break;
      }
      case MoveType.Forward: {
        const indexMap = {};
        for (let i8 = 0; i8 < sortedChildIds.length; i8++) {
          if (sortedIndicesToMove.includes(i8)) {
            for (let j4 = i8; j4 < sortedChildIds.length; j4++) {
              if (!sortedIndicesToMove.includes(j4)) {
                startChildIndex = sortedChildren[j4].childIndex;
                const step2 = j4 === sortedChildIds.length - 1 ? 1 : (sortedChildren[j4 + 1].childIndex - startChildIndex) / (j4 - i8 + 1);
                for (let k3 = 0; k3 < j4 - i8; k3++) {
                  indexMap[sortedChildren[i8 + k3].id] = startChildIndex + step2 * (k3 + 1);
                }
                break;
              }
            }
          }
        }
        if (Object.values(indexMap).length > 0) {
          result = TLDR.mutateShapes(app.state, sortedIndicesToMove.map((i8) => sortedChildren[i8].id), (shape) => ({
            childIndex: indexMap[shape.id]
          }), currentPageId);
        }
        break;
      }
    }
  });
  return {
    id: "move",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: result.before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: result.after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function renamePage(app, pageId, name) {
  const { page } = app;
  return {
    id: "rename_page",
    before: {
      document: {
        pages: {
          [pageId]: { name: page.name }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: { name }
        }
      }
    }
  };
}
function resetBounds(app, ids, pageId) {
  const { currentPageId } = app;
  const { before, after } = TLDR.mutateShapes(app.state, ids, (shape) => {
    var _a2, _b;
    return (_b = (_a2 = app.getShapeUtil(shape)).onDoubleClickBoundsHandle) == null ? void 0 : _b.call(_a2, shape);
  }, pageId);
  return {
    id: "reset_bounds",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
var PI23 = Math.PI * 2;
function rotateShapes(app, ids, delta = -PI23 / 4) {
  const { currentPageId } = app;
  const before = {};
  const after = {};
  const shapesToRotate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children.map((childId) => app.getShape(childId)) : shape;
  }).filter((shape) => !shape.isLocked);
  const origin = Utils.getBoundsCenter(Utils.getCommonBounds(shapesToRotate.map((shape) => TLDR.getBounds(shape))));
  shapesToRotate.forEach((shape) => {
    const change = TLDR.getRotatedShapeMutation(shape, TLDR.getCenter(shape), origin, delta);
    if (!change)
      return;
    before[shape.id] = TLDR.getBeforeShape(shape, change);
    after[shape.id] = change;
  });
  return {
    id: "rotate",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function stretchShapes(app, ids, type) {
  const { currentPageId, selectedIds } = app;
  const initialShapes = ids.map((id) => app.getShape(id));
  const boundsForShapes = initialShapes.map((shape) => TLDR.getBounds(shape));
  const commonBounds = Utils.getCommonBounds(boundsForShapes);
  const idsToMutate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children : shape.id;
  }).filter((id) => !app.getShape(id).isLocked);
  const { before, after } = TLDR.mutateShapes(app.state, idsToMutate, (shape) => {
    const bounds = TLDR.getBounds(shape);
    switch (type) {
      case StretchType.Horizontal: {
        const newBounds = __spreadProps4(__spreadValues4({}, bounds), {
          minX: commonBounds.minX,
          maxX: commonBounds.maxX,
          width: commonBounds.width
        });
        return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {
          type: TLBoundsCorner.TopLeft,
          scaleX: newBounds.width / bounds.width,
          scaleY: 1,
          initialShape: shape,
          transformOrigin: [0.5, 0.5]
        });
      }
      case StretchType.Vertical: {
        const newBounds = __spreadProps4(__spreadValues4({}, bounds), {
          minY: commonBounds.minY,
          maxY: commonBounds.maxY,
          height: commonBounds.height
        });
        return TLDR.getShapeUtil(shape).transformSingle(shape, newBounds, {
          type: TLBoundsCorner.TopLeft,
          scaleX: 1,
          scaleY: newBounds.height / bounds.height,
          initialShape: shape,
          transformOrigin: [0.5, 0.5]
        });
      }
    }
  }, currentPageId);
  initialShapes.forEach((shape) => {
    if (shape.type === TDShapeType.Group) {
      delete before[shape.id];
      delete after[shape.id];
    }
  });
  return {
    id: "stretch",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: before }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: after }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function styleShapes(app, ids, changes) {
  const { currentPageId, selectedIds } = app;
  const shapeIdsToMutate = ids.flatMap((id) => TLDR.getDocumentBranch(app.state, id, currentPageId)).filter((id) => !app.getShape(id).isLocked);
  const beforeShapes = {};
  const afterShapes = {};
  shapeIdsToMutate.map((id) => app.getShape(id)).filter((shape) => !shape.isLocked).forEach((shape) => {
    beforeShapes[shape.id] = {
      style: __spreadValues4({}, Object.fromEntries(Object.keys(changes).map((key) => [key, shape.style[key]])))
    };
    afterShapes[shape.id] = {
      style: changes
    };
    if (shape.type === TDShapeType.Text) {
      beforeShapes[shape.id].point = shape.point;
      afterShapes[shape.id].point = Vec.toFixed(Vec.add(shape.point, Vec.sub(app.getShapeUtil(shape).getCenter(shape), app.getShapeUtil(shape).getCenter(__spreadProps4(__spreadValues4({}, shape), {
        style: __spreadValues4(__spreadValues4({}, shape.style), changes)
      })))));
    }
  });
  return {
    id: "style",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: beforeShapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      },
      appState: {
        currentStyle: __spreadValues4({}, app.appState.currentStyle)
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: afterShapes
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      },
      appState: {
        currentStyle: changes
      }
    }
  };
}
function toggleShapesDecoration(app, ids, decorationId) {
  const { currentPageId, selectedIds } = app;
  const beforeShapes = Object.fromEntries(ids.map((id) => {
    var _a2;
    return [
      id,
      {
        decorations: {
          [decorationId]: (_a2 = app.getShape(id).decorations) == null ? void 0 : _a2[decorationId]
        }
      }
    ];
  }));
  const afterShapes = Object.fromEntries(ids.filter((id) => !app.getShape(id).isLocked).map((id) => {
    var _a2;
    return [
      id,
      {
        decorations: {
          [decorationId]: ((_a2 = app.getShape(id).decorations) == null ? void 0 : _a2[decorationId]) ? void 0 : Decoration.Arrow
        }
      }
    ];
  }));
  return {
    id: "toggle_decorations",
    before: {
      document: {
        pages: {
          [currentPageId]: { shapes: beforeShapes }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: { shapes: afterShapes }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function toggleShapeProp(app, ids, prop) {
  const { currentPageId } = app;
  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => prop === "isLocked" ? true : !shape.isLocked);
  const isAllToggled = initialShapes.every((shape) => shape[prop]);
  const before = {};
  const after = {};
  initialShapes.forEach((shape) => {
    before[shape.id] = { [prop]: shape[prop] };
    after[shape.id] = { [prop]: !isAllToggled };
  });
  return {
    id: "toggle",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function translateShapes(app, ids, delta) {
  const { currentPageId, selectedIds } = app;
  app.rotationInfo.selectedIds = [...selectedIds];
  const before = {
    shapes: {},
    bindings: {}
  };
  const after = {
    shapes: {},
    bindings: {}
  };
  const idsToMutate = ids.flatMap((id) => {
    const shape = app.getShape(id);
    return shape.children ? shape.children : shape.id;
  }).filter((id) => !app.getShape(id).isLocked);
  const change = TLDR.mutateShapes(app.state, idsToMutate, (shape) => ({
    point: Vec.toFixed(Vec.add(shape.point, delta))
  }), currentPageId);
  before.shapes = change.before;
  after.shapes = change.after;
  const bindingsToDelete = TLDR.getBindings(app.state, currentPageId).filter((binding) => ids.includes(binding.fromId) && !ids.includes(binding.toId));
  bindingsToDelete.forEach((binding) => {
    before.bindings[binding.id] = binding;
    after.bindings[binding.id] = void 0;
    for (const id of [binding.toId, binding.fromId]) {
      const shape = app.getShape(id);
      if (!shape.handles)
        continue;
      Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
        var _a2, _b;
        before.shapes[id] = __spreadProps4(__spreadValues4({}, before.shapes[id]), {
          handles: __spreadProps4(__spreadValues4({}, (_a2 = before.shapes[id]) == null ? void 0 : _a2.handles), {
            [handle.id]: { bindingId: binding.id }
          })
        });
        after.shapes[id] = __spreadProps4(__spreadValues4({}, after.shapes[id]), {
          handles: __spreadProps4(__spreadValues4({}, (_b = after.shapes[id]) == null ? void 0 : _b.handles), { [handle.id]: { bindingId: void 0 } })
        });
      });
    }
  });
  return {
    id: "translate",
    before: {
      document: {
        pages: {
          [currentPageId]: before
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: after
        },
        pageStates: {
          [currentPageId]: {
            selectedIds: ids
          }
        }
      }
    }
  };
}
function ungroupShapes(app, selectedIds, groupShapes2, pageId) {
  const { bindings } = app;
  const beforeShapes = {};
  const afterShapes = {};
  const beforeBindings = {};
  const afterBindings = {};
  const beforeSelectedIds = selectedIds;
  const afterSelectedIds = selectedIds.filter((id) => !groupShapes2.find((shape) => shape.id === id));
  groupShapes2.filter((shape) => !shape.isLocked).forEach((groupShape) => {
    const shapesToReparent = [];
    const deletedGroupIds = [];
    beforeShapes[groupShape.id] = groupShape;
    afterShapes[groupShape.id] = void 0;
    groupShape.children.forEach((id) => {
      afterSelectedIds.push(id);
      const shape = app.getShape(id, pageId);
      shapesToReparent.push(shape);
    });
    const startingChildIndex = groupShape.childIndex;
    const endingChildIndex = TLDR.getChildIndexAbove(app.state, groupShape.id, pageId);
    const step = (endingChildIndex - startingChildIndex) / shapesToReparent.length;
    const sortedShapes = shapesToReparent.sort((a9, b7) => a9.childIndex - b7.childIndex);
    sortedShapes.forEach((shape, index2) => {
      beforeShapes[shape.id] = {
        parentId: shape.parentId,
        childIndex: shape.childIndex
      };
      afterShapes[shape.id] = {
        parentId: pageId,
        childIndex: startingChildIndex + step * index2
      };
    });
    bindings.filter((binding) => binding.toId === groupShape.id || binding.fromId === groupShape.id).forEach((binding) => {
      for (const id of [binding.toId, binding.fromId]) {
        if (afterShapes[id] === void 0) {
          beforeBindings[binding.id] = binding;
          afterBindings[binding.id] = void 0;
          const shape = app.getShape(id, pageId);
          if (shape.handles) {
            Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
              var _a2, _b;
              beforeShapes[id] = __spreadProps4(__spreadValues4({}, beforeShapes[id]), {
                handles: __spreadProps4(__spreadValues4({}, (_a2 = beforeShapes[id]) == null ? void 0 : _a2.handles), {
                  [handle.id]: { bindingId: binding.id }
                })
              });
              if (!deletedGroupIds.includes(id)) {
                afterShapes[id] = __spreadProps4(__spreadValues4({}, afterShapes[id]), {
                  handles: __spreadProps4(__spreadValues4({}, (_b = afterShapes[id]) == null ? void 0 : _b.handles), {
                    [handle.id]: { bindingId: void 0 }
                  })
                });
              }
            });
          }
        }
      }
    });
  });
  return {
    id: "ungroup",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: beforeShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: beforeSelectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: afterShapes,
            bindings: beforeBindings
          }
        },
        pageStates: {
          [pageId]: {
            selectedIds: afterSelectedIds
          }
        }
      }
    }
  };
}
function updateShapes(app, updates, pageId) {
  const ids = updates.map((update) => update.id);
  const change = TLDR.mutateShapes(app.state, ids.filter((id) => !app.getShape(id, pageId).isLocked), (_shape, i8) => updates[i8], pageId);
  return {
    id: "update",
    before: {
      document: {
        pages: {
          [pageId]: {
            shapes: change.before
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [pageId]: {
            shapes: change.after
          }
        }
      }
    }
  };
}
function setShapesProps(app, ids, partial) {
  const { currentPageId, selectedIds } = app;
  const initialShapes = ids.map((id) => app.getShape(id)).filter((shape) => partial["isLocked"] ? true : !shape.isLocked);
  const before = {};
  const after = {};
  const keys = Object.keys(partial);
  initialShapes.forEach((shape) => {
    before[shape.id] = Object.fromEntries(keys.map((key) => [key, shape[key]]));
    after[shape.id] = partial;
  });
  return {
    id: "set_props",
    before: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: before
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    },
    after: {
      document: {
        pages: {
          [currentPageId]: {
            shapes: after
          }
        },
        pageStates: {
          [currentPageId]: {
            selectedIds
          }
        }
      }
    }
  };
}
var BaseSession = class {
  constructor(app) {
    this.app = app;
  }
};
var ArrowSession = class extends BaseSession {
  constructor(app, shapeId, handleId, isCreate = false) {
    super(app);
    this.type = SessionType.Arrow;
    this.status = TDStatus.TranslatingHandle;
    this.newStartBindingId = Utils.uniqueId();
    this.draggedBindingId = Utils.uniqueId();
    this.didBind = false;
    this.start = () => void 0;
    this.update = () => {
      var _a3, _b, _c;
      const { initialShape } = this;
      const {
        currentPoint,
        shiftKey,
        altKey,
        metaKey,
        currentGrid,
        settings: { showGrid }
      } = this.app;
      const shape = this.app.getShape(initialShape.id);
      if (shape.isLocked)
        return;
      const handles = shape.handles;
      const handleId2 = this.handleId;
      if (!handles[handleId2].canBind)
        return;
      let delta = Vec.sub(currentPoint, handles[handleId2].point);
      if (shiftKey) {
        const A4 = handles[handleId2 === "start" ? "end" : "start"].point;
        const B3 = handles[handleId2].point;
        const C6 = Vec.toFixed(Vec.sub(Vec.add(B3, delta), shape.point));
        const angle = Vec.angle(A4, C6);
        const adjusted = Vec.rotWith(C6, A4, Utils.snapAngleToSegments(angle, 24) - angle);
        delta = Vec.add(delta, Vec.sub(adjusted, C6));
      }
      const nextPoint = Vec.sub(Vec.add(handles[handleId2].point, delta), shape.point);
      const handle = __spreadProps4(__spreadValues4({}, handles[handleId2]), {
        point: showGrid ? Vec.snap(nextPoint, currentGrid) : Vec.toFixed(nextPoint),
        bindingId: void 0
      });
      const utils = shapeUtils[TDShapeType.Arrow];
      const change = (_a3 = utils.onHandleChange) == null ? void 0 : _a3.call(utils, shape, {
        [handleId2]: handle
      });
      if (!change)
        return;
      const next = {
        shape: Utils.deepMerge(shape, change),
        bindings: {}
      };
      if (this.initialBinding) {
        next.bindings[this.initialBinding.id] = void 0;
      }
      if (this.startBindingShapeId) {
        let startBinding;
        const target = this.app.page.shapes[this.startBindingShapeId];
        const targetUtils = TLDR.getShapeUtil(target);
        if (!metaKey) {
          const center = targetUtils.getCenter(target);
          const handle2 = next.shape.handles.start;
          const rayPoint = Vec.add(handle2.point, next.shape.point);
          const rayOrigin = center;
          const rayDirection = Vec.uni(Vec.sub(rayPoint, rayOrigin));
          startBinding = this.findBindingPoint(shape, target, "start", this.newStartBindingId, center, rayOrigin, rayDirection, false);
        }
        if (startBinding) {
          this.didBind = true;
          next.bindings[this.newStartBindingId] = startBinding;
          next.shape.handles = __spreadProps4(__spreadValues4({}, next.shape.handles), {
            start: __spreadProps4(__spreadValues4({}, next.shape.handles.start), {
              bindingId: startBinding.id
            })
          });
          const target2 = this.app.page.shapes[this.startBindingShapeId];
          const targetUtils2 = TLDR.getShapeUtil(target2);
          const arrowChange = (_c = (_b = TLDR.getShapeUtil(next.shape.type)).onBindingChange) == null ? void 0 : _c.call(_b, next.shape, startBinding, target2, targetUtils2.getBounds(target2), targetUtils2.getExpandedBounds(target2), targetUtils2.getCenter(target2));
          if (arrowChange) {
            Object.assign(next.shape, arrowChange);
          }
        } else {
          this.didBind = this.didBind || false;
          if (this.app.page.bindings[this.newStartBindingId]) {
            next.bindings[this.newStartBindingId] = void 0;
          }
          if (shape.handles.start.bindingId === this.newStartBindingId) {
            next.shape.handles = __spreadProps4(__spreadValues4({}, next.shape.handles), {
              start: __spreadProps4(__spreadValues4({}, next.shape.handles.start), {
                bindingId: void 0
              })
            });
          }
        }
      }
      let draggedBinding;
      if (!metaKey) {
        const handle2 = next.shape.handles[this.handleId];
        const oppositeHandle = next.shape.handles[this.handleId === "start" ? "end" : "start"];
        const rayOrigin = Vec.add(oppositeHandle.point, next.shape.point);
        const rayPoint = Vec.add(handle2.point, next.shape.point);
        const rayDirection = Vec.uni(Vec.sub(rayPoint, rayOrigin));
        const targets = this.bindableShapeIds.map((id) => this.app.page.shapes[id]);
        for (const target of targets) {
          draggedBinding = this.findBindingPoint(shape, target, this.handleId, this.draggedBindingId, rayPoint, rayOrigin, rayDirection, altKey);
          if (draggedBinding)
            break;
        }
      }
      if (draggedBinding) {
        this.didBind = true;
        next.bindings[this.draggedBindingId] = draggedBinding;
        next.shape.handles = __spreadProps4(__spreadValues4({}, next.shape.handles), {
          [this.handleId]: __spreadProps4(__spreadValues4({}, next.shape.handles[this.handleId]), {
            bindingId: this.draggedBindingId
          })
        });
        const target = this.app.page.shapes[draggedBinding.toId];
        const targetUtils = TLDR.getShapeUtil(target);
        const utils2 = shapeUtils[TDShapeType.Arrow];
        const arrowChange = utils2.onBindingChange(next.shape, draggedBinding, target, targetUtils.getBounds(target), targetUtils.getExpandedBounds(target), targetUtils.getCenter(target));
        if (arrowChange) {
          Object.assign(next.shape, arrowChange);
        }
      } else {
        this.didBind = this.didBind || false;
        const currentBindingId = shape.handles[this.handleId].bindingId;
        if (currentBindingId) {
          next.bindings = __spreadProps4(__spreadValues4({}, next.bindings), {
            [currentBindingId]: void 0
          });
          next.shape.handles = __spreadProps4(__spreadValues4({}, next.shape.handles), {
            [this.handleId]: __spreadProps4(__spreadValues4({}, next.shape.handles[this.handleId]), {
              bindingId: void 0
            })
          });
        }
      }
      return {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [shape.id]: next.shape
              },
              bindings: next.bindings
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              bindingId: next.shape.handles[handleId2].bindingId
            }
          }
        }
      };
    };
    this.cancel = () => {
      const { initialShape, initialBinding, newStartBindingId, draggedBindingId } = this;
      const afterBindings = {};
      afterBindings[draggedBindingId] = void 0;
      if (initialBinding) {
        afterBindings[initialBinding.id] = initialBinding;
      }
      if (newStartBindingId) {
        afterBindings[newStartBindingId] = void 0;
      }
      return {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [initialShape.id]: this.isCreate ? void 0 : initialShape
              },
              bindings: afterBindings
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              selectedIds: this.isCreate ? [] : [initialShape.id],
              bindingId: void 0,
              hoveredId: void 0,
              editingId: void 0
            }
          }
        }
      };
    };
    this.complete = () => {
      const { initialShape, initialBinding, newStartBindingId, startBindingShapeId, handleId: handleId2 } = this;
      const currentShape = TLDR.onSessionComplete(this.app.page.shapes[initialShape.id]);
      const currentBindingId = currentShape.handles[handleId2].bindingId;
      if (!(currentBindingId || initialBinding) && Vec.dist(currentShape.handles.start.point, currentShape.handles.end.point) < 4) {
        return this.cancel();
      }
      const beforeBindings = {};
      const afterBindings = {};
      if (initialBinding) {
        beforeBindings[initialBinding.id] = this.isCreate ? void 0 : initialBinding;
        afterBindings[initialBinding.id] = void 0;
      }
      if (currentBindingId) {
        beforeBindings[currentBindingId] = void 0;
        afterBindings[currentBindingId] = this.app.page.bindings[currentBindingId];
      }
      if (startBindingShapeId) {
        beforeBindings[newStartBindingId] = void 0;
        afterBindings[newStartBindingId] = this.app.page.bindings[newStartBindingId];
      }
      return {
        id: "arrow",
        before: {
          document: {
            pages: {
              [this.app.currentPageId]: {
                shapes: {
                  [initialShape.id]: this.isCreate ? void 0 : initialShape
                },
                bindings: beforeBindings
              }
            },
            pageStates: {
              [this.app.currentPageId]: {
                selectedIds: this.isCreate ? [] : [initialShape.id],
                bindingId: void 0,
                hoveredId: void 0,
                editingId: void 0
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [this.app.currentPageId]: {
                shapes: {
                  [initialShape.id]: currentShape
                },
                bindings: afterBindings
              }
            },
            pageStates: {
              [this.app.currentPageId]: {
                selectedIds: [initialShape.id],
                bindingId: void 0,
                hoveredId: void 0,
                editingId: void 0
              }
            }
          }
        }
      };
    };
    this.findBindingPoint = (shape, target, handleId2, bindingId, point, origin, direction, bindAnywhere) => {
      const util = TLDR.getShapeUtil(target.type);
      const bindingPoint = util.getBindingPoint(target, shape, point, origin, direction, bindAnywhere);
      if (!bindingPoint)
        return;
      return {
        id: bindingId,
        type: "arrow",
        fromId: shape.id,
        toId: target.id,
        handleId: handleId2,
        point: Vec.toFixed(bindingPoint.point),
        distance: bindingPoint.distance
      };
    };
    var _a2;
    this.isCreate = isCreate;
    const { currentPageId } = app.state.appState;
    const page = app.state.document.pages[currentPageId];
    this.handleId = handleId;
    this.initialShape = page.shapes[shapeId];
    this.bindableShapeIds = TLDR.getBindableShapeIds(app.state).filter((id) => !(id === this.initialShape.id || id === this.initialShape.parentId));
    const { originPoint } = this.app;
    if (this.isCreate) {
      this.startBindingShapeId = (_a2 = this.bindableShapeIds.map((id) => page.shapes[id]).find((shape) => Utils.pointInBounds(originPoint, TLDR.getShapeUtil(shape).getBounds(shape)))) == null ? void 0 : _a2.id;
    } else {
      const initialBindingId = this.initialShape.handles[this.handleId].bindingId;
      if (initialBindingId) {
        this.initialBinding = page.bindings[initialBindingId];
      } else {
        this.initialShape.handles[this.handleId].bindingId = void 0;
      }
    }
  }
};
var BrushSession = class extends BaseSession {
  constructor(app) {
    super(app);
    this.type = SessionType.Brush;
    this.status = TDStatus.Brushing;
    this.start = () => void 0;
    this.update = () => {
      const {
        initialSelectedIds,
        shapesToTest,
        app: { originPoint, currentPoint }
      } = this;
      const brush = Utils.getBoundsFromPoints([originPoint, currentPoint]);
      const hits = new Set();
      const selectedIds = new Set(initialSelectedIds);
      shapesToTest.forEach(({ id, selectId }) => {
        const { metaKey } = this.app;
        const shape = this.app.getShape(id);
        if (!hits.has(selectId)) {
          const util = this.app.getShapeUtil(shape);
          if (metaKey ? Utils.boundsContain(brush, util.getBounds(shape)) : util.hitTestBounds(shape, brush)) {
            hits.add(selectId);
            if (!selectedIds.has(selectId)) {
              selectedIds.add(selectId);
            }
          } else if (selectedIds.has(selectId)) {
            selectedIds.delete(selectId);
          }
        }
      });
      const currentSelectedIds = this.app.selectedIds;
      const didChange = selectedIds.size !== currentSelectedIds.length || currentSelectedIds.some((id) => !selectedIds.has(id));
      const afterSelectedIds = didChange ? Array.from(selectedIds.values()) : currentSelectedIds;
      return {
        document: {
          pageStates: {
            [this.app.currentPageId]: {
              brush,
              selectedIds: afterSelectedIds
            }
          }
        }
      };
    };
    this.cancel = () => {
      return {
        document: {
          pageStates: {
            [this.app.currentPageId]: {
              brush: null,
              selectedIds: Array.from(this.initialSelectedIds.values())
            }
          }
        }
      };
    };
    this.complete = () => {
      return {
        document: {
          pageStates: {
            [this.app.currentPageId]: {
              brush: null,
              selectedIds: [...this.app.selectedIds]
            }
          }
        }
      };
    };
    const { currentPageId } = app;
    this.initialSelectedIds = new Set(this.app.selectedIds);
    this.shapesToTest = this.app.shapes.filter((shape) => !(shape.isLocked || shape.isHidden || shape.parentId !== currentPageId || this.initialSelectedIds.has(shape.id) || this.initialSelectedIds.has(shape.parentId))).map((shape) => ({
      id: shape.id,
      bounds: this.app.getShapeUtil(shape).getBounds(shape),
      selectId: shape.id
    }));
  }
};
var DrawSession = class extends BaseSession {
  constructor(app, id) {
    super(app);
    this.type = SessionType.Draw;
    this.status = TDStatus.Creating;
    this.shiftedPoints = [];
    this.start = () => void 0;
    this.update = () => {
      const { shapeId } = this;
      const { currentPoint, originPoint: originPoint2, shiftKey } = this.app;
      if (!this.lockedDirection && this.points.length > 1) {
        const bounds = Utils.getBoundsFromPoints(this.points);
        if (bounds.width > 8 || bounds.height > 8) {
          this.lockedDirection = bounds.width > bounds.height ? "horizontal" : "vertical";
        }
      }
      if (shiftKey) {
        if (!this.isLocked && this.points.length > 2) {
          if (!this.lockedDirection) {
            const bounds = Utils.getBoundsFromPoints(this.points);
            this.lockedDirection = bounds.width > bounds.height ? "horizontal" : "vertical";
          }
          this.isLocked = true;
          const returning = [...this.lastAdjustedPoint];
          if (this.lockedDirection === "vertical") {
            returning[0] = 0;
          } else {
            returning[1] = 0;
          }
          this.points.push(returning.concat(currentPoint[2]));
        }
      } else if (this.isLocked) {
        this.isLocked = false;
      }
      if (this.isLocked) {
        if (this.lockedDirection === "vertical") {
          currentPoint[0] = originPoint2[0];
        } else {
          currentPoint[1] = originPoint2[1];
        }
      }
      const newAdjustedPoint = Vec.toFixed(Vec.sub(currentPoint, originPoint2)).concat(currentPoint[2]);
      if (Vec.isEqual(this.lastAdjustedPoint, newAdjustedPoint))
        return;
      this.points.push(newAdjustedPoint);
      this.lastAdjustedPoint = newAdjustedPoint;
      const prevTopLeft = [...this.topLeft];
      const topLeft = [
        Math.min(this.topLeft[0], currentPoint[0]),
        Math.min(this.topLeft[1], currentPoint[1])
      ];
      const delta = Vec.sub(topLeft, originPoint2);
      let points;
      if (prevTopLeft[0] !== topLeft[0] || prevTopLeft[1] !== topLeft[1]) {
        this.topLeft = topLeft;
        points = this.points.map((pt) => {
          return Vec.toFixed(Vec.sub(pt, delta)).concat(pt[2]);
        });
      } else {
        points = [...this.shiftedPoints, Vec.sub(newAdjustedPoint, delta).concat(newAdjustedPoint[2])];
      }
      this.shiftedPoints = points;
      return {
        document: {
          pages: {
            [this.app.currentPageId]: {
              shapes: {
                [shapeId]: {
                  point: this.topLeft,
                  points
                }
              }
            }
          },
          pageStates: {
            [this.app.currentPageId]: {
              selectedIds: [shapeId]
            }
          }
        }
      };
    };
    this.cancel = () => {
      const { shapeId } = this;
      const pageId = this.app.currentPageId;
      return {
        document: {
          pages: {
            [pageId]: {
              shapes: {
                [shapeId]: void 0
              }
            }
          },
          pageStates: {
            [pageId]: {
              selectedIds: []
            }
          }
        }
      };
    };
    this.complete = () => {
      const { shapeId } = this;
      const pageId = this.app.currentPageId;
      const shape = this.app.getShape(shapeId);
      return {
        id: "create_draw",
        before: {
          document: {
            pages: {
              [pageId]: {
                shapes: {
                  [shapeId]: void 0
                }
              }
            },
            pageStates: {
              [pageId]: {
                selectedIds: []
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [pageId]: {
                shapes: {
                  [shapeId]: __spreadProps4(__spreadValues4({}, shape), {
                    point: Vec.toFixed(shape.point),
                    points: shape.points.map((pt) => Vec.toFixed(pt)),
                    isComplete: true
                  })
                }
              }
            },
            pageStates: {
              [this.app.currentPageId]: {
                selectedIds: []
              }
            }
          }
        }
      };
    };
    const { originPoint } = this.app;
    this.topLeft = [...originPoint];
    this.shapeId = id;
    this.points = [[0, 0, originPoint[2] || 0.5]];
    this.shiftedPoints = [...this.points];
    this.lastAdjustedPoint = [0, 0];
  }
};
var HandleSession = class extends BaseSession {
  constructor(app, shapeId, handleId, commandId = "move_handle") {
    super(app);
    this.type = SessionType.Handle;
    this.status = TDStatus.TranslatingHandle;
    this.shiftKey = false;
    this.start = () => void 0;
    this.update = () => {
      var _a2, _b;
      const {
        initialShape,
        app: { currentPageId, currentPoint, shiftKey, altKey, metaKey }
      } = this;
      const shape = this.app.getShape(initialShape.id);
      if (shape.isLocked)
        return void 0;
      const handles = shape.handles;
      const handleId2 = this.handleId;
      const delta = Vec.sub(currentPoint, handles[handleId2].point);
      const handle = __spreadProps4(__spreadValues4({}, handles[handleId2]), {
        point: Vec.sub(Vec.add(handles[handleId2].point, delta), shape.point)
      });
      const change = (_b = (_a2 = TLDR.getShapeUtil(shape)).onHandleChange) == null ? void 0 : _b.call(_a2, shape, {
        [handleId2]: handle
      }, { delta, shiftKey, altKey, metaKey });
      if (!change)
        return;
      return {
        document: {
          pages: {
            [currentPageId]: {
              shapes: {
                [shape.id]: change
              }
            }
          }
        }
      };
    };
    this.cancel = () => {
      const {
        initialShape,
        app: { currentPageId }
      } = this;
      return {
        document: {
          pages: {
            [currentPageId]: {
              shapes: {
                [initialShape.id]: initialShape
              }
            }
          }
        }
      };
    };
    this.complete = () => {
      const {
        initialShape,
        app: { currentPageId }
      } = this;
      return {
        id: this.commandId,
        before: {
          document: {
            pages: {
              [currentPageId]: {
                shapes: {
                  [initialShape.id]: initialShape
                }
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [currentPageId]: {
                shapes: {
                  [initialShape.id]: TLDR.onSessionComplete(this.app.getShape(this.initialShape.id))
                }
              }
            }
          }
        }
      };
    };
    const { originPoint } = app;
    this.topLeft = [...originPoint];
    this.handleId = handleId;
    this.initialShape = this.app.getShape(shapeId);
    this.commandId = commandId;
  }
};
var RotateSession = class extends BaseSession {
  constructor(app) {
    super(app);
    this.type = SessionType.Rotate;
    this.status = TDStatus.Transforming;
    this.delta = [0, 0];
    this.changes = {};
    this.start = () => void 0;
    this.update = () => {
      const {
        commonBoundsCenter,
        initialShapes: initialShapes2,
        app: { currentPageId: currentPageId2, currentPoint, shiftKey }
      } = this;
      const shapes = {};
      let directionDelta = Vec.angle(commonBoundsCenter, currentPoint) - this.initialAngle;
      if (shiftKey) {
        directionDelta = Utils.snapAngleToSegments(directionDelta, 24);
      }
      initialShapes2.forEach(({ center, shape }) => {
        const { rotation = 0 } = shape;
        let shapeDelta = 0;
        if (shiftKey) {
          const snappedRotation = Utils.snapAngleToSegments(rotation, 24);
          shapeDelta = snappedRotation - rotation;
        }
        const change = TLDR.getRotatedShapeMutation(shape, center, commonBoundsCenter, shiftKey ? directionDelta + shapeDelta : directionDelta);
        if (change) {
          shapes[shape.id] = change;
        }
      });
      this.changes = shapes;
      return {
        document: {
          pages: {
            [currentPageId2]: {
              shapes
            }
          }
        }
      };
    };
    this.cancel = () => {
      const {
        initialShapes: initialShapes2,
        app: { currentPageId: currentPageId2 }
      } = this;
      const shapes = {};
      initialShapes2.forEach(({ shape }) => shapes[shape.id] = shape);
      return {
        document: {
          pages: {
            [currentPageId2]: {
              shapes
            }
          }
        }
      };
    };
    this.complete = () => {
      const {
        initialShapes: initialShapes2,
        app: { currentPageId: currentPageId2 }
      } = this;
      const beforeShapes = {};
      const afterShapes = this.changes;
      initialShapes2.forEach(({ shape: { id, point, rotation, handles } }) => {
        beforeShapes[id] = { point, rotation, handles };
      });
      return {
        id: "rotate",
        before: {
          document: {
            pages: {
              [currentPageId2]: {
                shapes: beforeShapes
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [currentPageId2]: {
                shapes: afterShapes
              }
            }
          }
        }
      };
    };
    const {
      app: { currentPageId, pageState, originPoint }
    } = this;
    const initialShapes = TLDR.getSelectedBranchSnapshot(app.state, currentPageId).filter((shape) => !shape.isLocked);
    if (initialShapes.length === 0) {
      throw Error("No selected shapes!");
    }
    if (app.rotationInfo.selectedIds === pageState.selectedIds) {
      if (app.rotationInfo.center === void 0) {
        throw Error("We should have a center for rotation!");
      }
      this.commonBoundsCenter = app.rotationInfo.center;
    } else {
      this.commonBoundsCenter = Utils.getBoundsCenter(Utils.getCommonBounds(initialShapes.map(TLDR.getBounds)));
      app.rotationInfo.selectedIds = pageState.selectedIds;
      app.rotationInfo.center = this.commonBoundsCenter;
    }
    this.initialShapes = initialShapes.filter((shape) => shape.children === void 0).map((shape) => {
      return {
        shape,
        center: this.app.getShapeUtil(shape).getCenter(shape)
      };
    });
    this.initialAngle = Vec.angle(this.commonBoundsCenter, originPoint);
  }
};
var TransformSession = class extends BaseSession {
  constructor(app, transformType = TLBoundsCorner.BottomRight, isCreate = false) {
    super(app);
    this.transformType = transformType;
    this.isCreate = isCreate;
    this.type = SessionType.Transform;
    this.status = TDStatus.Transforming;
    this.scaleX = 1;
    this.scaleY = 1;
    this.snapInfo = { state: "empty" };
    this.prevPoint = [0, 0];
    this.speed = 1;
    this.start = () => {
      this.snapInfo = {
        state: "ready",
        bounds: this.app.shapes.filter((shape) => !this.initialShapeIds.includes(shape.id)).map((shape) => Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape)))
      };
      return void 0;
    };
    this.update = () => {
      const {
        transformType: transformType2,
        shapeBounds,
        initialCommonBounds,
        isAllAspectRatioLocked,
        app: {
          currentPageId,
          pageState: { camera },
          viewport,
          currentPoint,
          previousPoint,
          originPoint,
          shiftKey,
          altKey,
          metaKey,
          currentGrid,
          settings: { isSnapping, showGrid }
        }
      } = this;
      const shapes = {};
      const delta = altKey ? Vec.mul(Vec.sub(currentPoint, originPoint), 2) : Vec.sub(currentPoint, originPoint);
      let newBounds = Utils.getTransformedBoundingBox(initialCommonBounds, transformType2, delta, 0, shiftKey || isAllAspectRatioLocked);
      if (altKey) {
        newBounds = __spreadValues4(__spreadValues4({}, newBounds), Utils.centerBounds(newBounds, Utils.getBoundsCenter(initialCommonBounds)));
      }
      if (showGrid) {
        newBounds = __spreadValues4(__spreadValues4({}, newBounds), Utils.snapBoundsToGrid(newBounds, currentGrid));
      }
      const speed = Vec.dist(currentPoint, previousPoint);
      const speedChange = speed - this.speed;
      this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);
      let snapLines = [];
      if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
        const snapResult = Utils.getSnapPoints(Utils.getBoundsWithCenter(newBounds), this.snapInfo.bounds.filter((bounds) => Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)), SNAP_DISTANCE / camera.zoom);
        if (snapResult) {
          snapLines = snapResult.snapLines;
          newBounds = Utils.getTransformedBoundingBox(initialCommonBounds, transformType2, Vec.sub(delta, snapResult.offset), 0, shiftKey || isAllAspectRatioLocked);
        }
      }
      this.scaleX = newBounds.scaleX;
      this.scaleY = newBounds.scaleY;
      shapeBounds.forEach(({ initialShape, initialShapeBounds, transformOrigin }) => {
        let newShapeBounds = Utils.getRelativeTransformedBoundingBox(newBounds, initialCommonBounds, initialShapeBounds, this.scaleX < 0, this.scaleY < 0);
        if (showGrid) {
          newShapeBounds = Utils.snapBoundsToGrid(newShapeBounds, currentGrid);
        }
        const afterShape = TLDR.transform(this.app.getShape(initialShape.id), newShapeBounds, {
          type: this.transformType,
          initialShape,
          scaleX: this.scaleX,
          scaleY: this.scaleY,
          transformOrigin
        });
        shapes[initialShape.id] = afterShape;
      });
      return {
        appState: {
          snapLines
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes
            }
          }
        }
      };
    };
    this.cancel = () => {
      const {
        shapeBounds,
        app: { currentPageId }
      } = this;
      const shapes = {};
      if (this.isCreate) {
        shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = void 0);
      } else {
        shapeBounds.forEach((shape) => shapes[shape.initialShape.id] = shape.initialShape);
      }
      return {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: this.isCreate ? [] : shapeBounds.map((shape) => shape.initialShape.id)
            }
          }
        }
      };
    };
    this.complete = () => {
      const {
        isCreate: isCreate2,
        shapeBounds,
        hasUnlockedShapes,
        app: { currentPageId }
      } = this;
      if (!hasUnlockedShapes)
        return;
      const beforeShapes = {};
      const afterShapes = {};
      let beforeSelectedIds;
      let afterSelectedIds;
      if (isCreate2) {
        beforeSelectedIds = [];
        afterSelectedIds = [];
        shapeBounds.forEach(({ initialShape }) => {
          beforeShapes[initialShape.id] = void 0;
          afterShapes[initialShape.id] = this.app.getShape(initialShape.id);
        });
      } else {
        beforeSelectedIds = this.initialSelectedIds;
        afterSelectedIds = this.initialSelectedIds;
        shapeBounds.forEach(({ initialShape }) => {
          beforeShapes[initialShape.id] = initialShape;
          afterShapes[initialShape.id] = this.app.getShape(initialShape.id);
        });
      }
      return {
        id: "transform",
        before: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId]: {
                shapes: beforeShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: beforeSelectedIds,
                hoveredId: void 0,
                editingId: void 0
              }
            }
          }
        },
        after: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId]: {
                shapes: afterShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: afterSelectedIds,
                hoveredId: void 0,
                editingId: void 0
              }
            }
          }
        }
      };
    };
    this.initialSelectedIds = [...this.app.selectedIds];
    this.app.rotationInfo.selectedIds = [...this.initialSelectedIds];
    this.initialShapes = TLDR.getSelectedBranchSnapshot(this.app.state, this.app.currentPageId).filter((shape) => !shape.isLocked);
    this.initialShapeIds = this.initialShapes.map((shape) => shape.id);
    this.hasUnlockedShapes = this.initialShapes.length > 0;
    this.isAllAspectRatioLocked = this.initialShapes.every((shape) => shape.isAspectRatioLocked || TLDR.getShapeUtil(shape).isAspectRatioLocked);
    const shapesBounds = Object.fromEntries(this.initialShapes.map((shape) => [shape.id, TLDR.getBounds(shape)]));
    const boundsArr = Object.values(shapesBounds);
    this.initialCommonBounds = Utils.getCommonBounds(boundsArr);
    const initialInnerBounds = Utils.getBoundsFromPoints(boundsArr.map(Utils.getBoundsCenter));
    this.shapeBounds = this.initialShapes.map((shape) => {
      const initialShapeBounds = shapesBounds[shape.id];
      const ic = Utils.getBoundsCenter(initialShapeBounds);
      const ix = (ic[0] - initialInnerBounds.minX) / initialInnerBounds.width;
      const iy = (ic[1] - initialInnerBounds.minY) / initialInnerBounds.height;
      return {
        initialShape: shape,
        initialShapeBounds,
        transformOrigin: [ix, iy]
      };
    });
  }
};
var TransformSingleSession = class extends BaseSession {
  constructor(app, id, transformType, isCreate = false) {
    super(app);
    this.type = SessionType.TransformSingle;
    this.status = TDStatus.Transforming;
    this.scaleX = 1;
    this.scaleY = 1;
    this.snapInfo = { state: "empty" };
    this.prevPoint = [0, 0];
    this.speed = 1;
    this.start = () => {
      this.snapInfo = {
        state: "ready",
        bounds: this.app.shapes.filter((shape2) => shape2.id !== this.initialShape.id).map((shape2) => Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape2)))
      };
      return void 0;
    };
    this.update = () => {
      const {
        transformType: transformType2,
        initialShape,
        initialShapeBounds,
        app: {
          settings: { isSnapping, showGrid },
          currentPageId,
          pageState: { camera },
          viewport,
          currentPoint,
          previousPoint,
          originPoint,
          currentGrid,
          shiftKey,
          altKey,
          metaKey
        }
      } = this;
      if (initialShape.isLocked)
        return void 0;
      const shapes = {};
      const delta = altKey ? Vec.mul(Vec.sub(currentPoint, originPoint), 2) : Vec.sub(currentPoint, originPoint);
      const shape2 = this.app.getShape(initialShape.id);
      const utils = TLDR.getShapeUtil(shape2);
      let newBounds = Utils.getTransformedBoundingBox(initialShapeBounds, transformType2, delta, shape2.rotation, shiftKey || shape2.isAspectRatioLocked || utils.isAspectRatioLocked);
      if (altKey) {
        newBounds = __spreadValues4(__spreadValues4({}, newBounds), Utils.centerBounds(newBounds, Utils.getBoundsCenter(initialShapeBounds)));
      }
      if (showGrid) {
        newBounds = __spreadValues4(__spreadValues4({}, newBounds), Utils.snapBoundsToGrid(newBounds, currentGrid));
      }
      const speed = Vec.dist(currentPoint, previousPoint);
      const speedChange = speed - this.speed;
      this.speed = this.speed + speedChange * (speedChange > 1 ? 0.5 : 0.15);
      let snapLines = [];
      if ((isSnapping && !metaKey || !isSnapping && metaKey) && !initialShape.rotation && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
        const snapResult = Utils.getSnapPoints(Utils.getBoundsWithCenter(newBounds), this.snapInfo.bounds.filter((bounds) => Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)), SNAP_DISTANCE / camera.zoom);
        if (snapResult) {
          snapLines = snapResult.snapLines;
          newBounds = Utils.getTransformedBoundingBox(initialShapeBounds, transformType2, Vec.sub(delta, snapResult.offset), shape2.rotation, shiftKey || shape2.isAspectRatioLocked || utils.isAspectRatioLocked);
        }
      }
      const afterShape = TLDR.getShapeUtil(shape2).transformSingle(shape2, newBounds, {
        initialShape,
        type: this.transformType,
        scaleX: newBounds.scaleX,
        scaleY: newBounds.scaleY,
        transformOrigin: [0.5, 0.5]
      });
      if (afterShape) {
        shapes[shape2.id] = afterShape;
      }
      if (showGrid && afterShape && afterShape.point) {
        afterShape.point = Vec.snap(afterShape.point, currentGrid);
      }
      return {
        appState: {
          snapLines
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes
            }
          }
        }
      };
    };
    this.cancel = () => {
      const {
        initialShape,
        app: { currentPageId }
      } = this;
      const shapes = {};
      if (this.isCreate) {
        shapes[initialShape.id] = void 0;
      } else {
        shapes[initialShape.id] = initialShape;
      }
      return {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId]: {
              shapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: this.isCreate ? [] : [initialShape.id]
            }
          }
        }
      };
    };
    this.complete = () => {
      const {
        initialShape,
        app: { currentPageId }
      } = this;
      if (initialShape.isLocked)
        return;
      const beforeShapes = {};
      const afterShapes = {};
      beforeShapes[initialShape.id] = this.isCreate ? void 0 : initialShape;
      afterShapes[initialShape.id] = TLDR.onSessionComplete(this.app.getShape(initialShape.id));
      return {
        id: "transform_single",
        before: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId]: {
                shapes: beforeShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: this.isCreate ? [] : [initialShape.id],
                editingId: void 0,
                hoveredId: void 0
              }
            }
          }
        },
        after: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId]: {
                shapes: afterShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: [initialShape.id],
                editingId: void 0,
                hoveredId: void 0
              }
            }
          }
        }
      };
    };
    this.isCreate = isCreate;
    this.transformType = transformType;
    const shape = this.app.getShape(id);
    this.initialShape = shape;
    this.initialShapeBounds = TLDR.getBounds(shape);
    this.initialCommonBounds = TLDR.getRotatedBounds(shape);
    this.app.rotationInfo.selectedIds = [shape.id];
  }
};
var TranslateSession = class extends BaseSession {
  constructor(app, isCreate = false, link = false) {
    super(app);
    this.type = SessionType.Translate;
    this.status = TDStatus.Translating;
    this.delta = [0, 0];
    this.prev = [0, 0];
    this.prevPoint = [0, 0];
    this.speed = 1;
    this.cloneInfo = {
      state: "empty"
    };
    this.snapInfo = {
      state: "empty"
    };
    this.snapLines = [];
    this.isCloning = false;
    this.start = () => {
      const {
        bindingsToDelete,
        initialIds,
        app: { currentPageId: currentPageId2, page: page2 }
      } = this;
      const allBounds = [];
      const otherBounds = [];
      Object.values(page2.shapes).forEach((shape) => {
        const bounds = Utils.getBoundsWithCenter(TLDR.getRotatedBounds(shape));
        allBounds.push(bounds);
        if (!initialIds.has(shape.id)) {
          otherBounds.push(bounds);
        }
      });
      this.snapInfo = {
        state: "ready",
        bounds: allBounds,
        others: otherBounds
      };
      if (bindingsToDelete.length === 0)
        return;
      const nextBindings = {};
      bindingsToDelete.forEach((binding) => nextBindings[binding.id] = void 0);
      return {
        document: {
          pages: {
            [currentPageId2]: {
              bindings: nextBindings
            }
          }
        }
      };
    };
    this.update = () => {
      const {
        initialParentChildren,
        initialShapes,
        initialCommonBounds,
        bindingsToDelete,
        app: {
          pageState: { camera },
          settings: { isSnapping, showGrid },
          currentPageId: currentPageId2,
          viewport,
          selectedIds: selectedIds2,
          currentPoint,
          previousPoint,
          originPoint,
          altKey,
          shiftKey,
          metaKey,
          currentGrid
        }
      } = this;
      const nextBindings = {};
      const nextShapes = {};
      const nextPageState = {};
      let delta = Vec.sub(currentPoint, originPoint);
      let didChangeCloning = false;
      if (!this.isCreate) {
        if (altKey && !this.isCloning) {
          this.isCloning = true;
          didChangeCloning = true;
        } else if (!altKey && this.isCloning) {
          this.isCloning = false;
          didChangeCloning = true;
        }
      }
      if (shiftKey) {
        if (Math.abs(delta[0]) < Math.abs(delta[1])) {
          delta[0] = 0;
        } else {
          delta[1] = 0;
        }
      }
      const speed = Vec.dist(currentPoint, previousPoint);
      const change = speed - this.speed;
      this.speed = this.speed + change * (change > 1 ? 0.5 : 0.15);
      this.snapLines = [];
      if ((isSnapping && !metaKey || !isSnapping && metaKey) && this.speed * camera.zoom < SLOW_SPEED && this.snapInfo.state === "ready") {
        const snapResult = Utils.getSnapPoints(Utils.getBoundsWithCenter(showGrid ? Utils.snapBoundsToGrid(Utils.translateBounds(initialCommonBounds, delta), currentGrid) : Utils.translateBounds(initialCommonBounds, delta)), (this.isCloning ? this.snapInfo.bounds : this.snapInfo.others).filter((bounds) => Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds)), SNAP_DISTANCE / camera.zoom);
        if (snapResult) {
          this.snapLines = snapResult.snapLines;
          delta = Vec.sub(delta, snapResult.offset);
        }
      }
      this.prev = delta;
      if (this.isCloning) {
        if (didChangeCloning) {
          if (this.cloneInfo.state === "empty") {
            this.createCloneInfo();
          }
          if (this.cloneInfo.state === "empty") {
            throw Error;
          }
          const { clones, clonedBindings } = this.cloneInfo;
          this.isCloning = true;
          bindingsToDelete.forEach((binding) => nextBindings[binding.id] = binding);
          initialShapes.forEach((shape) => nextShapes[shape.id] = { point: shape.point });
          clones.forEach((clone) => {
            var _a2;
            nextShapes[clone.id] = __spreadValues4({}, clone);
            if (clone.parentId !== currentPageId2 && !selectedIds2.includes(clone.parentId)) {
              const children = ((_a2 = nextShapes[clone.parentId]) == null ? void 0 : _a2.children) || initialParentChildren[clone.parentId];
              if (!children.includes(clone.id)) {
                nextShapes[clone.parentId] = __spreadProps4(__spreadValues4({}, nextShapes[clone.parentId]), {
                  children: [...children, clone.id]
                });
              }
            }
          });
          for (const binding of clonedBindings) {
            nextBindings[binding.id] = binding;
          }
          nextPageState.selectedIds = clones.map((clone) => clone.id);
          clones.forEach((clone) => {
            nextShapes[clone.id] = __spreadProps4(__spreadValues4({}, clone), {
              point: showGrid ? Vec.snap(Vec.toFixed(Vec.add(clone.point, delta)), currentGrid) : Vec.toFixed(Vec.add(clone.point, delta))
            });
          });
        } else {
          if (this.cloneInfo.state === "empty")
            throw Error;
          const { clones } = this.cloneInfo;
          clones.forEach((clone) => {
            nextShapes[clone.id] = {
              point: showGrid ? Vec.snap(Vec.toFixed(Vec.add(clone.point, delta)), currentGrid) : Vec.toFixed(Vec.add(clone.point, delta))
            };
          });
        }
      } else {
        if (didChangeCloning) {
          if (this.cloneInfo.state === "empty")
            throw Error;
          const { clones, clonedBindings } = this.cloneInfo;
          this.isCloning = false;
          bindingsToDelete.forEach((binding) => nextBindings[binding.id] = void 0);
          clones.forEach((clone) => {
            if (clone.parentId !== currentPageId2) {
              nextShapes[clone.parentId] = __spreadProps4(__spreadValues4({}, nextShapes[clone.parentId]), {
                children: initialParentChildren[clone.parentId]
              });
            }
          });
          clones.forEach((clone) => nextShapes[clone.id] = void 0);
          initialShapes.forEach((shape) => {
            nextShapes[shape.id] = {
              point: showGrid ? Vec.snap(Vec.toFixed(Vec.add(shape.point, delta)), currentGrid) : Vec.toFixed(Vec.add(shape.point, delta))
            };
          });
          for (const binding of clonedBindings) {
            nextBindings[binding.id] = void 0;
          }
          nextPageState.selectedIds = initialShapes.map((shape) => shape.id);
        } else {
          initialShapes.forEach((shape) => {
            nextShapes[shape.id] = {
              point: showGrid ? Vec.snap(Vec.toFixed(Vec.add(shape.point, delta)), currentGrid) : Vec.toFixed(Vec.add(shape.point, delta))
            };
          });
        }
      }
      return {
        appState: {
          snapLines: this.snapLines
        },
        document: {
          pages: {
            [currentPageId2]: {
              shapes: nextShapes,
              bindings: nextBindings
            }
          },
          pageStates: {
            [currentPageId2]: nextPageState
          }
        }
      };
    };
    this.cancel = () => {
      const {
        initialShapes,
        initialSelectedIds,
        bindingsToDelete,
        app: { currentPageId: currentPageId2 }
      } = this;
      const nextBindings = {};
      const nextShapes = {};
      const nextPageState = {
        editingId: void 0,
        hoveredId: void 0
      };
      bindingsToDelete.forEach((binding) => nextBindings[binding.id] = binding);
      if (this.isCreate) {
        initialShapes.forEach(({ id }) => nextShapes[id] = void 0);
        nextPageState.selectedIds = [];
      } else {
        initialShapes.forEach(({ id, point }) => nextShapes[id] = __spreadProps4(__spreadValues4({}, nextShapes[id]), { point }));
        nextPageState.selectedIds = initialSelectedIds;
      }
      if (this.cloneInfo.state === "ready") {
        const { clones, clonedBindings } = this.cloneInfo;
        clones.forEach((clone) => nextShapes[clone.id] = void 0);
        clonedBindings.forEach((binding) => nextBindings[binding.id] = void 0);
      }
      return {
        appState: {
          snapLines: []
        },
        document: {
          pages: {
            [currentPageId2]: {
              shapes: nextShapes,
              bindings: nextBindings
            }
          },
          pageStates: {
            [currentPageId2]: nextPageState
          }
        }
      };
    };
    this.complete = () => {
      const {
        initialShapes,
        initialParentChildren,
        bindingsToDelete,
        app: { currentPageId: currentPageId2 }
      } = this;
      const beforeBindings = {};
      const beforeShapes = {};
      const afterBindings = {};
      const afterShapes = {};
      if (this.isCloning) {
        if (this.cloneInfo.state === "empty") {
          this.createCloneInfo();
        }
        if (this.cloneInfo.state !== "ready")
          throw Error;
        const { clones, clonedBindings } = this.cloneInfo;
        clones.forEach((clone) => {
          beforeShapes[clone.id] = void 0;
          afterShapes[clone.id] = this.app.getShape(clone.id);
          if (clone.parentId !== currentPageId2) {
            beforeShapes[clone.parentId] = __spreadProps4(__spreadValues4({}, beforeShapes[clone.parentId]), {
              children: initialParentChildren[clone.parentId]
            });
            afterShapes[clone.parentId] = __spreadProps4(__spreadValues4({}, afterShapes[clone.parentId]), {
              children: this.app.getShape(clone.parentId).children
            });
          }
        });
        clonedBindings.forEach((binding) => {
          beforeBindings[binding.id] = void 0;
          afterBindings[binding.id] = this.app.getBinding(binding.id);
        });
      } else {
        initialShapes.forEach((shape) => {
          beforeShapes[shape.id] = this.isCreate ? void 0 : __spreadProps4(__spreadValues4({}, beforeShapes[shape.id]), {
            point: shape.point
          });
          afterShapes[shape.id] = __spreadValues4(__spreadValues4({}, afterShapes[shape.id]), this.isCreate ? this.app.getShape(shape.id) : { point: this.app.getShape(shape.id).point });
        });
      }
      bindingsToDelete.forEach((binding) => {
        beforeBindings[binding.id] = binding;
        for (const id of [binding.toId, binding.fromId]) {
          const shape = this.app.getShape(id);
          if (!shape.handles)
            continue;
          Object.values(shape.handles).filter((handle) => handle.bindingId === binding.id).forEach((handle) => {
            beforeShapes[id] = __spreadProps4(__spreadValues4({}, beforeShapes[id]), { handles: {} });
            afterShapes[id] = __spreadProps4(__spreadValues4({}, afterShapes[id]), { handles: {} });
            beforeShapes[id].handles[handle.id] = {
              bindingId: binding.id
            };
            afterShapes[id].handles[handle.id] = {
              bindingId: void 0
            };
          });
        }
      });
      return {
        id: "translate",
        before: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId2]: {
                shapes: beforeShapes,
                bindings: beforeBindings
              }
            },
            pageStates: {
              [currentPageId2]: {
                selectedIds: this.isCreate ? [] : [...this.initialSelectedIds]
              }
            }
          }
        },
        after: {
          appState: {
            snapLines: []
          },
          document: {
            pages: {
              [currentPageId2]: {
                shapes: afterShapes,
                bindings: afterBindings
              }
            },
            pageStates: {
              [currentPageId2]: {
                selectedIds: [...this.app.selectedIds]
              }
            }
          }
        }
      };
    };
    this.createCloneInfo = () => {
      const {
        initialShapes,
        initialParentChildren,
        app: { selectedIds: selectedIds2, currentPageId: currentPageId2, page: page2 }
      } = this;
      const cloneMap = {};
      const clonedBindingsMap = {};
      const clonedBindings = [];
      const clones = [];
      initialShapes.forEach((shape) => {
        const newId = Utils.uniqueId();
        initialParentChildren[newId] = initialParentChildren[shape.id];
        cloneMap[shape.id] = newId;
        const clone = __spreadProps4(__spreadValues4({}, Utils.deepClone(shape)), {
          id: newId,
          parentId: shape.parentId,
          childIndex: TLDR.getChildIndexAbove(this.app.state, shape.id, currentPageId2)
        });
        clones.push(clone);
      });
      clones.forEach((clone) => {
        if (clone.children !== void 0) {
          clone.children = clone.children.map((childId) => cloneMap[childId]);
        }
      });
      clones.forEach((clone) => {
        if (selectedIds2.includes(clone.parentId)) {
          clone.parentId = cloneMap[clone.parentId];
        }
      });
      const clonedShapeIds = new Set(Object.keys(cloneMap));
      Object.values(page2.bindings).filter((binding) => clonedShapeIds.has(binding.fromId) || clonedShapeIds.has(binding.toId)).forEach((binding) => {
        if (clonedShapeIds.has(binding.fromId)) {
          if (clonedShapeIds.has(binding.toId)) {
            const cloneId = Utils.uniqueId();
            const cloneBinding = __spreadProps4(__spreadValues4({}, Utils.deepClone(binding)), {
              id: cloneId,
              fromId: cloneMap[binding.fromId] || binding.fromId,
              toId: cloneMap[binding.toId] || binding.toId
            });
            clonedBindingsMap[binding.id] = cloneId;
            clonedBindings.push(cloneBinding);
          }
        }
      });
      clones.forEach((clone) => {
        if (clone.handles) {
          if (clone.handles) {
            for (const id in clone.handles) {
              const handle = clone.handles[id];
              handle.bindingId = handle.bindingId ? clonedBindingsMap[handle.bindingId] : void 0;
            }
          }
        }
      });
      clones.forEach((clone) => {
        if (page2.shapes[clone.id]) {
          throw Error("uh oh, we didn't clone correctly");
        }
      });
      this.cloneInfo = {
        state: "ready",
        clones,
        cloneMap,
        clonedBindings
      };
    };
    this.isCreate = isCreate;
    this.link = link;
    const { currentPageId, selectedIds, page } = this.app;
    this.initialSelectedIds = [...selectedIds];
    const selectedShapes = (link ? TLDR.getLinkedShapeIds(this.app.state, currentPageId, link, false) : selectedIds).map((id) => this.app.getShape(id)).filter((shape) => !shape.isLocked);
    const selectedShapeIds = new Set(selectedShapes.map((shape) => shape.id));
    this.hasUnlockedShapes = selectedShapes.length > 0;
    this.initialShapes = Array.from(new Set(selectedShapes.filter((shape) => !selectedShapeIds.has(shape.parentId)).flatMap((shape) => {
      return shape.children ? [shape, ...shape.children.map((childId) => this.app.getShape(childId))] : [shape];
    })).values());
    this.initialIds = new Set(this.initialShapes.map((shape) => shape.id));
    this.bindingsToDelete = [];
    Object.values(page.bindings).filter((binding) => this.initialIds.has(binding.fromId) || this.initialIds.has(binding.toId)).forEach((binding) => {
      if (this.initialIds.has(binding.fromId)) {
        if (!this.initialIds.has(binding.toId)) {
          this.bindingsToDelete.push(binding);
        }
      }
    });
    this.initialParentChildren = {};
    this.initialShapes.map((s8) => s8.parentId).filter((id) => id !== page.id).forEach((id) => {
      this.initialParentChildren[id] = this.app.getShape(id).children;
    });
    this.initialCommonBounds = Utils.getCommonBounds(this.initialShapes.map(TLDR.getRotatedBounds));
    this.app.rotationInfo.selectedIds = [...this.app.selectedIds];
  }
};
var EraseSession = class extends BaseSession {
  constructor(app) {
    super(app);
    this.type = SessionType.Draw;
    this.status = TDStatus.Creating;
    this.erasedShapes = new Set();
    this.erasedBindings = new Set();
    this.start = () => void 0;
    this.update = () => {
      const { page, shiftKey, originPoint, currentPoint } = this.app;
      if (shiftKey) {
        if (!this.isLocked && Vec.dist(originPoint, currentPoint) > 4) {
          if (!this.lockedDirection) {
            const delta = Vec.sub(currentPoint, originPoint);
            this.lockedDirection = delta[0] > delta[1] ? "horizontal" : "vertical";
          }
          this.isLocked = true;
        }
      } else if (this.isLocked) {
        this.isLocked = false;
      }
      if (this.isLocked) {
        if (this.lockedDirection === "vertical") {
          currentPoint[0] = originPoint[0];
        } else {
          currentPoint[1] = originPoint[1];
        }
      }
      const newPoint = Vec.toFixed(Vec.add(originPoint, Vec.sub(currentPoint, originPoint)));
      const deletedShapeIds = new Set([]);
      for (const shape of this.erasableShapes) {
        if (this.erasedShapes.has(shape))
          continue;
        if (this.app.getShapeUtil(shape).hitTestLineSegment(shape, this.prevPoint, newPoint)) {
          this.erasedShapes.add(shape);
          deletedShapeIds.add(shape.id);
          if (shape.children !== void 0) {
            for (const childId of shape.children) {
              this.erasedShapes.add(this.app.getShape(childId));
              deletedShapeIds.add(childId);
            }
          }
        }
      }
      Object.values(page.bindings).forEach((binding) => {
        for (const id of [binding.toId, binding.fromId]) {
          if (deletedShapeIds.has(id)) {
            this.erasedBindings.add(binding);
          }
        }
      });
      const erasedShapes = Array.from(this.erasedShapes.values());
      this.prevPoint = newPoint;
      return {
        document: {
          pages: {
            [page.id]: {
              shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: true }]))
            }
          }
        }
      };
    };
    this.cancel = () => {
      const { page } = this.app;
      const erasedShapes = Array.from(this.erasedShapes.values());
      return {
        document: {
          pages: {
            [page.id]: {
              shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, { isGhost: false }]))
            }
          },
          pageStates: {
            [page.id]: {
              selectedIds: this.initialSelectedShapes.map((shape) => shape.id)
            }
          }
        }
      };
    };
    this.complete = () => {
      const { page } = this.app;
      const erasedShapes = Array.from(this.erasedShapes.values());
      const erasedBindings = Array.from(this.erasedBindings.values());
      const erasedShapeIds = erasedShapes.map((shape) => shape.id);
      const erasedBindingIds = erasedBindings.map((binding) => binding.id);
      const before = {
        shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, shape])),
        bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, binding]))
      };
      const after = {
        shapes: Object.fromEntries(erasedShapes.map((shape) => [shape.id, void 0])),
        bindings: Object.fromEntries(erasedBindings.map((binding) => [binding.id, void 0]))
      };
      this.app.shapes.forEach((shape) => {
        if (shape.handles && !after.shapes[shape.id]) {
          Object.values(shape.handles).forEach((handle) => {
            var _a2, _b;
            if (handle.bindingId && erasedBindingIds.includes(handle.bindingId)) {
              before.shapes[shape.id] = __spreadProps4(__spreadValues4({}, before.shapes[shape.id]), {
                handles: __spreadProps4(__spreadValues4({}, (_a2 = before.shapes[shape.id]) == null ? void 0 : _a2.handles), {
                  [handle.id]: handle
                })
              });
              if (!erasedShapeIds.includes(shape.id)) {
                after.shapes[shape.id] = __spreadProps4(__spreadValues4({}, after.shapes[shape.id]), {
                  handles: __spreadProps4(__spreadValues4({}, (_b = after.shapes[shape.id]) == null ? void 0 : _b.handles), {
                    [handle.id]: __spreadProps4(__spreadValues4({}, handle), {
                      bindingId: void 0
                    })
                  })
                });
              }
            }
          });
        }
      });
      return {
        id: "erase",
        before: {
          document: {
            pages: {
              [page.id]: before
            },
            pageStates: {
              [page.id]: {
                selectedIds: this.initialSelectedShapes.map((shape) => shape.id)
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [page.id]: after
            },
            pageStates: {
              [page.id]: {
                selectedIds: this.initialSelectedShapes.filter((shape) => !erasedShapeIds.includes(shape.id)).map((shape) => shape.id)
              }
            }
          }
        }
      };
    };
    this.prevPoint = [...app.originPoint];
    this.initialSelectedShapes = this.app.selectedIds.map((id) => this.app.getShape(id));
    this.erasableShapes = this.app.shapes.filter((shape) => !shape.isLocked);
  }
};
var GridSession = class extends BaseSession {
  constructor(app, id) {
    super(app);
    this.type = SessionType.Grid;
    this.status = TDStatus.Translating;
    this.grid = {};
    this.columns = 1;
    this.rows = 1;
    this.isCopying = false;
    this.start = () => void 0;
    this.update = () => {
      const { currentPageId, altKey, shiftKey, currentPoint } = this.app;
      const nextShapes = {};
      const nextPageState = {};
      const center = Utils.getBoundsCenter(this.bounds);
      const offset = Vec.sub(currentPoint, center);
      if (shiftKey) {
        if (Math.abs(offset[0]) < Math.abs(offset[1])) {
          offset[0] = 0;
        } else {
          offset[1] = 0;
        }
      }
      const gapX = this.bounds.width + 32;
      const gapY = this.bounds.height + 32;
      const columns = Math.ceil(offset[0] / gapX);
      const rows = Math.ceil(offset[1] / gapY);
      const minX = Math.min(columns, 0);
      const minY = Math.min(rows, 0);
      const maxX = Math.max(columns, 1);
      const maxY = Math.max(rows, 1);
      const inGrid = new Set();
      const isCopying = altKey;
      if (isCopying !== this.isCopying) {
        Object.values(this.grid).filter((id2) => id2 !== this.shape.id).forEach((id2) => nextShapes[id2] = void 0);
        this.grid = { "0_0": this.shape.id };
        this.isCopying = isCopying;
      }
      for (let x5 = minX; x5 < maxX; x5++) {
        for (let y4 = minY; y4 < maxY; y4++) {
          const position = `${x5}_${y4}`;
          inGrid.add(position);
          if (this.grid[position])
            continue;
          if (x5 === 0 && y4 === 0)
            continue;
          const clone = this.getClone(Vec.add(this.shape.point, [x5 * gapX, y4 * gapY]), isCopying);
          nextShapes[clone.id] = clone;
          this.grid[position] = clone.id;
        }
      }
      Object.entries(this.grid).forEach(([position, id2]) => {
        if (!inGrid.has(position)) {
          nextShapes[id2] = void 0;
          delete this.grid[position];
        }
      });
      if (Object.values(nextShapes).length === 0)
        return;
      if (this.initialSiblings) {
        nextShapes[this.shape.parentId] = {
          children: [...this.initialSiblings, ...Object.values(this.grid)]
        };
      }
      return {
        document: {
          pages: {
            [currentPageId]: {
              shapes: nextShapes
            }
          },
          pageStates: {
            [currentPageId]: nextPageState
          }
        }
      };
    };
    this.cancel = () => {
      const { currentPageId } = this.app;
      const nextShapes = {};
      Object.values(this.grid).forEach((id2) => {
        nextShapes[id2] = void 0;
      });
      nextShapes[this.shape.id] = __spreadProps4(__spreadValues4({}, nextShapes[this.shape.id]), { point: this.shape.point });
      if (this.initialSiblings) {
        nextShapes[this.shape.parentId] = {
          children: [...this.initialSiblings, this.shape.id]
        };
      }
      return {
        document: {
          pages: {
            [currentPageId]: {
              shapes: nextShapes
            }
          },
          pageStates: {
            [currentPageId]: {
              selectedIds: [this.shape.id]
            }
          }
        }
      };
    };
    this.complete = () => {
      const { currentPageId } = this.app;
      const beforeShapes = {};
      const afterShapes = {};
      const afterSelectedIds = [];
      Object.values(this.grid).forEach((id2) => {
        beforeShapes[id2] = void 0;
        afterShapes[id2] = this.app.getShape(id2);
        afterSelectedIds.push(id2);
      });
      beforeShapes[this.shape.id] = this.shape;
      if (this.initialSiblings) {
        beforeShapes[this.shape.parentId] = {
          children: [...this.initialSiblings, this.shape.id]
        };
        afterShapes[this.shape.parentId] = {
          children: [...this.initialSiblings, ...Object.values(this.grid)]
        };
      }
      if (afterSelectedIds.length === 1)
        return;
      return {
        id: "grid",
        before: {
          document: {
            pages: {
              [currentPageId]: {
                shapes: beforeShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: [],
                hoveredId: void 0
              }
            }
          }
        },
        after: {
          document: {
            pages: {
              [currentPageId]: {
                shapes: afterShapes
              }
            },
            pageStates: {
              [currentPageId]: {
                selectedIds: afterSelectedIds,
                hoveredId: void 0
              }
            }
          }
        }
      };
    };
    this.getClone = (point, copy) => {
      const clone = __spreadProps4(__spreadValues4({}, this.shape), {
        id: Utils.uniqueId(),
        point
      });
      if (!copy) {
        if (clone.type === TDShapeType.Sticky) {
          clone.text = "";
        }
      }
      return clone;
    };
    var _a2;
    this.shape = this.app.getShape(id);
    this.grid["0_0"] = this.shape.id;
    this.bounds = this.app.getShapeBounds(id);
    this.initialSelectedIds = [...this.app.selectedIds];
    if (this.shape.parentId !== this.app.currentPageId) {
      this.initialSiblings = (_a2 = this.app.getShape(this.shape.parentId).children) == null ? void 0 : _a2.filter((id2) => id2 !== this.shape.id);
    }
  }
};
var sessions = {
  [SessionType.Arrow]: ArrowSession,
  [SessionType.Brush]: BrushSession,
  [SessionType.Draw]: DrawSession,
  [SessionType.Erase]: EraseSession,
  [SessionType.Handle]: HandleSession,
  [SessionType.Rotate]: RotateSession,
  [SessionType.Transform]: TransformSession,
  [SessionType.TransformSingle]: TransformSingleSession,
  [SessionType.Translate]: TranslateSession,
  [SessionType.Grid]: GridSession
};
var getSession = (type) => {
  return sessions[type];
};
var Status;
(function(Status4) {
  Status4["Idle"] = "idle";
  Status4["Creating"] = "creating";
  Status4["Pinching"] = "pinching";
})(Status || (Status = {}));
var BaseTool = class extends TDEventHandler {
  constructor(app) {
    super();
    this.app = app;
    this.type = "select";
    this.status = Status.Idle;
    this.setStatus = (status) => {
      this.status = status;
      this.app.setStatus(this.status);
    };
    this.onEnter = () => {
      this.setStatus(Status.Idle);
    };
    this.onExit = () => {
      this.setStatus(Status.Idle);
    };
    this.onCancel = () => {
      if (this.status === Status.Idle) {
        this.app.selectTool("select");
      } else {
        this.setStatus(Status.Idle);
      }
      this.app.cancelSession();
    };
    this.getNextChildIndex = () => {
      const {
        shapes,
        appState: { currentPageId }
      } = this.app;
      return shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a9, b7) => b7.childIndex - a9.childIndex)[0].childIndex + 1;
    };
    this.onPinchStart = () => {
      this.app.cancelSession();
      this.setStatus(Status.Pinching);
    };
    this.onPinchEnd = () => {
      if (Utils.isMobileSafari()) {
        this.app.undoSelect();
      }
      this.setStatus(Status.Idle);
    };
    this.onPinch = (info, e12) => {
      var _a2;
      if (this.status !== "pinching")
        return;
      this.app.pinchZoom(info.point, info.delta, info.delta[2]);
      (_a2 = this.onPointerMove) == null ? void 0 : _a2.call(this, info, e12);
    };
    this.onKeyDown = (key) => {
      if (key === "Escape") {
        this.onCancel();
        return;
      }
      if (key === "Meta" || key === "Control" || key === "Alt") {
        this.app.updateSession();
        return;
      }
    };
    this.onKeyUp = (key) => {
      if (key === "Meta" || key === "Control" || key === "Alt") {
        this.app.updateSession();
        return;
      }
    };
    this.onPointerMove = () => {
      if (this.status === Status.Creating) {
        this.app.updateSession();
      }
    };
    this.onPointerUp = () => {
      if (this.status === Status.Creating) {
        this.app.completeSession();
        const { isToolLocked } = this.app.appState;
        if (!isToolLocked) {
          this.app.selectTool("select");
        }
      }
      this.setStatus(Status.Idle);
    };
  }
};
var Status2;
(function(Status4) {
  Status4["Idle"] = "idle";
  Status4["Creating"] = "creating";
  Status4["Pinching"] = "pinching";
  Status4["PointingCanvas"] = "pointingCanvas";
  Status4["PointingHandle"] = "pointingHandle";
  Status4["PointingBounds"] = "pointingBounds";
  Status4["PointingClone"] = "pointingClone";
  Status4["TranslatingClone"] = "translatingClone";
  Status4["PointingBoundsHandle"] = "pointingBoundsHandle";
  Status4["TranslatingHandle"] = "translatingHandle";
  Status4["Translating"] = "translating";
  Status4["Transforming"] = "transforming";
  Status4["Rotating"] = "rotating";
  Status4["Brushing"] = "brushing";
  Status4["GridCloning"] = "gridCloning";
  Status4["ClonePainting"] = "clonePainting";
  Status4["SpacePanning"] = "spacePanning";
  Status4["MiddleWheelPanning"] = "middleWheelPanning";
})(Status2 || (Status2 = {}));
var SelectTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = "select";
    this.onEnter = () => {
      this.setStatus(Status2.Idle);
    };
    this.onExit = () => {
      this.setStatus(Status2.Idle);
    };
    this.clonePaint = (point) => {
      if (this.app.selectedIds.length === 0)
        return;
      const shapes = this.app.selectedIds.map((id) => this.app.getShape(id));
      const bounds = Utils.expandBounds(Utils.getCommonBounds(shapes.map(TLDR.getBounds)), 16);
      const center = Utils.getBoundsCenter(bounds);
      const size = [bounds.width, bounds.height];
      const gridPoint = [
        center[0] + size[0] * Math.floor((point[0] + size[0] / 2 - center[0]) / size[0]),
        center[1] + size[1] * Math.floor((point[1] + size[1] / 2 - center[1]) / size[1])
      ];
      const centeredBounds = Utils.centerBounds(bounds, gridPoint);
      const hit = this.app.shapes.some((shape) => TLDR.getShapeUtil(shape).hitTestBounds(shape, centeredBounds));
      if (!hit) {
        this.app.duplicate(this.app.selectedIds, gridPoint);
      }
    };
    this.getShapeClone = (id, side) => {
      const shape = this.app.getShape(id);
      const utils = TLDR.getShapeUtil(shape);
      if (utils.canClone) {
        const bounds = utils.getBounds(shape);
        const center = utils.getCenter(shape);
        let point = {
          top: [bounds.minX, bounds.minY - (bounds.height + CLONING_DISTANCE)],
          right: [bounds.maxX + CLONING_DISTANCE, bounds.minY],
          bottom: [bounds.minX, bounds.maxY + CLONING_DISTANCE],
          left: [bounds.minX - (bounds.width + CLONING_DISTANCE), bounds.minY],
          topLeft: [
            bounds.minX - (bounds.width + CLONING_DISTANCE),
            bounds.minY - (bounds.height + CLONING_DISTANCE)
          ],
          topRight: [
            bounds.maxX + CLONING_DISTANCE,
            bounds.minY - (bounds.height + CLONING_DISTANCE)
          ],
          bottomLeft: [
            bounds.minX - (bounds.width + CLONING_DISTANCE),
            bounds.maxY + CLONING_DISTANCE
          ],
          bottomRight: [bounds.maxX + CLONING_DISTANCE, bounds.maxY + CLONING_DISTANCE]
        }[side];
        if (shape.rotation !== 0) {
          const newCenter = src_default.add(point, [bounds.width / 2, bounds.height / 2]);
          const rotatedCenter = src_default.rotWith(newCenter, center, shape.rotation || 0);
          point = src_default.sub(rotatedCenter, [bounds.width / 2, bounds.height / 2]);
        }
        const id2 = Utils.uniqueId();
        const clone = __spreadProps4(__spreadValues4({}, shape), {
          id: id2,
          point
        });
        if (clone.type === TDShapeType.Sticky) {
          clone.text = "";
        }
        return clone;
      }
      return;
    };
    this.onCancel = () => {
      this.selectNone();
      this.app.cancelSession();
      this.setStatus(Status2.Idle);
    };
    this.onKeyDown = (key) => {
      if (key === "Escape") {
        this.onCancel();
        return;
      }
      if (key === " " && this.status === Status2.Idle) {
        this.setStatus(Status2.SpacePanning);
      }
      if (key === "Tab") {
        if (this.status === Status2.Idle && this.app.selectedIds.length === 1) {
          const [selectedId] = this.app.selectedIds;
          const clonedShape = this.getShapeClone(selectedId, "right");
          if (clonedShape) {
            this.app.createShapes(clonedShape);
            this.setStatus(Status2.Idle);
            if (clonedShape.type === TDShapeType.Sticky) {
              this.app.select(clonedShape.id);
              this.app.setEditingId(clonedShape.id);
            }
          }
        }
        return;
      }
      if (key === "Meta" || key === "Control" || key === "Alt") {
        this.app.updateSession();
        return;
      }
    };
    this.onKeyUp = (key, info) => {
      if (this.status === Status2.ClonePainting && !(info.altKey && info.shiftKey)) {
        this.setStatus(Status2.Idle);
        return;
      }
      if (this.status === Status2.SpacePanning && key === " ") {
        this.setStatus(Status2.Idle);
        return;
      }
      if (key === "Meta" || key === "Control" || key === "Alt") {
        this.app.updateSession();
        return;
      }
    };
    this.onPointerMove = (info, e12) => {
      var _a2, _b;
      const { originPoint, currentPoint } = this.app;
      if (this.status === Status2.SpacePanning && e12.buttons === 1 || this.status === Status2.MiddleWheelPanning && e12.buttons === 4) {
        (_b = (_a2 = this.app).onPan) == null ? void 0 : _b.call(_a2, __spreadProps4(__spreadValues4({}, info), { delta: src_default.neg(info.delta) }), e12);
        return;
      }
      if (this.status === Status2.PointingBoundsHandle) {
        if (!this.pointedBoundsHandle)
          throw Error("No pointed bounds handle");
        if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
          if (this.pointedBoundsHandle === "rotate") {
            this.setStatus(Status2.Rotating);
            this.app.startSession(SessionType.Rotate);
          } else if (this.pointedBoundsHandle === "center" || this.pointedBoundsHandle === "left" || this.pointedBoundsHandle === "right") {
            this.setStatus(Status2.Translating);
            this.app.startSession(SessionType.Translate, false, this.pointedBoundsHandle);
          } else {
            this.setStatus(Status2.Transforming);
            const idsToTransform = this.app.selectedIds.flatMap((id) => TLDR.getDocumentBranch(this.app.state, id, this.app.currentPageId));
            if (idsToTransform.length === 1) {
              this.app.startSession(SessionType.TransformSingle, idsToTransform[0], this.pointedBoundsHandle);
            } else {
              this.app.startSession(SessionType.Transform, this.pointedBoundsHandle);
            }
          }
          this.app.updateSession();
        }
        return;
      }
      if (this.status === Status2.PointingCanvas) {
        if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.app.startSession(SessionType.Brush);
          this.setStatus(Status2.Brushing);
        }
        return;
      }
      if (this.status === Status2.PointingClone) {
        if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.setStatus(Status2.TranslatingClone);
          this.app.startSession(SessionType.Translate);
          this.app.updateSession();
        }
        return;
      }
      if (this.status === Status2.PointingBounds) {
        if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.setStatus(Status2.Translating);
          this.app.startSession(SessionType.Translate);
          this.app.updateSession();
        }
        return;
      }
      if (this.status === Status2.PointingHandle) {
        if (!this.pointedHandleId)
          throw Error("No pointed handle");
        if (src_default.dist(originPoint, currentPoint) > DEAD_ZONE) {
          this.setStatus(Status2.TranslatingHandle);
          const selectedShape = this.app.getShape(this.app.selectedIds[0]);
          if (!selectedShape)
            return;
          if (this.pointedHandleId === "bend") {
            this.app.startSession(SessionType.Handle, selectedShape.id, this.pointedHandleId);
            this.app.updateSession();
          } else {
            this.app.startSession(SessionType.Arrow, selectedShape.id, this.pointedHandleId, false);
            this.app.updateSession();
          }
        }
        return;
      }
      if (this.app.session) {
        return this.app.updateSession();
      }
      if (this.status === Status2.ClonePainting) {
        this.clonePaint(currentPoint);
      }
      return;
    };
    this.onPointerDown = (info, e12) => {
      if (e12.buttons === 4) {
        this.setStatus(Status2.MiddleWheelPanning);
      }
      if (info.target === "canvas" && this.status === Status2.Idle) {
        const { currentPoint } = this.app;
        if (info.spaceKey && e12.buttons === 1)
          return;
        if (this.status === Status2.Idle && info.altKey && info.shiftKey) {
          this.setStatus(Status2.ClonePainting);
          this.clonePaint(currentPoint);
          return;
        }
        if (!info.shiftKey) {
          this.app.onShapeBlur();
          if (info.altKey && this.app.selectedIds.length > 0) {
            this.app.duplicate(this.app.selectedIds, currentPoint);
            return;
          }
          this.selectNone();
        }
        this.setStatus(Status2.PointingCanvas);
      }
    };
    this.onPointerUp = (info, e12) => {
      if (this.status === Status2.MiddleWheelPanning) {
        this.setStatus(Status2.Idle);
        return;
      }
      if (this.status === Status2.TranslatingClone || this.status === Status2.PointingClone) {
        if (this.pointedId) {
          this.app.completeSession();
          this.app.setEditingId(this.pointedId);
        }
        this.setStatus(Status2.Idle);
        this.pointedId = void 0;
        return;
      }
      if (this.status === Status2.PointingBounds) {
        if (info.target === "bounds") {
          this.selectNone();
        } else if (this.app.isSelected(info.target)) {
          if (info.shiftKey) {
            if (this.pointedId !== info.target) {
              this.deselect(info.target);
            }
          } else {
            if (this.pointedId !== info.target && this.app.selectedIds.length > 1) {
              this.select(info.target);
            }
          }
        } else if (this.pointedId === info.target) {
          if (this.app.getShape(info.target).isLocked)
            return;
          if (info.shiftKey) {
            this.pushSelect(info.target);
          } else {
            this.select(info.target);
          }
        }
      }
      this.app.completeSession();
      this.setStatus(Status2.Idle);
      this.pointedBoundsHandle = void 0;
      this.pointedHandleId = void 0;
      this.pointedId = void 0;
    };
    this.onDoubleClickCanvas = () => {
    };
    this.onPointShape = (info, e12) => {
      if (info.spaceKey && e12.buttons === 1)
        return;
      if (this.app.getShape(info.target).isLocked)
        return;
      const { editingId, hoveredId } = this.app.pageState;
      if (editingId && info.target !== editingId) {
        this.app.onShapeBlur();
      }
      if ((this.status === Status2.Idle || this.status === Status2.PointingBounds) && info.metaKey && info.shiftKey && hoveredId) {
        this.pointedId = hoveredId;
        if (this.app.isSelected(hoveredId)) {
          this.deselect(hoveredId);
        } else {
          this.pushSelect(hoveredId);
          this.setStatus(Status2.PointingBounds);
        }
        return;
      }
      if (this.status === Status2.PointingBounds) {
        const { parentId } = this.app.getShape(info.target);
        this.pointedId = parentId === this.app.currentPageId ? info.target : parentId;
        return;
      }
      if (this.status === Status2.Idle) {
        this.setStatus(Status2.PointingBounds);
        if (info.metaKey) {
          if (!info.shiftKey) {
            this.selectNone();
          }
          this.app.startSession(SessionType.Brush);
          this.setStatus(Status2.Brushing);
          return;
        }
        let shapeIdToSelect;
        const { parentId } = this.app.getShape(info.target);
        if (parentId === this.app.currentPageId) {
          shapeIdToSelect = info.target;
          this.selectedGroupId = void 0;
        } else {
          if (parentId === this.selectedGroupId) {
            shapeIdToSelect = info.target;
          } else {
            shapeIdToSelect = parentId;
            this.selectedGroupId = void 0;
          }
        }
        if (!this.app.isSelected(shapeIdToSelect)) {
          this.pointedId = shapeIdToSelect;
          if (info.shiftKey) {
            this.pushSelect(shapeIdToSelect);
          } else {
            this.select(shapeIdToSelect);
          }
        }
      }
    };
    this.onDoubleClickShape = (info) => {
      const shape = this.app.getShape(info.target);
      if (shape.isLocked) {
        this.app.select(info.target);
        return;
      }
      if (TLDR.getShapeUtil(shape.type).canEdit && (shape.parentId === this.app.currentPageId || shape.parentId === this.selectedGroupId)) {
        this.app.setEditingId(info.target);
      }
      if (shape.parentId !== this.app.currentPageId) {
        this.selectedGroupId = shape.parentId;
      }
      this.app.select(info.target);
    };
    this.onRightPointShape = (info) => {
      if (!this.app.isSelected(info.target)) {
        this.app.select(info.target);
      }
    };
    this.onHoverShape = (info) => {
      this.app.setHoveredId(info.target);
    };
    this.onUnhoverShape = (info) => {
      const { currentPageId: oldCurrentPageId } = this.app;
      requestAnimationFrame(() => {
        if (oldCurrentPageId === this.app.currentPageId && this.app.pageState.hoveredId === info.target) {
          this.app.setHoveredId(void 0);
        }
      });
    };
    this.onPointBounds = (info) => {
      if (info.metaKey) {
        if (!info.shiftKey) {
          this.selectNone();
        }
        this.app.startSession(SessionType.Brush);
        this.setStatus(Status2.Brushing);
        return;
      }
      this.setStatus(Status2.PointingBounds);
    };
    this.onRightPointBounds = (info, e12) => {
      e12.stopPropagation();
    };
    this.onReleaseBounds = () => {
      if (this.status === Status2.Translating || this.status === Status2.Brushing) {
        this.app.completeSession();
      }
      this.setStatus(Status2.Idle);
    };
    this.onPointBoundsHandle = (info) => {
      this.pointedBoundsHandle = info.target;
      this.setStatus(Status2.PointingBoundsHandle);
    };
    this.onDoubleClickBoundsHandle = (info) => {
      if (info.target === "center" || info.target === "left" || info.target === "right") {
        this.app.select(...TLDR.getLinkedShapeIds(this.app.state, this.app.currentPageId, info.target, info.shiftKey));
      }
      if (this.app.selectedIds.length === 1) {
        this.app.resetBounds(this.app.selectedIds);
      }
    };
    this.onReleaseBoundsHandle = () => {
      this.setStatus(Status2.Idle);
    };
    this.onPointHandle = (info) => {
      this.pointedHandleId = info.target;
      this.setStatus(Status2.PointingHandle);
    };
    this.onDoubleClickHandle = (info) => {
      this.app.toggleDecoration(info.target);
    };
    this.onReleaseHandle = () => {
      this.setStatus(Status2.Idle);
    };
    this.onShapeClone = (info) => {
      const selectedShapeId = this.app.selectedIds[0];
      const clonedShape = this.getShapeClone(selectedShapeId, info.target);
      if (info.target === "left" || info.target === "right" || info.target === "top" || info.target === "bottom") {
        if (clonedShape) {
          this.app.createShapes(clonedShape);
          this.pointedId = clonedShape.id;
          this.setStatus(Status2.PointingClone);
        }
      } else {
        this.setStatus(Status2.GridCloning);
        this.app.startSession(SessionType.Grid, selectedShapeId);
      }
    };
  }
  deselect(id) {
    this.app.select(...this.app.selectedIds.filter((oid) => oid !== id));
  }
  select(id) {
    this.app.select(id);
  }
  pushSelect(id) {
    const shape = this.app.getShape(id);
    this.app.select(...this.app.selectedIds.filter((oid) => oid !== shape.parentId), id);
  }
  selectNone() {
    this.app.selectNone();
  }
};
var Status3;
(function(Status4) {
  Status4["Idle"] = "idle";
  Status4["Pointing"] = "pointing";
  Status4["Erasing"] = "erasing";
})(Status3 || (Status3 = {}));
var EraseTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = "erase";
    this.status = Status3.Idle;
    this.onPointerDown = () => {
      if (this.status !== Status3.Idle)
        return;
      this.setStatus(Status3.Pointing);
    };
    this.onPointerMove = (info) => {
      switch (this.status) {
        case Status3.Pointing: {
          if (src_default.dist(info.origin, info.point) > DEAD_ZONE) {
            this.app.startSession(SessionType.Erase);
            this.app.updateSession();
            this.setStatus(Status3.Erasing);
          }
          break;
        }
        case Status3.Erasing: {
          this.app.updateSession();
        }
      }
    };
    this.onPointerUp = () => {
      switch (this.status) {
        case Status3.Pointing: {
          const shapeIdsAtPoint = this.app.shapes.filter((shape) => !shape.isLocked).filter((shape) => this.app.getShapeUtil(shape).hitTestPoint(shape, this.app.currentPoint)).flatMap((shape) => shape.children ? [shape.id, ...shape.children] : shape.id);
          this.app.delete(shapeIdsAtPoint);
          break;
        }
        case Status3.Erasing: {
          this.app.completeSession();
        }
      }
      this.setStatus(Status3.Idle);
    };
    this.onCancel = () => {
      if (this.status === Status3.Idle) {
        if (this.previous) {
          this.app.selectTool(this.previous);
        } else {
          this.app.selectTool("select");
        }
      } else {
        this.setStatus(Status3.Idle);
      }
      this.app.cancelSession();
    };
  }
};
var TextTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Text;
    this.stopEditingShape = () => {
      this.setStatus(Status.Idle);
      if (!this.app.appState.isToolLocked) {
        this.app.selectTool("select");
      }
    };
    this.onKeyUp = () => {
    };
    this.onKeyDown = () => {
    };
    this.onPointerDown = () => {
      if (this.status === Status.Creating) {
        this.stopEditingShape();
        return;
      }
      if (this.status === Status.Idle) {
        const {
          currentPoint,
          currentGrid,
          settings: { showGrid }
        } = this.app;
        this.app.createTextShapeAtPoint(showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint);
        this.setStatus(Status.Creating);
        return;
      }
    };
    this.onPointerUp = () => {
    };
    this.onPointShape = (info) => {
      const shape = this.app.getShape(info.target);
      if (shape.type === TDShapeType.Text) {
        this.setStatus(Status.Idle);
        this.app.setEditingId(shape.id);
      }
    };
    this.onShapeBlur = () => {
      this.stopEditingShape();
    };
  }
};
var DrawTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Draw;
    this.onPointerDown = (info) => {
      if (this.status !== Status.Idle)
        return;
      const {
        currentPoint,
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Draw.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: [...currentPoint, info.pressure || 0.5],
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession(SessionType.Draw, id);
      this.setStatus(Status.Creating);
    };
    this.onPointerMove = () => {
      if (this.status === Status.Creating) {
        this.app.updateSession();
      }
    };
    this.onPointerUp = () => {
      if (this.status === Status.Creating) {
        this.app.completeSession();
      }
      this.setStatus(Status.Idle);
    };
  }
};
var EllipseTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Ellipse;
    this.onPointerDown = () => {
      if (this.status !== Status.Idle)
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Ellipse.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession(SessionType.TransformSingle, newShape.id, TLBoundsCorner.BottomRight, true);
      this.setStatus(Status.Creating);
    };
  }
};
var RectangleTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Rectangle;
    this.onPointerDown = () => {
      if (this.status !== Status.Idle)
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Rectangle.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession(SessionType.TransformSingle, newShape.id, TLBoundsCorner.BottomRight, true);
      this.setStatus(Status.Creating);
    };
  }
};
var TriangleTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Triangle;
    this.onPointerDown = () => {
      if (this.status !== Status.Idle)
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Triangle.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession(SessionType.TransformSingle, newShape.id, TLBoundsCorner.BottomRight, true);
      this.setStatus(Status.Creating);
    };
  }
};
var LineTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Line;
    this.onPointerDown = () => {
      if (this.status !== Status.Idle)
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Arrow6.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        decorations: {
          start: void 0,
          end: void 0
        },
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession(SessionType.Arrow, newShape.id, "end", true);
      this.setStatus(Status.Creating);
    };
  }
};
var ArrowTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Arrow;
    this.onPointerDown = () => {
      if (this.status !== Status.Idle)
        return;
      const {
        currentPoint,
        currentGrid,
        settings: { showGrid },
        appState: { currentPageId, currentStyle }
      } = this.app;
      const childIndex = this.getNextChildIndex();
      const id = Utils.uniqueId();
      const newShape = Arrow6.create({
        id,
        parentId: currentPageId,
        childIndex,
        point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
        style: __spreadValues4({}, currentStyle)
      });
      this.app.patchCreate([newShape]);
      this.app.startSession(SessionType.Arrow, newShape.id, "end", true);
      this.setStatus(Status.Creating);
    };
  }
};
var StickyTool = class extends BaseTool {
  constructor() {
    super(...arguments);
    this.type = TDShapeType.Sticky;
    this.onPointerDown = () => {
      if (this.status === Status.Creating) {
        this.setStatus(Status.Idle);
        if (!this.app.appState.isToolLocked) {
          this.app.selectTool("select");
        }
        return;
      }
      if (this.status === Status.Idle) {
        const {
          currentPoint,
          currentGrid,
          settings: { showGrid },
          appState: { currentPageId, currentStyle }
        } = this.app;
        const childIndex = this.getNextChildIndex();
        const id = Utils.uniqueId();
        this.shapeId = id;
        const newShape = Sticky.create({
          id,
          parentId: currentPageId,
          childIndex,
          point: showGrid ? src_default.snap(currentPoint, currentGrid) : currentPoint,
          style: __spreadValues4({}, currentStyle)
        });
        const bounds = Sticky.getBounds(newShape);
        newShape.point = src_default.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);
        this.app.createShapes(newShape);
        this.app.startSession(SessionType.Translate);
        this.setStatus(Status.Creating);
      }
    };
    this.onPointerUp = () => {
      if (this.status === Status.Creating) {
        this.setStatus(Status.Idle);
        this.app.completeSession();
        this.app.selectTool("select");
        this.app.setEditingId(this.shapeId);
      }
    };
  }
};
function deepCopy(target) {
  if (target === null) {
    return target;
  }
  if (target instanceof Date) {
    return new Date(target.getTime());
  }
  if (typeof target === "object") {
    if (typeof target[Symbol.iterator] === "function") {
      const cp = [];
      if (target.length > 0) {
        for (const arrayMember of target) {
          cp.push(deepCopy(arrayMember));
        }
      }
      return cp;
    } else {
      const targetKeys = Object.keys(target);
      const cp = {};
      if (targetKeys.length > 0) {
        for (const key of targetKeys) {
          cp[key] = deepCopy(target[key]);
        }
      }
      return cp;
    }
  }
  return target;
}
var StateManager = class {
  constructor(initialState, id, version, update) {
    this.pointer = -1;
    this._status = "loading";
    this.stack = [];
    this.isPaused = false;
    this.persist = (id2) => {
      if (this.onPersist) {
        this.onPersist(this._state, id2);
      }
      if (this._idbId) {
        return set5(this._idbId, this._state).catch((e12) => console.error(e12));
      }
    };
    this.applyPatch = (patch, id2) => {
      const prev = this._state;
      const next = Utils.deepMerge(this._state, patch);
      const final = this.cleanup(next, prev, patch, id2);
      if (this.onStateWillChange) {
        this.onStateWillChange(final, id2);
      }
      this._state = final;
      this.store.setState(this._state, true);
      if (this.onStateDidChange) {
        this.onStateDidChange(this._state, id2);
      }
      return this;
    };
    this.cleanup = (nextState, prevState, patch, id2) => nextState;
    this.patchState = (patch, id2) => {
      this.applyPatch(patch, id2);
      if (this.onPatch) {
        this.onPatch(this._state, id2);
      }
      return this;
    };
    this.replaceState = (state, id2) => {
      const final = this.cleanup(state, this._state, state, id2);
      if (this.onStateWillChange) {
        this.onStateWillChange(final, "replace");
      }
      this._state = final;
      this.store.setState(this._state, true);
      if (this.onStateDidChange) {
        this.onStateDidChange(this._state, "replace");
      }
      return this;
    };
    this.setState = (command, id2 = command.id) => {
      if (this.pointer < this.stack.length - 1) {
        this.stack = this.stack.slice(0, this.pointer + 1);
      }
      this.stack.push(__spreadProps4(__spreadValues4({}, command), { id: id2 }));
      this.pointer = this.stack.length - 1;
      this.applyPatch(command.after, id2);
      if (this.onCommand)
        this.onCommand(this._state, id2);
      this.persist(id2);
      return this;
    };
    this.reset = () => {
      if (this.onStateWillChange) {
        this.onStateWillChange(this.initialState, "reset");
      }
      this._state = this.initialState;
      this.store.setState(this._state, true);
      this.resetHistory();
      this.persist("reset");
      if (this.onStateDidChange) {
        this.onStateDidChange(this._state, "reset");
      }
      if (this.onReset) {
        this.onReset(this._state);
      }
      return this;
    };
    this.replaceHistory = (history, pointer = history.length - 1) => {
      this.stack = history;
      this.pointer = pointer;
      if (this.onReplace) {
        this.onReplace(this._state);
      }
      return this;
    };
    this.resetHistory = () => {
      this.stack = [];
      this.pointer = -1;
      if (this.onResetHistory) {
        this.onResetHistory(this._state);
      }
      return this;
    };
    this.undo = () => {
      if (!this.isPaused) {
        if (!this.canUndo)
          return this;
        const command = this.stack[this.pointer];
        this.pointer--;
        this.applyPatch(command.before, `undo`);
        this.persist("undo");
      }
      if (this.onUndo)
        this.onUndo(this._state);
      return this;
    };
    this.redo = () => {
      if (!this.isPaused) {
        if (!this.canRedo)
          return this;
        this.pointer++;
        const command = this.stack[this.pointer];
        this.applyPatch(command.after, "redo");
        this.persist("undo");
      }
      if (this.onRedo)
        this.onRedo(this._state);
      return this;
    };
    this.setSnapshot = () => {
      this._snapshot = __spreadValues4({}, this._state);
      return this;
    };
    this.forceUpdate = () => {
      this.store.setState(this._state, true);
    };
    this._idbId = id;
    this._state = deepCopy(initialState);
    this._snapshot = deepCopy(initialState);
    this.initialState = deepCopy(initialState);
    this.store = createStore2(() => this._state);
    this.useStore = create(this.store);
    this.ready = new Promise((resolve) => {
      let message = "none";
      if (this._idbId) {
        message = "restored";
        get4(this._idbId).then((saved) => __async(this, null, function* () {
          if (saved) {
            let next = saved;
            if (version) {
              const savedVersion = yield get4(id + "_version");
              if (savedVersion && savedVersion < version) {
                next = update ? update(saved, initialState, savedVersion) : initialState;
                message = "migrated";
              }
            }
            yield set5(id + "_version", version || -1);
            this._state = deepCopy(next);
            this._snapshot = deepCopy(next);
            this.store.setState(this._state, true);
          } else {
            yield set5(id + "_version", version || -1);
          }
          this._status = "ready";
          resolve(message);
        })).catch((e12) => console.error(e12));
      } else {
        this._status = "ready";
        resolve(message);
      }
      resolve(message);
    }).then((message) => {
      if (this.onReady)
        this.onReady(message);
      return message;
    });
  }
  pause() {
    this.isPaused = true;
  }
  resume() {
    this.isPaused = false;
  }
  get canUndo() {
    return this.pointer > -1;
  }
  get canRedo() {
    return this.pointer < this.stack.length - 1;
  }
  get state() {
    return this._state;
  }
  get status() {
    return this._status;
  }
  get snapshot() {
    return this._snapshot;
  }
};
var uuid = Utils.uniqueId();
var _TldrawApp = class extends StateManager {
  constructor(id, callbacks = {}) {
    super(_TldrawApp.defaultState, id, _TldrawApp.version, (prev, next, prevVersion) => {
      return __spreadProps4(__spreadValues4({}, next), {
        document: migrate(__spreadProps4(__spreadValues4(__spreadValues4({}, next.document), prev.document), { version: prevVersion }), _TldrawApp.version)
      });
    });
    this.callbacks = {};
    this.tools = {
      select: new SelectTool(this),
      erase: new EraseTool(this),
      [TDShapeType.Text]: new TextTool(this),
      [TDShapeType.Draw]: new DrawTool(this),
      [TDShapeType.Ellipse]: new EllipseTool(this),
      [TDShapeType.Rectangle]: new RectangleTool(this),
      [TDShapeType.Triangle]: new TriangleTool(this),
      [TDShapeType.Line]: new LineTool(this),
      [TDShapeType.Arrow]: new ArrowTool(this),
      [TDShapeType.Sticky]: new StickyTool(this)
    };
    this.currentTool = this.tools.select;
    this.readOnly = false;
    this.isDirty = false;
    this.isCreating = false;
    this.originPoint = [0, 0];
    this.currentPoint = [0, 0];
    this.previousPoint = [0, 0];
    this.shiftKey = false;
    this.altKey = false;
    this.metaKey = false;
    this.ctrlKey = false;
    this.spaceKey = false;
    this.editingStartTime = -1;
    this.fileSystemHandle = null;
    this.viewport = Utils.getBoundsFromPoints([
      [0, 0],
      [100, 100]
    ]);
    this.rendererBounds = Utils.getBoundsFromPoints([
      [0, 0],
      [100, 100]
    ]);
    this.selectHistory = {
      stack: [[]],
      pointer: 0
    };
    this.rotationInfo = {
      selectedIds: [],
      center: [0, 0]
    };
    this.pasteInfo = {
      center: [0, 0],
      offset: [0, 0]
    };
    this.onReady = () => {
      var _a2, _b;
      this.loadDocument(this.document);
      loadFileHandle().then((fileHandle) => {
        this.fileSystemHandle = fileHandle;
      });
      try {
        this.patchState({
          appState: {
            status: TDStatus.Idle
          },
          document: migrate(this.document, _TldrawApp.version)
        });
      } catch (e12) {
        console.error("The data appears to be corrupted. Resetting!", e12);
        localStorage.setItem(this.document.id + "_corrupted", JSON.stringify(this.document));
        this.patchState(__spreadProps4(__spreadValues4({}, _TldrawApp.defaultState), {
          appState: __spreadProps4(__spreadValues4({}, _TldrawApp.defaultState.appState), {
            status: TDStatus.Idle
          })
        }));
      }
      (_b = (_a2 = this.callbacks).onMount) == null ? void 0 : _b.call(_a2, this);
    };
    this.cleanup = (state, prev) => {
      const next = __spreadValues4({}, state);
      if (next.document !== prev.document) {
        Object.entries(next.document.pages).forEach(([pageId, page]) => {
          if (page === void 0) {
            delete next.document.pages[pageId];
            delete next.document.pageStates[pageId];
            return;
          }
          const prevPage = prev.document.pages[pageId];
          const changedShapes = {};
          if (!prevPage || page.shapes !== prevPage.shapes || page.bindings !== prevPage.bindings) {
            page.shapes = __spreadValues4({}, page.shapes);
            page.bindings = __spreadValues4({}, page.bindings);
            const groupsToUpdate = new Set();
            Object.entries(page.shapes).forEach(([id2, shape]) => {
              var _a2;
              let parentId;
              if (!shape) {
                parentId = (_a2 = prevPage == null ? void 0 : prevPage.shapes[id2]) == null ? void 0 : _a2.parentId;
                delete page.shapes[id2];
              } else {
                parentId = shape.parentId;
              }
              if (page.id === next.appState.currentPageId) {
                if ((prevPage == null ? void 0 : prevPage.shapes[id2]) !== shape) {
                  changedShapes[id2] = shape;
                }
              }
              if (parentId && parentId !== pageId) {
                const group = page.shapes[parentId];
                if (group !== void 0) {
                  groupsToUpdate.add(page.shapes[parentId]);
                }
              }
            });
            Object.keys(page.bindings).forEach((id2) => {
              if (!page.bindings[id2]) {
                delete page.bindings[id2];
              }
            });
            next.document.pages[pageId] = page;
            const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(changedShapes), pageId);
            bindingsToUpdate.forEach((binding) => {
              var _a2;
              if (!page.bindings[binding.id]) {
                return;
              }
              const toShape = page.shapes[binding.toId];
              const fromShape = page.shapes[binding.fromId];
              const toUtils = TLDR.getShapeUtil(toShape);
              const fromUtils = TLDR.getShapeUtil(fromShape);
              const fromDelta = (_a2 = fromUtils.onBindingChange) == null ? void 0 : _a2.call(fromUtils, fromShape, binding, toShape, toUtils.getBounds(toShape), toUtils.getExpandedBounds(toShape), toUtils.getCenter(toShape));
              if (fromDelta) {
                const nextShape = __spreadValues4(__spreadValues4({}, fromShape), fromDelta);
                page.shapes[fromShape.id] = nextShape;
              }
            });
            groupsToUpdate.forEach((group) => {
              if (!group)
                throw Error("no group!");
              const children = group.children.filter((id2) => page.shapes[id2] !== void 0);
              const commonBounds = Utils.getCommonBounds(children.map((id2) => page.shapes[id2]).filter(Boolean).map((shape) => TLDR.getRotatedBounds(shape)));
              page.shapes[group.id] = __spreadProps4(__spreadValues4({}, group), {
                point: [commonBounds.minX, commonBounds.minY],
                size: [commonBounds.width, commonBounds.height],
                children
              });
            });
          }
          const nextPageState = __spreadValues4({}, next.document.pageStates[pageId]);
          if (!nextPageState.brush) {
            delete nextPageState.brush;
          }
          if (nextPageState.hoveredId && !page.shapes[nextPageState.hoveredId]) {
            delete nextPageState.hoveredId;
          }
          if (nextPageState.bindingId && !page.bindings[nextPageState.bindingId]) {
            TLDR.warn(`Could not find the binding of ${pageId}`);
            delete nextPageState.bindingId;
          }
          if (nextPageState.editingId && !page.shapes[nextPageState.editingId]) {
            TLDR.warn("Could not find the editing shape!");
            delete nextPageState.editingId;
          }
          next.document.pageStates[pageId] = nextPageState;
        });
      }
      const currentPageId = next.appState.currentPageId;
      const currentPageState = next.document.pageStates[currentPageId];
      if (next.room && next.room !== prev.room) {
        const room = __spreadProps4(__spreadValues4({}, next.room), { users: __spreadValues4({}, next.room.users) });
        if (prev.room) {
          Object.values(prev.room.users).filter(Boolean).forEach((user) => {
            if (room.users[user.id] === void 0) {
              delete room.users[user.id];
            }
          });
        }
        next.room = room;
      }
      if (next.room) {
        next.room.users[next.room.userId] = __spreadProps4(__spreadValues4({}, next.room.users[next.room.userId]), {
          point: this.currentPoint,
          selectedIds: currentPageState.selectedIds
        });
      }
      if (this.readOnly) {
        next.document.pages = prev.document.pages;
      }
      return next;
    };
    this.onPatch = (state, id2) => {
      var _a2, _b;
      (_b = (_a2 = this.callbacks).onPatch) == null ? void 0 : _b.call(_a2, this, id2);
    };
    this.onCommand = (state, id2) => {
      var _a2, _b;
      this.clearSelectHistory();
      this.isDirty = true;
      (_b = (_a2 = this.callbacks).onCommand) == null ? void 0 : _b.call(_a2, this, id2);
    };
    this.onReplace = () => {
      this.clearSelectHistory();
      this.isDirty = false;
    };
    this.onUndo = () => {
      var _a2, _b;
      this.rotationInfo.selectedIds = [...this.selectedIds];
      (_b = (_a2 = this.callbacks).onUndo) == null ? void 0 : _b.call(_a2, this);
    };
    this.onRedo = () => {
      var _a2, _b;
      this.rotationInfo.selectedIds = [...this.selectedIds];
      (_b = (_a2 = this.callbacks).onRedo) == null ? void 0 : _b.call(_a2, this);
    };
    this.onPersist = () => {
      var _a2, _b;
      if (this.callbacks.onChangePage) {
        this.broadcastPageChanges();
      }
      (_b = (_a2 = this.callbacks).onPersist) == null ? void 0 : _b.call(_a2, this);
    };
    this.prevSelectedIds = this.selectedIds;
    this.onStateDidChange = (_state, id2) => {
      var _a2, _b, _c, _d;
      (_b = (_a2 = this.callbacks).onChange) == null ? void 0 : _b.call(_a2, this, id2);
      if (this.room && this.selectedIds !== this.prevSelectedIds) {
        (_d = (_c = this.callbacks).onChangePresence) == null ? void 0 : _d.call(_c, this, __spreadProps4(__spreadValues4({}, this.room.users[this.room.userId]), {
          selectedIds: this.selectedIds
        }));
        this.prevSelectedIds = this.selectedIds;
      }
    };
    this.justSent = false;
    this.prevShapes = this.page.shapes;
    this.prevBindings = this.page.bindings;
    this.broadcastPageChanges = () => {
      var _a2, _b;
      const visited = new Set();
      const changedShapes = {};
      const changedBindings = {};
      this.shapes.forEach((shape) => {
        visited.add(shape.id);
        if (this.prevShapes[shape.id] !== shape) {
          changedShapes[shape.id] = shape;
        }
      });
      Object.keys(this.prevShapes).filter((id2) => !visited.has(id2)).forEach((id2) => {
        changedShapes[id2] = void 0;
      });
      this.bindings.forEach((binding) => {
        visited.add(binding.id);
        if (this.prevBindings[binding.id] !== binding) {
          changedBindings[binding.id] = binding;
        }
      });
      Object.keys(this.prevBindings).filter((id2) => !visited.has(id2)).forEach((id2) => {
        changedBindings[id2] = void 0;
      });
      if (Object.keys(changedBindings).length > 0 || Object.keys(changedShapes).length > 0) {
        this.justSent = true;
        (_b = (_a2 = this.callbacks).onChangePage) == null ? void 0 : _b.call(_a2, this, changedShapes, changedBindings);
        this.prevShapes = this.page.shapes;
        this.prevBindings = this.page.bindings;
      }
    };
    this.getReservedContent = (ids, pageId = this.currentPageId) => {
      const { bindings } = this.document.pages[pageId];
      const reservedShapes = {};
      const reservedBindings = {};
      const bindingsArr = Object.values(bindings);
      const boundTos = new Map(bindingsArr.map((binding) => [binding.toId, binding]));
      const boundFroms = new Map(bindingsArr.map((binding) => [binding.fromId, binding]));
      const bindingMaps = [boundTos, boundFroms];
      const reservedShapeIds = [];
      if (this.session)
        ids.forEach((id2) => reservedShapeIds.push(id2));
      const strongReservedShapeIds = new Set(reservedShapeIds);
      const visited = new Set();
      while (reservedShapeIds.length > 0) {
        const id2 = reservedShapeIds.pop();
        if (!id2)
          break;
        if (visited.has(id2))
          continue;
        visited.add(id2);
        const shape = this.getShape(id2);
        reservedShapes[id2] = shape;
        if (shape.parentId !== pageId)
          reservedShapeIds.push(shape.parentId);
        if (shape.children)
          reservedShapeIds.push(...shape.children);
        bindingMaps.map((map3) => map3.get(shape.id)).filter(Boolean).forEach((binding) => {
          reservedBindings[binding.id] = binding;
          reservedShapeIds.push(binding.toId, binding.fromId);
        });
      }
      return { reservedShapes, reservedBindings, strongReservedShapeIds };
    };
    this.replacePageContent = (shapes, bindings, pageId = this.currentPageId) => {
      if (this.justSent) {
        this.justSent = false;
        return this;
      }
      this.useStore.setState((current) => {
        const { hoveredId, editingId, bindingId, selectedIds } = current.document.pageStates[pageId];
        const coreReservedIds = [...selectedIds];
        if (editingId)
          coreReservedIds.push(editingId);
        const { reservedShapes, reservedBindings, strongReservedShapeIds } = this.getReservedContent(coreReservedIds, this.currentPageId);
        Object.values(reservedShapes).filter((reservedShape) => !("text" in reservedShape)).forEach((reservedShape) => {
          const incomingShape = shapes[reservedShape.id];
          if (!incomingShape)
            return;
          if (!(reservedShape.type === TDShapeType.Arrow || strongReservedShapeIds.has(reservedShape.id))) {
            reservedShapes[reservedShape.id] = incomingShape;
            return;
          }
          if ("decorations" in incomingShape && "decorations" in reservedShape) {
            reservedShape.decorations = incomingShape.decorations;
          }
          reservedShape.style = incomingShape.style;
        });
        this.prevShapes = shapes;
        this.prevBindings = bindings;
        const nextShapes = __spreadValues4(__spreadValues4({}, shapes), reservedShapes);
        const nextBindings = __spreadValues4(__spreadValues4({}, bindings), reservedBindings);
        const next = __spreadProps4(__spreadValues4({}, current), {
          document: __spreadProps4(__spreadValues4({}, current.document), {
            pages: {
              [pageId]: __spreadProps4(__spreadValues4({}, current.document.pages[pageId]), {
                shapes: nextShapes,
                bindings: nextBindings
              })
            },
            pageStates: __spreadProps4(__spreadValues4({}, current.document.pageStates), {
              [pageId]: __spreadProps4(__spreadValues4({}, current.document.pageStates[pageId]), {
                selectedIds: selectedIds.filter((id2) => nextShapes[id2] !== void 0),
                hoveredId: hoveredId ? nextShapes[hoveredId] === void 0 ? void 0 : hoveredId : void 0,
                editingId,
                bindingId: bindingId ? nextBindings[bindingId] === void 0 ? void 0 : bindingId : void 0
              })
            })
          })
        });
        const bindingsToUpdate = TLDR.getRelatedBindings(next, Object.keys(nextShapes), pageId);
        const page = next.document.pages[pageId];
        bindingsToUpdate.forEach((binding) => {
          var _a2;
          if (!page.bindings[binding.id]) {
            return;
          }
          const toShape = page.shapes[binding.toId];
          const fromShape = page.shapes[binding.fromId];
          const toUtils = TLDR.getShapeUtil(toShape);
          const fromUtils = TLDR.getShapeUtil(fromShape);
          const fromDelta = (_a2 = fromUtils.onBindingChange) == null ? void 0 : _a2.call(fromUtils, fromShape, binding, toShape, toUtils.getBounds(toShape), toUtils.getExpandedBounds(toShape), toUtils.getCenter(toShape));
          if (fromDelta) {
            const nextShape = __spreadValues4(__spreadValues4({}, fromShape), fromDelta);
            page.shapes[fromShape.id] = nextShape;
          }
        });
        Object.values(nextShapes).forEach((shape) => {
          if (shape.type !== TDShapeType.Group)
            return;
          const children = shape.children.filter((id2) => page.shapes[id2] !== void 0);
          const commonBounds = Utils.getCommonBounds(children.map((id2) => page.shapes[id2]).filter(Boolean).map((shape2) => TLDR.getRotatedBounds(shape2)));
          page.shapes[shape.id] = __spreadProps4(__spreadValues4({}, shape), {
            point: [commonBounds.minX, commonBounds.minY],
            size: [commonBounds.width, commonBounds.height],
            children
          });
        });
        this.state.document = next.document;
        return next;
      }, true);
      return this;
    };
    this.updateBounds = (bounds) => {
      this.rendererBounds = bounds;
      const { point, zoom } = this.pageState.camera;
      this.updateViewport(point, zoom);
      if (!this.readOnly && this.session) {
        this.session.update();
      }
    };
    this.updateViewport = (point, zoom) => {
      const { width, height } = this.rendererBounds;
      const [minX, minY] = Vec.sub(Vec.div([0, 0], zoom), point);
      const [maxX, maxY] = Vec.sub(Vec.div([width, height], zoom), point);
      this.viewport = {
        minX,
        minY,
        maxX,
        maxY,
        height: maxX - minX,
        width: maxY - minY
      };
    };
    this.setEditingId = (id2) => {
      if (this.readOnly)
        return;
      this.editingStartTime = Date.now();
      this.patchState({
        document: {
          pageStates: {
            [this.currentPageId]: {
              editingId: id2
            }
          }
        }
      }, `set_editing_id`);
    };
    this.setHoveredId = (id2) => {
      this.patchState({
        document: {
          pageStates: {
            [this.currentPageId]: {
              hoveredId: id2
            }
          }
        }
      }, `set_hovered_id`);
    };
    this.setSetting = (name, value) => {
      if (this.session)
        return this;
      this.patchState({
        settings: {
          [name]: typeof value === "function" ? value(this.settings[name]) : value
        }
      }, `settings:${name}`);
      this.persist();
      return this;
    };
    this.toggleFocusMode = () => {
      if (this.session)
        return this;
      this.patchState({
        settings: {
          isFocusMode: !this.settings.isFocusMode
        }
      }, `settings:toggled_focus_mode`);
      this.persist();
      return this;
    };
    this.togglePenMode = () => {
      if (this.session)
        return this;
      this.patchState({
        settings: {
          isPenMode: !this.settings.isPenMode
        }
      }, `settings:toggled_pen_mode`);
      this.persist();
      return this;
    };
    this.toggleDarkMode = () => {
      if (this.session)
        return this;
      this.patchState({ settings: { isDarkMode: !this.settings.isDarkMode } }, `settings:toggled_dark_mode`);
      this.persist();
      return this;
    };
    this.toggleZoomSnap = () => {
      if (this.session)
        return this;
      this.patchState({ settings: { isZoomSnap: !this.settings.isZoomSnap } }, `settings:toggled_zoom_snap`);
      this.persist();
      return this;
    };
    this.toggleDebugMode = () => {
      if (this.session)
        return this;
      this.patchState({ settings: { isDebugMode: !this.settings.isDebugMode } }, `settings:toggled_debug`);
      this.persist();
      return this;
    };
    this.setMenuOpen = (isOpen) => {
      this.patchState({ appState: { isMenuOpen: isOpen } }, "ui:toggled_menu_opened");
      this.persist();
      return this;
    };
    this.isMenuOpen = () => this.appState.isMenuOpen;
    this.toggleGrid = () => {
      if (this.session)
        return this;
      this.patchState({ settings: { showGrid: !this.settings.showGrid } }, "settings:toggled_grid");
      this.persist();
      return this;
    };
    this.selectTool = (type) => {
      if (this.readOnly || this.session)
        return this;
      const tool = this.tools[type];
      if (tool === this.currentTool) {
        this.patchState({
          appState: {
            isToolLocked: false
          }
        });
        return this;
      }
      this.currentTool.onExit();
      tool.previous = this.currentTool.type;
      this.currentTool = tool;
      this.currentTool.onEnter();
      return this.patchState({
        appState: {
          activeTool: type,
          isToolLocked: false
        }
      }, `selected_tool:${type}`);
    };
    this.toggleToolLock = () => {
      if (this.session)
        return this;
      return this.patchState({
        appState: {
          isToolLocked: !this.appState.isToolLocked
        }
      }, `toggled_tool_lock`);
    };
    this.resetDocument = () => {
      if (this.session)
        return this;
      this.session = void 0;
      this.pasteInfo.offset = [0, 0];
      this.currentTool = this.tools.select;
      this.resetHistory().clearSelectHistory().loadDocument(migrate(_TldrawApp.defaultDocument, _TldrawApp.version)).persist();
      return this;
    };
    this.updateUsers = (users, isOwnUpdate = false) => {
      this.patchState({
        room: {
          users: Object.fromEntries(users.map((user) => [user.id, user]))
        }
      }, isOwnUpdate ? "room:self:update" : "room:user:update");
    };
    this.removeUser = (userId) => {
      this.patchState({
        room: {
          users: {
            [userId]: void 0
          }
        }
      });
    };
    this.mergeDocument = (document2) => {
      if (this.document.id !== document2.id) {
        this.replaceState(__spreadProps4(__spreadValues4({}, this.state), {
          appState: __spreadProps4(__spreadValues4({}, this.appState), {
            currentPageId: Object.keys(document2.pages)[0]
          }),
          document: migrate(document2, _TldrawApp.version)
        }));
        return this;
      }
      const currentPageStates = __spreadValues4({}, this.document.pageStates);
      const nextAppState = __spreadProps4(__spreadValues4({}, this.appState), {
        currentPageId: document2.pages[this.currentPageId] ? this.currentPageId : Object.keys(document2.pages)[0],
        pages: Object.values(document2.pages).map((page, i8) => ({
          id: page.id,
          name: page.name,
          childIndex: page.childIndex || i8
        }))
      });
      this.resetHistory();
      Object.keys(this.document.pages).forEach((pageId) => {
        if (!document2.pages[pageId]) {
          if (pageId === this.appState.currentPageId) {
            this.cancelSession();
            this.selectNone();
          }
          currentPageStates[pageId] = void 0;
        }
      });
      if (this.session) {
        this.selectedIds.filter((id2) => !document2.pages[this.currentPageId].shapes[id2]).forEach((id2) => document2.pages[this.currentPageId].shapes[id2] = this.page.shapes[id2]);
      }
      Object.entries(currentPageStates).forEach(([pageId, pageState]) => {
        pageState.selectedIds = pageState.selectedIds.filter((id2) => !!document2.pages[pageId].shapes[id2]);
      });
      const { editingId } = this.pageState;
      if (editingId) {
        document2.pages[this.currentPageId].shapes[editingId] = this.page.shapes[editingId];
        currentPageStates[this.currentPageId].selectedIds = [editingId];
      }
      return this.replaceState(__spreadProps4(__spreadValues4({}, this.state), {
        appState: nextAppState,
        document: __spreadProps4(__spreadValues4({}, migrate(document2, _TldrawApp.version)), {
          pageStates: currentPageStates
        })
      }), "merge");
    };
    this.updateDocument = (document2, reason = "updated_document") => {
      const prevState = this.state;
      const nextState = __spreadProps4(__spreadValues4({}, prevState), { document: __spreadValues4({}, prevState.document) });
      if (!document2.pages[this.currentPageId]) {
        nextState.appState = __spreadProps4(__spreadValues4({}, prevState.appState), {
          currentPageId: Object.keys(document2.pages)[0]
        });
      }
      let i8 = 1;
      for (const nextPage of Object.values(document2.pages)) {
        if (nextPage !== prevState.document.pages[nextPage.id]) {
          nextState.document.pages[nextPage.id] = nextPage;
          if (!nextPage.name) {
            nextState.document.pages[nextPage.id].name = `Page ${i8 + 1}`;
            i8++;
          }
        }
      }
      for (const nextPageState of Object.values(document2.pageStates)) {
        if (nextPageState !== prevState.document.pageStates[nextPageState.id]) {
          nextState.document.pageStates[nextPageState.id] = nextPageState;
          const nextPage = document2.pages[nextPageState.id];
          const keysToCheck = ["bindingId", "editingId", "hoveredId", "pointedId"];
          for (const key of keysToCheck) {
            if (!nextPage.shapes[key]) {
              nextPageState[key] = void 0;
            }
          }
          nextPageState.selectedIds = nextPageState.selectedIds.filter((id2) => !!document2.pages[nextPage.id].shapes[id2]);
        }
      }
      nextState.document = migrate(nextState.document, nextState.document.version || 0);
      return this.replaceState(nextState, `${reason}:${document2.id}`);
    };
    this.loadRoom = (roomId) => {
      this.patchState({
        room: {
          id: roomId,
          userId: uuid,
          users: {
            [uuid]: {
              id: uuid,
              color: USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)],
              point: [100, 100],
              selectedIds: [],
              activeShapes: []
            }
          }
        }
      });
      return this;
    };
    this.loadDocument = (document2) => {
      this.selectNone();
      this.resetHistory();
      this.clearSelectHistory();
      this.session = void 0;
      this.replaceState(__spreadProps4(__spreadValues4({}, _TldrawApp.defaultState), {
        document: migrate(document2, _TldrawApp.version),
        appState: __spreadProps4(__spreadValues4({}, _TldrawApp.defaultState.appState), {
          currentPageId: Object.keys(document2.pages)[0]
        })
      }), "loaded_document");
      return this;
    };
    this.newProject = () => {
      if (!this.isLocal)
        return;
      this.fileSystemHandle = null;
      this.resetDocument();
    };
    this.saveProject = () => __async(this, null, function* () {
      if (this.readOnly)
        return;
      try {
        const fileHandle = yield saveToFileSystem(this.document, this.fileSystemHandle);
        this.fileSystemHandle = fileHandle;
        this.persist();
        this.isDirty = false;
      } catch (e12) {
        console.error(e12.message);
      }
      return this;
    });
    this.saveProjectAs = () => __async(this, null, function* () {
      try {
        const fileHandle = yield saveToFileSystem(this.document, null);
        this.fileSystemHandle = fileHandle;
        this.persist();
        this.isDirty = false;
      } catch (e12) {
        console.error(e12.message);
      }
      return this;
    });
    this.openProject = () => __async(this, null, function* () {
      if (!this.isLocal)
        return;
      try {
        const result = yield openFromFileSystem();
        if (!result) {
          throw Error();
        }
        const { fileHandle, document: document2 } = result;
        this.loadDocument(document2);
        this.fileSystemHandle = fileHandle;
        this.zoomToFit();
        this.persist();
      } catch (e12) {
        console.error(e12);
      } finally {
        this.persist();
      }
    });
    this.signOut = () => {
    };
    this.getAppState = () => {
      return this.appState;
    };
    this.getPage = (pageId = this.currentPageId) => {
      return TLDR.getPage(this.state, pageId || this.currentPageId);
    };
    this.getShapes = (pageId = this.currentPageId) => {
      return TLDR.getShapes(this.state, pageId || this.currentPageId);
    };
    this.getBindings = (pageId = this.currentPageId) => {
      return TLDR.getBindings(this.state, pageId || this.currentPageId);
    };
    this.getShape = (id2, pageId = this.currentPageId) => {
      return TLDR.getShape(this.state, id2, pageId);
    };
    this.getShapeBounds = (id2, pageId = this.currentPageId) => {
      return TLDR.getBounds(this.getShape(id2, pageId));
    };
    this.getBinding = (id2, pageId = this.currentPageId) => {
      return TLDR.getBinding(this.state, id2, pageId);
    };
    this.getPageState = (pageId = this.currentPageId) => {
      return TLDR.getPageState(this.state, pageId || this.currentPageId);
    };
    this.getPagePoint = (point, pageId = this.currentPageId) => {
      const { camera } = this.getPageState(pageId);
      return Vec.sub(Vec.div(point, camera.zoom), camera.point);
    };
    this.createPage = (id2) => {
      if (this.readOnly)
        return this;
      const { width, height } = this.rendererBounds;
      return this.setState(createPage(this, [-width / 2, -height / 2], id2));
    };
    this.changePage = (pageId) => {
      return this.setState(changePage(this, pageId));
    };
    this.renamePage = (pageId, name) => {
      if (this.readOnly)
        return this;
      return this.setState(renamePage(this, pageId, name));
    };
    this.duplicatePage = (pageId) => {
      if (this.readOnly)
        return this;
      return this.setState(duplicatePage(this, pageId));
    };
    this.deletePage = (pageId) => {
      if (this.readOnly)
        return this;
      if (Object.values(this.document.pages).length <= 1)
        return this;
      return this.setState(deletePage(this, pageId ? pageId : this.currentPageId));
    };
    this.copy = (ids = this.selectedIds) => {
      const copyingShapeIds = ids.flatMap((id2) => TLDR.getDocumentBranch(this.state, id2, this.currentPageId));
      const copyingShapes = copyingShapeIds.map((id2) => Utils.deepClone(this.getShape(id2, this.currentPageId)));
      if (copyingShapes.length === 0)
        return this;
      const copyingBindings = Object.values(this.page.bindings).filter((binding) => copyingShapeIds.includes(binding.fromId) && copyingShapeIds.includes(binding.toId));
      this.clipboard = {
        shapes: copyingShapes,
        bindings: copyingBindings
      };
      try {
        const text = JSON.stringify({
          type: "tldr/clipboard",
          shapes: copyingShapes,
          bindings: copyingBindings
        });
        navigator.clipboard.writeText(text).then(() => {
        }, () => {
        });
      } catch (e12) {
      }
      this.pasteInfo.offset = [0, 0];
      this.pasteInfo.center = [0, 0];
      return this;
    };
    this.cut = (ids = this.selectedIds) => {
      this.copy(ids);
      this.delete(ids);
      return this;
    };
    this.paste = (point) => {
      if (this.readOnly)
        return;
      const pasteInCurrentPage = (shapes, bindings) => {
        const idsMap = {};
        shapes.forEach((shape) => idsMap[shape.id] = Utils.uniqueId());
        bindings.forEach((binding) => idsMap[binding.id] = Utils.uniqueId());
        let startIndex = TLDR.getTopChildIndex(this.state, this.currentPageId);
        const shapesToPaste = shapes.sort((a9, b7) => a9.childIndex - b7.childIndex).map((shape) => {
          const parentShapeId = idsMap[shape.parentId];
          const copy = __spreadProps4(__spreadValues4({}, shape), {
            id: idsMap[shape.id],
            parentId: parentShapeId || this.currentPageId
          });
          if (shape.children) {
            copy.children = shape.children.map((id2) => idsMap[id2]);
          }
          if (!parentShapeId) {
            copy.childIndex = startIndex;
            startIndex++;
          }
          if (copy.handles) {
            Object.values(copy.handles).forEach((handle) => {
              if (handle.bindingId) {
                handle.bindingId = idsMap[handle.bindingId];
              }
            });
          }
          return copy;
        });
        const bindingsToPaste = bindings.map((binding) => __spreadProps4(__spreadValues4({}, binding), {
          id: idsMap[binding.id],
          toId: idsMap[binding.toId],
          fromId: idsMap[binding.fromId]
        }));
        const commonBounds = Utils.getCommonBounds(shapesToPaste.map(TLDR.getBounds));
        let center = Vec.toFixed(this.getPagePoint(point || this.centerPoint));
        if (Vec.dist(center, this.pasteInfo.center) < 2 || Vec.dist(center, Vec.toFixed(Utils.getBoundsCenter(commonBounds))) < 2) {
          center = Vec.add(center, this.pasteInfo.offset);
          this.pasteInfo.offset = Vec.add(this.pasteInfo.offset, [GRID_SIZE, GRID_SIZE]);
        } else {
          this.pasteInfo.center = center;
          this.pasteInfo.offset = [0, 0];
        }
        const centeredBounds = Utils.centerBounds(commonBounds, center);
        const delta = Vec.sub(Utils.getBoundsCenter(centeredBounds), Utils.getBoundsCenter(commonBounds));
        this.create(shapesToPaste.map((shape) => TLDR.getShapeUtil(shape.type).create(__spreadProps4(__spreadValues4({}, shape), {
          point: Vec.toFixed(Vec.add(shape.point, delta)),
          parentId: shape.parentId || this.currentPageId
        }))), bindingsToPaste);
      };
      try {
        if (!("clipboard" in navigator && navigator.clipboard.readText)) {
          throw Error("This browser does not support the clipboard API.");
        }
        navigator.clipboard.readText().then((result) => {
          try {
            const data = JSON.parse(result);
            if (data.type !== "tldr/clipboard") {
              throw Error("The pasted string was not from the Tldraw clipboard.");
            }
            pasteInCurrentPage(data.shapes, data.bindings);
          } catch (e12) {
            TLDR.warn(e12);
            const shapeId = Utils.uniqueId();
            this.createShapes({
              id: shapeId,
              type: TDShapeType.Text,
              parentId: this.appState.currentPageId,
              text: TLDR.normalizeText(result),
              point: this.getPagePoint(this.centerPoint, this.currentPageId),
              style: __spreadValues4({}, this.appState.currentStyle)
            });
            this.select(shapeId);
          }
        });
      } catch (e12) {
        if (this.clipboard) {
          pasteInCurrentPage(this.clipboard.shapes, this.clipboard.bindings);
        }
      }
      return this;
    };
    this.copySvg = (ids = this.selectedIds, pageId = this.currentPageId) => {
      if (ids.length === 0)
        ids = Object.keys(this.page.shapes);
      if (ids.length === 0)
        return;
      const shapes = ids.map((id2) => this.getShape(id2, pageId));
      const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getRotatedBounds));
      const padding = 16;
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const style = document.createElementNS("http://www.w3.org/2000/svg", "style");
      style.textContent = `@import url('https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Source+Code+Pro&family=Source+Sans+Pro&family=Source+Serif+Pro&display=swap');`;
      defs.appendChild(style);
      svg.appendChild(defs);
      function getSvgElementForShape(shape) {
        const util = TLDR.getShapeUtil(shape);
        const element = util.getSvgElement(shape);
        const bounds = util.getBounds(shape);
        if (!element)
          return;
        element.setAttribute("transform", `translate(${padding + shape.point[0] - commonBounds.minX}, ${padding + shape.point[1] - commonBounds.minY}) rotate(${(shape.rotation || 0) * 180 / Math.PI}, ${bounds.width / 2}, ${bounds.height / 2})`);
        return element;
      }
      shapes.forEach((shape) => {
        var _a2;
        if ((_a2 = shape.children) == null ? void 0 : _a2.length) {
          const g5 = document.createElementNS("http://www.w3.org/2000/svg", "g");
          shape.children.map((childId) => this.getShape(childId, pageId)).map(getSvgElementForShape).filter(Boolean).forEach((element2) => g5.appendChild(element2));
          svg.appendChild(g5);
          return;
        }
        const element = getSvgElementForShape(shape);
        if (element) {
          svg.appendChild(element);
        }
      });
      svg.setAttribute("viewBox", [0, 0, commonBounds.width + padding * 2, commonBounds.height + padding * 2].join(" "));
      svg.setAttribute("width", String(commonBounds.width));
      svg.setAttribute("height", String(commonBounds.height));
      const s8 = new XMLSerializer();
      const svgString = s8.serializeToString(svg).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1");
      TLDR.copyStringToClipboard(svgString);
      return svgString;
    };
    this.copyJson = (ids = this.selectedIds, pageId = this.currentPageId) => {
      if (ids.length === 0)
        ids = Object.keys(this.page.shapes);
      if (ids.length === 0)
        return;
      const shapes = ids.map((id2) => this.getShape(id2, pageId));
      const json = JSON.stringify(shapes, null, 2);
      TLDR.copyStringToClipboard(json);
      return json;
    };
    this.setCamera = (point, zoom, reason) => {
      this.updateViewport(point, zoom);
      this.patchState({
        document: {
          pageStates: {
            [this.currentPageId]: { camera: { point, zoom } }
          }
        }
      }, reason);
      return this;
    };
    this.resetCamera = () => {
      return this.setCamera(this.centerPoint, 1, `reset_camera`);
    };
    this.pan = (delta) => {
      const { camera } = this.pageState;
      return this.setCamera(Vec.toFixed(Vec.sub(camera.point, delta)), camera.zoom, `panned`);
    };
    this.pinchZoom = (point, delta, zoom) => {
      const { camera } = this.pageState;
      const nextPoint = Vec.sub(camera.point, Vec.div(delta, camera.zoom));
      const nextZoom = zoom;
      const p0 = Vec.sub(Vec.div(point, camera.zoom), nextPoint);
      const p1 = Vec.sub(Vec.div(point, nextZoom), nextPoint);
      return this.setCamera(Vec.toFixed(Vec.add(nextPoint, Vec.sub(p1, p0))), nextZoom, `pinch_zoomed`);
    };
    this.zoomTo = (next, center = this.centerPoint) => {
      const { zoom, point } = this.pageState.camera;
      const p0 = Vec.sub(Vec.div(center, zoom), point);
      const p1 = Vec.sub(Vec.div(center, next), point);
      return this.setCamera(Vec.toFixed(Vec.add(point, Vec.sub(p1, p0))), next, `zoomed_camera`);
    };
    this.zoomIn = () => {
      const i8 = Math.round(this.pageState.camera.zoom * 100 / 25);
      const nextZoom = TLDR.getCameraZoom((i8 + 1) * 0.25);
      return this.zoomTo(nextZoom);
    };
    this.zoomOut = () => {
      const i8 = Math.round(this.pageState.camera.zoom * 100 / 25);
      const nextZoom = TLDR.getCameraZoom((i8 - 1) * 0.25);
      return this.zoomTo(nextZoom);
    };
    this.zoomToFit = () => {
      const shapes = this.shapes;
      if (shapes.length === 0)
        return this;
      const { rendererBounds } = this;
      const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getBounds));
      let zoom = TLDR.getCameraZoom(Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / commonBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / commonBounds.height));
      zoom = this.pageState.camera.zoom === zoom || this.pageState.camera.zoom < 1 ? Math.min(1, zoom) : zoom;
      const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;
      const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;
      return this.setCamera(Vec.toFixed(Vec.sub([mx, my], [commonBounds.minX, commonBounds.minY])), zoom, `zoomed_to_fit`);
    };
    this.zoomToSelection = () => {
      if (this.selectedIds.length === 0)
        return this;
      const { rendererBounds } = this;
      const selectedBounds = TLDR.getSelectedBounds(this.state);
      let zoom = TLDR.getCameraZoom(Math.min((rendererBounds.width - FIT_TO_SCREEN_PADDING) / selectedBounds.width, (rendererBounds.height - FIT_TO_SCREEN_PADDING) / selectedBounds.height));
      zoom = this.pageState.camera.zoom === zoom || this.pageState.camera.zoom < 1 ? Math.min(1, zoom) : zoom;
      const mx = (rendererBounds.width - selectedBounds.width * zoom) / 2 / zoom;
      const my = (rendererBounds.height - selectedBounds.height * zoom) / 2 / zoom;
      return this.setCamera(Vec.toFixed(Vec.sub([mx, my], [selectedBounds.minX, selectedBounds.minY])), zoom, `zoomed_to_selection`);
    };
    this.zoomToContent = () => {
      const shapes = this.shapes;
      const pageState = this.pageState;
      if (shapes.length === 0)
        return this;
      const { rendererBounds } = this;
      const { zoom } = pageState.camera;
      const commonBounds = Utils.getCommonBounds(shapes.map(TLDR.getBounds));
      const mx = (rendererBounds.width - commonBounds.width * zoom) / 2 / zoom;
      const my = (rendererBounds.height - commonBounds.height * zoom) / 2 / zoom;
      return this.setCamera(Vec.toFixed(Vec.sub([mx, my], [commonBounds.minX, commonBounds.minY])), this.pageState.camera.zoom, `zoomed_to_content`);
    };
    this.resetZoom = () => {
      return this.zoomTo(1);
    };
    this.zoomBy = Utils.throttle((delta, center) => {
      const { zoom } = this.pageState.camera;
      const nextZoom = TLDR.getCameraZoom(zoom - delta * zoom);
      return this.zoomTo(nextZoom, center);
    }, 16);
    this.clearSelectHistory = () => {
      this.selectHistory.pointer = 0;
      this.selectHistory.stack = [this.selectedIds];
      return this;
    };
    this.addToSelectHistory = (ids) => {
      if (this.selectHistory.pointer < this.selectHistory.stack.length) {
        this.selectHistory.stack = this.selectHistory.stack.slice(0, this.selectHistory.pointer + 1);
      }
      this.selectHistory.pointer++;
      this.selectHistory.stack.push(ids);
      return this;
    };
    this.setSelectedIds = (ids, push3 = false) => {
      const nextIds = push3 ? [...this.pageState.selectedIds, ...ids] : [...ids];
      return this.patchState({
        appState: {
          activeTool: "select"
        },
        document: {
          pageStates: {
            [this.currentPageId]: {
              selectedIds: nextIds
            }
          }
        }
      }, `selected`);
    };
    this.undoSelect = () => {
      if (this.selectHistory.pointer > 0) {
        this.selectHistory.pointer--;
        this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);
      }
      return this;
    };
    this.redoSelect = () => {
      if (this.selectHistory.pointer < this.selectHistory.stack.length - 1) {
        this.selectHistory.pointer++;
        this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer]);
      }
      return this;
    };
    this.select = (...ids) => {
      ids.forEach((id2) => {
        if (!this.page.shapes[id2]) {
          throw Error(`That shape does not exist on page ${this.currentPageId}`);
        }
      });
      this.setSelectedIds(ids);
      this.addToSelectHistory(ids);
      return this;
    };
    this.selectAll = (pageId = this.currentPageId) => {
      if (this.session)
        return this;
      this.setSelectedIds(Object.values(this.document.pages[pageId].shapes).filter((shape) => shape.parentId === pageId).map((shape) => shape.id));
      this.addToSelectHistory(this.selectedIds);
      this.selectTool("select");
      return this;
    };
    this.selectNone = () => {
      this.setSelectedIds([]);
      this.addToSelectHistory(this.selectedIds);
      return this;
    };
    this.startSession = (type, ...args) => {
      if (this.readOnly && type !== SessionType.Brush)
        return this;
      if (this.session) {
        TLDR.warn(`Already in a session! (${this.session.constructor.name})`);
        this.cancelSession();
      }
      const Session = getSession(type);
      this.session = new Session(this, ...args);
      const result = this.session.start();
      if (result) {
        this.patchState(result, `session:start_${this.session.constructor.name}`);
      }
      return this;
    };
    this.updateSession = () => {
      const { session } = this;
      if (!session)
        return this;
      const patch = session.update();
      if (!patch)
        return this;
      return this.patchState(patch, `session:${session == null ? void 0 : session.constructor.name}`);
    };
    this.cancelSession = () => {
      const { session } = this;
      if (!session)
        return this;
      this.session = void 0;
      const result = session.cancel();
      if (result) {
        this.patchState(result, `session:cancel:${session.constructor.name}`);
      }
      return this;
    };
    this.completeSession = () => {
      var _a2, _b, _c, _d, _e, _f, _g;
      const { session } = this;
      if (!session)
        return this;
      this.session = void 0;
      const result = session.complete();
      if (result === void 0) {
        this.isCreating = false;
        return this.patchState({
          appState: {
            status: TDStatus.Idle
          },
          document: {
            pageStates: {
              [this.currentPageId]: {
                editingId: void 0,
                bindingId: void 0,
                hoveredId: void 0
              }
            }
          }
        }, `session:complete:${session.constructor.name}`);
      } else if ("after" in result) {
        if (this.isCreating) {
          result.before = {
            appState: __spreadProps4(__spreadValues4({}, result.before.appState), {
              status: TDStatus.Idle
            }),
            document: {
              pages: {
                [this.currentPageId]: {
                  shapes: Object.fromEntries(this.selectedIds.map((id2) => [id2, void 0]))
                }
              },
              pageStates: {
                [this.currentPageId]: {
                  selectedIds: [],
                  editingId: null,
                  bindingId: null,
                  hoveredId: null
                }
              }
            }
          };
          if (this.appState.isToolLocked) {
            const pageState = ((_c = (_b = (_a2 = result.after) == null ? void 0 : _a2.document) == null ? void 0 : _b.pageStates) == null ? void 0 : _c[this.currentPageId]) || {};
            pageState.selectedIds = [];
          }
          this.isCreating = false;
        }
        result.after.appState = __spreadProps4(__spreadValues4({}, result.after.appState), {
          status: TDStatus.Idle
        });
        result.after.document = __spreadProps4(__spreadValues4({}, result.after.document), {
          pageStates: __spreadProps4(__spreadValues4({}, (_d = result.after.document) == null ? void 0 : _d.pageStates), {
            [this.currentPageId]: __spreadProps4(__spreadValues4({}, (((_e = result.after.document) == null ? void 0 : _e.pageStates) || {})[this.currentPageId]), {
              editingId: null
            })
          })
        });
        this.setState(result, `session:complete:${session.constructor.name}`);
      } else {
        this.patchState(__spreadProps4(__spreadValues4({}, result), {
          appState: __spreadProps4(__spreadValues4({}, result.appState), {
            status: TDStatus.Idle
          }),
          document: __spreadProps4(__spreadValues4({}, result.document), {
            pageStates: {
              [this.currentPageId]: __spreadProps4(__spreadValues4({}, (_g = (_f = result.document) == null ? void 0 : _f.pageStates) == null ? void 0 : _g[this.currentPageId]), {
                editingId: null
              })
            }
          })
        }), `session:complete:${session.constructor.name}`);
      }
      return this;
    };
    this.createShapes = (...shapes) => {
      if (shapes.length === 0)
        return this;
      return this.create(shapes.map((shape) => {
        return TLDR.getShapeUtil(shape.type).create(__spreadValues4({
          parentId: this.currentPageId
        }, shape));
      }));
    };
    this.updateShapes = (...shapes) => {
      const pageShapes = this.document.pages[this.currentPageId].shapes;
      const shapesToUpdate = shapes.filter((shape) => pageShapes[shape.id]);
      if (shapesToUpdate.length === 0)
        return this;
      return this.setState(updateShapes(this, shapesToUpdate, this.currentPageId), "updated_shapes");
    };
    this.create = (shapes = [], bindings = []) => {
      if (shapes.length === 0)
        return this;
      return this.setState(createShapes(this, shapes, bindings));
    };
    this.patchCreate = (shapes = [], bindings = []) => {
      if (shapes.length === 0)
        return this;
      return this.patchState(createShapes(this, shapes, bindings).after);
    };
    this.delete = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(deleteShapes(this, ids));
    };
    this.deleteAll = () => {
      this.selectAll();
      this.delete();
      return this;
    };
    this.style = (style, ids = this.selectedIds) => {
      return this.setState(styleShapes(this, ids, style));
    };
    this.align = (type, ids = this.selectedIds) => {
      if (ids.length < 2)
        return this;
      return this.setState(alignShapes(this, ids, type));
    };
    this.distribute = (direction, ids = this.selectedIds) => {
      if (ids.length < 3)
        return this;
      return this.setState(distributeShapes(this, ids, direction));
    };
    this.stretch = (direction, ids = this.selectedIds) => {
      if (ids.length < 2)
        return this;
      return this.setState(stretchShapes(this, ids, direction));
    };
    this.flipHorizontal = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(flipShapes(this, ids, FlipType.Horizontal));
    };
    this.flipVertical = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(flipShapes(this, ids, FlipType.Vertical));
    };
    this.moveToPage = (toPageId, fromPageId = this.currentPageId, ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      const { rendererBounds } = this;
      this.setState(moveShapesToPage(this, ids, rendererBounds, fromPageId, toPageId));
      return this;
    };
    this.moveToBack = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(reorderShapes(this, ids, MoveType.ToBack));
    };
    this.moveBackward = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(reorderShapes(this, ids, MoveType.Backward));
    };
    this.moveForward = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(reorderShapes(this, ids, MoveType.Forward));
    };
    this.moveToFront = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(reorderShapes(this, ids, MoveType.ToFront));
    };
    this.nudge = (delta, isMajor = false, ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      const size = isMajor ? this.settings.showGrid ? this.currentGrid * 4 : 10 : this.settings.showGrid ? this.currentGrid : 1;
      return this.setState(translateShapes(this, ids, Vec.mul(delta, size)));
    };
    this.duplicate = (ids = this.selectedIds, point) => {
      if (this.readOnly)
        return this;
      if (ids.length === 0)
        return this;
      return this.setState(duplicateShapes(this, ids, point));
    };
    this.resetBounds = (ids = this.selectedIds) => {
      const command = resetBounds(this, ids, this.currentPageId);
      return this.setState(resetBounds(this, ids, this.currentPageId), command.id);
    };
    this.toggleHidden = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(toggleShapeProp(this, ids, "isHidden"));
    };
    this.toggleLocked = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(toggleShapeProp(this, ids, "isLocked"));
    };
    this.toggleAspectRatioLocked = (ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      return this.setState(toggleShapeProp(this, ids, "isAspectRatioLocked"));
    };
    this.toggleDecoration = (handleId, ids = this.selectedIds) => {
      if (ids.length === 0 || !(handleId === "start" || handleId === "end"))
        return this;
      return this.setState(toggleShapesDecoration(this, ids, handleId));
    };
    this.setShapeProps = (props, ids = this.selectedIds) => {
      return this.setState(setShapesProps(this, ids, props));
    };
    this.rotate = (delta = Math.PI * -0.5, ids = this.selectedIds) => {
      if (ids.length === 0)
        return this;
      const change = rotateShapes(this, ids, delta);
      if (!change)
        return this;
      return this.setState(change);
    };
    this.group = (ids = this.selectedIds, groupId = Utils.uniqueId(), pageId = this.currentPageId) => {
      if (this.readOnly)
        return this;
      if (ids.length === 1 && this.getShape(ids[0], pageId).type === TDShapeType.Group) {
        return this.ungroup(ids, pageId);
      }
      if (ids.length < 2)
        return this;
      const command = groupShapes(this, ids, groupId, pageId);
      if (!command)
        return this;
      return this.setState(command);
    };
    this.ungroup = (ids = this.selectedIds, pageId = this.currentPageId) => {
      if (this.readOnly)
        return this;
      const groups = ids.map((id2) => this.getShape(id2, pageId)).filter((shape) => shape.type === TDShapeType.Group);
      if (groups.length === 0)
        return this;
      const command = ungroupShapes(this, ids, groups, pageId);
      if (!command)
        return this;
      return this.setState(command);
    };
    this.cancel = () => {
      var _a2, _b;
      (_b = (_a2 = this.currentTool).onCancel) == null ? void 0 : _b.call(_a2);
      return this;
    };
    this.onKeyDown = (key, info, e12) => {
      var _a2, _b;
      switch (e12.key) {
        case "/": {
          if (this.status === "idle") {
            const { shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;
            this.onPointerDown({
              target: "canvas",
              pointerId: 0,
              origin: info.point,
              point: info.point,
              delta: [0, 0],
              pressure: 0.5,
              shiftKey,
              ctrlKey,
              metaKey,
              altKey,
              spaceKey
            }, {
              shiftKey,
              altKey,
              ctrlKey,
              pointerId: 0,
              clientX: info.point[0],
              clientY: info.point[1]
            });
          }
          break;
        }
        case "Escape": {
          this.cancel();
          break;
        }
        case "Meta": {
          this.metaKey = true;
          break;
        }
        case "Alt": {
          this.altKey = true;
          break;
        }
        case "Control": {
          this.ctrlKey = true;
          break;
        }
        case " ": {
          this.spaceKey = true;
          break;
        }
      }
      (_b = (_a2 = this.currentTool).onKeyDown) == null ? void 0 : _b.call(_a2, key, info, e12);
      return this;
    };
    this.onKeyUp = (key, info, e12) => {
      var _a2, _b;
      if (!info)
        return;
      switch (e12.key) {
        case "/": {
          const { currentPoint, shiftKey, metaKey, altKey, ctrlKey, spaceKey } = this;
          this.onPointerUp({
            target: "canvas",
            pointerId: 0,
            origin: currentPoint,
            point: currentPoint,
            delta: [0, 0],
            pressure: 0.5,
            shiftKey,
            ctrlKey,
            metaKey,
            altKey,
            spaceKey
          }, {
            shiftKey,
            altKey,
            ctrlKey,
            pointerId: 0,
            clientX: currentPoint[0],
            clientY: currentPoint[1]
          });
          break;
        }
        case "Meta": {
          this.metaKey = false;
          break;
        }
        case "Alt": {
          this.altKey = false;
          break;
        }
        case "Control": {
          this.ctrlKey = false;
          break;
        }
        case " ": {
          this.spaceKey = false;
          break;
        }
      }
      (_b = (_a2 = this.currentTool).onKeyUp) == null ? void 0 : _b.call(_a2, key, info, e12);
    };
    this.onPinchStart = (info, e12) => {
      var _a2, _b;
      return (_b = (_a2 = this.currentTool).onPinchStart) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPinchEnd = (info, e12) => {
      var _a2, _b;
      return (_b = (_a2 = this.currentTool).onPinchEnd) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPinch = (info, e12) => {
      var _a2, _b;
      return (_b = (_a2 = this.currentTool).onPinch) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPan = (info, e12) => {
      if (this.appState.status === "pinching")
        return;
      const delta = Vec.div(info.delta, this.pageState.camera.zoom);
      const prev = this.pageState.camera.point;
      const next = Vec.sub(prev, delta);
      if (Vec.isEqual(next, prev))
        return;
      this.pan(delta);
      if (!info.spaceKey && !(e12.buttons === 4)) {
        this.onPointerMove(info, e12);
      }
    };
    this.onZoom = (info, e12) => {
      if (this.state.appState.status !== TDStatus.Idle)
        return;
      const delta = e12.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? info.delta[2] / 500 : e12.deltaMode === WheelEvent.DOM_DELTA_LINE ? info.delta[2] / 100 : info.delta[2] / 2;
      this.zoomBy(delta, this.centerPoint);
      this.onPointerMove(info, e12);
    };
    this.updateInputs = (info) => {
      this.currentPoint = [...this.getPagePoint(info.point), info.pressure];
      this.shiftKey = info.shiftKey;
      this.altKey = info.altKey;
      this.ctrlKey = info.ctrlKey;
      this.metaKey = info.metaKey;
    };
    this.onPointerMove = (info, e12) => {
      var _a2, _b, _c, _d;
      this.previousPoint = this.currentPoint;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onPointerMove) == null ? void 0 : _b.call(_a2, info, e12);
      if (this.state.room) {
        const { users, userId } = this.state.room;
        (_d = (_c = this.callbacks).onChangePresence) == null ? void 0 : _d.call(_c, this, __spreadProps4(__spreadValues4({}, users[userId]), {
          point: this.getPagePoint(info.point)
        }));
      }
    };
    this.onPointerDown = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onPointerDown) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPointerUp = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onPointerUp) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPointCanvas = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onPointCanvas) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDoubleClickCanvas = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDoubleClickCanvas) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onRightPointCanvas = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onRightPointCanvas) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDragCanvas = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDragCanvas) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onReleaseCanvas = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onReleaseCanvas) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPointShape = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onPointShape) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onReleaseShape = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onReleaseShape) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDoubleClickShape = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDoubleClickShape) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onRightPointShape = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onRightPointShape) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDragShape = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDragShape) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onHoverShape = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onHoverShape) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onUnhoverShape = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onUnhoverShape) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPointBounds = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onPointBounds) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDoubleClickBounds = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDoubleClickBounds) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onRightPointBounds = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onRightPointBounds) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDragBounds = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDragBounds) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onHoverBounds = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onHoverBounds) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onUnhoverBounds = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onUnhoverBounds) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onReleaseBounds = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onReleaseBounds) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPointBoundsHandle = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onPointBoundsHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDoubleClickBoundsHandle = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDoubleClickBoundsHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onRightPointBoundsHandle = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onRightPointBoundsHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDragBoundsHandle = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDragBoundsHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onHoverBoundsHandle = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onHoverBoundsHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onUnhoverBoundsHandle = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onUnhoverBoundsHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onReleaseBoundsHandle = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onReleaseBoundsHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onPointHandle = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onPointHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDoubleClickHandle = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDoubleClickHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onRightPointHandle = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onRightPointHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onDragHandle = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onDragHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onHoverHandle = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onHoverHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onUnhoverHandle = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onUnhoverHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onReleaseHandle = (info, e12) => {
      var _a2, _b;
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onReleaseHandle) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onShapeChange = (shape) => {
      this.updateShapes(shape);
    };
    this.onShapeBlur = () => {
      var _a2, _b;
      if (Date.now() - this.editingStartTime < 50)
        return;
      const { editingId } = this.pageState;
      const { isToolLocked } = this.getAppState();
      if (editingId) {
        const shape = this.getShape(editingId);
        this.setEditingId();
        if (shape.type === TDShapeType.Text) {
          if (shape.text.trim().length <= 0) {
            this.patchState(deleteShapes(this, [editingId]).after, "delete_empty_text");
          } else if (!isToolLocked) {
            this.select(editingId);
          }
        }
      }
      (_b = (_a2 = this.currentTool).onShapeBlur) == null ? void 0 : _b.call(_a2);
    };
    this.onShapeClone = (info, e12) => {
      var _a2, _b;
      this.originPoint = this.getPagePoint(info.point);
      this.updateInputs(info, e12);
      (_b = (_a2 = this.currentTool).onShapeClone) == null ? void 0 : _b.call(_a2, info, e12);
    };
    this.onRenderCountChange = (ids) => {
      const appState = this.getAppState();
      if (appState.isEmptyCanvas && ids.length > 0) {
        this.patchState({
          appState: {
            isEmptyCanvas: false
          }
        }, "empty_canvas:false");
      } else if (!appState.isEmptyCanvas && ids.length <= 0) {
        this.patchState({
          appState: {
            isEmptyCanvas: true
          }
        }, "empty_canvas:true");
      }
    };
    this.onError = () => {
    };
    this.getShapeUtil = TLDR.getShapeUtil;
    this.callbacks = callbacks;
  }
  setStatus(status) {
    return this.patchState({
      appState: { status }
    }, `set_status:${status}`);
  }
  get history() {
    return this.stack.slice(0, this.pointer + 1);
  }
  set history(commands) {
    this.replaceHistory(commands);
  }
  get document() {
    return this.state.document;
  }
  get settings() {
    return this.state.settings;
  }
  get appState() {
    return this.state.appState;
  }
  get currentPageId() {
    return this.state.appState.currentPageId;
  }
  get page() {
    return this.state.document.pages[this.currentPageId];
  }
  get shapes() {
    return Object.values(this.page.shapes);
  }
  get bindings() {
    return Object.values(this.page.bindings);
  }
  get pageState() {
    return this.state.document.pageStates[this.currentPageId];
  }
  get selectedIds() {
    return this.pageState.selectedIds;
  }
  createTextShapeAtPoint(point, id) {
    const {
      shapes,
      appState: { currentPageId, currentStyle }
    } = this;
    const childIndex = shapes.length === 0 ? 1 : shapes.filter((shape) => shape.parentId === currentPageId).sort((a9, b7) => b7.childIndex - a9.childIndex)[0].childIndex + 1;
    const Text2 = shapeUtils[TDShapeType.Text];
    const newShape = Text2.create({
      id: id || Utils.uniqueId(),
      parentId: currentPageId,
      childIndex,
      point,
      style: __spreadValues4({}, currentStyle)
    });
    const bounds = Text2.getBounds(newShape);
    newShape.point = Vec.sub(newShape.point, [bounds.width / 2, bounds.height / 2]);
    this.createShapes(newShape);
    this.setEditingId(newShape.id);
    return this;
  }
  isSelected(id) {
    return this.selectedIds.includes(id);
  }
  get room() {
    return this.state.room;
  }
  get isLocal() {
    return this.state.room === void 0 || this.state.room.id === "local";
  }
  get status() {
    return this.appState.status;
  }
  get currentUser() {
    if (!this.state.room)
      return;
    return this.state.room.users[this.state.room.userId];
  }
  get centerPoint() {
    const { width, height } = this.rendererBounds;
    return Vec.toFixed([width / 2, height / 2]);
  }
  get currentGrid() {
    const { zoom } = this.pageState.camera;
    if (zoom < 0.15) {
      return GRID_SIZE * 16;
    } else if (zoom < 1) {
      return GRID_SIZE * 4;
    } else {
      return GRID_SIZE * 1;
    }
  }
};
var TldrawApp = _TldrawApp;
TldrawApp.version = 14;
TldrawApp.defaultDocument = {
  id: "doc",
  name: "New Document",
  version: 14,
  pages: {
    page: {
      id: "page",
      name: "Page 1",
      childIndex: 1,
      shapes: {},
      bindings: {}
    }
  },
  pageStates: {
    page: {
      id: "page",
      selectedIds: [],
      camera: {
        point: [0, 0],
        zoom: 1
      }
    }
  }
};
TldrawApp.defaultState = {
  settings: {
    isPenMode: false,
    isDarkMode: false,
    isZoomSnap: false,
    isFocusMode: false,
    isSnapping: false,
    isDebugMode: true,
    isReadonlyMode: false,
    nudgeDistanceLarge: 16,
    nudgeDistanceSmall: 1,
    showRotateHandles: true,
    showBindingHandles: true,
    showCloneHandles: false,
    showGrid: false
  },
  appState: {
    status: TDStatus.Idle,
    activeTool: "select",
    hoveredId: void 0,
    currentPageId: "page",
    currentStyle: defaultStyle,
    isToolLocked: false,
    isMenuOpen: false,
    isEmptyCanvas: false,
    snapLines: []
  },
  document: _TldrawApp.defaultDocument
};
var tools = {
  select: SelectTool,
  erase: EraseTool,
  [TDShapeType.Text]: TextTool,
  [TDShapeType.Draw]: DrawTool,
  [TDShapeType.Ellipse]: EllipseTool,
  [TDShapeType.Rectangle]: RectangleTool,
  [TDShapeType.Triangle]: TriangleTool,
  [TDShapeType.Line]: LineTool,
  [TDShapeType.Arrow]: ArrowTool,
  [TDShapeType.Sticky]: StickyTool
};
function useKeyboardShortcuts(ref) {
  const app = useTldrawApp();
  const canHandleEvent = (0, import_react71.useCallback)((ignoreMenus = false) => {
    const elm = ref.current;
    if (ignoreMenus && app.isMenuOpen())
      return true;
    return elm && (document.activeElement === elm || elm.contains(document.activeElement));
  }, [ref]);
  useHotkeys("v,1", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("select");
  }, [app, ref.current]);
  useHotkeys("d,p,2", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool(TDShapeType.Draw);
  }, void 0, [app]);
  useHotkeys("e,3", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool("erase");
  }, void 0, [app]);
  useHotkeys("r,4", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool(TDShapeType.Rectangle);
  }, void 0, [app]);
  useHotkeys("o,5", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool(TDShapeType.Ellipse);
  }, void 0, [app]);
  useHotkeys("g,6", () => {
    if (!canHandleEvent())
      return;
    app.selectTool(TDShapeType.Triangle);
  }, void 0, [app]);
  useHotkeys("l,7", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool(TDShapeType.Line);
  }, void 0, [app]);
  useHotkeys("a,8", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool(TDShapeType.Arrow);
  }, void 0, [app]);
  useHotkeys("t,9", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool(TDShapeType.Text);
  }, void 0, [app]);
  useHotkeys("s,0", () => {
    if (!canHandleEvent(true))
      return;
    app.selectTool(TDShapeType.Sticky);
  }, void 0, [app]);
  useHotkeys("ctrl+shift+d,\u2318+shift+d", (e12) => {
    if (!canHandleEvent(true))
      return;
    app.toggleDarkMode();
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("ctrl+.,\u2318+.", () => {
    if (!canHandleEvent(true))
      return;
    app.toggleFocusMode();
  }, void 0, [app]);
  useHotkeys("ctrl+shift+g,\u2318+shift+g", () => {
    if (!canHandleEvent(true))
      return;
    app.toggleGrid();
  }, void 0, [app]);
  const { onNewProject, onOpenProject, onSaveProject, onSaveProjectAs } = useFileSystemHandlers();
  useHotkeys("ctrl+n,\u2318+n", (e12) => {
    if (!canHandleEvent())
      return;
    onNewProject(e12);
  }, void 0, [app]);
  useHotkeys("ctrl+s,\u2318+s", (e12) => {
    if (!canHandleEvent())
      return;
    onSaveProject(e12);
  }, void 0, [app]);
  useHotkeys("ctrl+shift+s,\u2318+shift+s", (e12) => {
    if (!canHandleEvent())
      return;
    onSaveProjectAs(e12);
  }, void 0, [app]);
  useHotkeys("ctrl+o,\u2318+o", (e12) => {
    if (!canHandleEvent())
      return;
    onOpenProject(e12);
  }, void 0, [app]);
  useHotkeys("\u2318+z,ctrl+z", () => {
    if (!canHandleEvent(true))
      return;
    if (app.session) {
      app.cancelSession();
    } else {
      app.undo();
    }
  }, void 0, [app]);
  useHotkeys("ctrl+shift-z,\u2318+shift+z", () => {
    if (!canHandleEvent(true))
      return;
    if (app.session) {
      app.cancelSession();
    } else {
      app.redo();
    }
  }, void 0, [app]);
  useHotkeys("\u2318+u,ctrl+u", () => {
    if (!canHandleEvent())
      return;
    app.undoSelect();
  }, void 0, [app]);
  useHotkeys("ctrl+shift-u,\u2318+shift+u", () => {
    if (!canHandleEvent())
      return;
    app.redoSelect();
  }, void 0, [app]);
  useHotkeys("ctrl+=,\u2318+=,ctrl+num_subtract,\u2318+num_subtract", (e12) => {
    if (!canHandleEvent(true))
      return;
    app.zoomIn();
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("ctrl+-,\u2318+-,ctrl+num_add,\u2318+num_add", (e12) => {
    if (!canHandleEvent(true))
      return;
    app.zoomOut();
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("shift+0,ctrl+numpad_0,\u2318+numpad_0", () => {
    if (!canHandleEvent(true))
      return;
    app.resetZoom();
  }, void 0, [app]);
  useHotkeys("shift+1", () => {
    if (!canHandleEvent(true))
      return;
    app.zoomToFit();
  }, void 0, [app]);
  useHotkeys("shift+2", () => {
    if (!canHandleEvent(true))
      return;
    app.zoomToSelection();
  }, void 0, [app]);
  useHotkeys("ctrl+d,\u2318+d", (e12) => {
    if (!canHandleEvent())
      return;
    app.duplicate();
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("shift+h", () => {
    if (!canHandleEvent(true))
      return;
    app.flipHorizontal();
  }, void 0, [app]);
  useHotkeys("shift+v", () => {
    if (!canHandleEvent(true))
      return;
    app.flipVertical();
  }, void 0, [app]);
  useHotkeys("escape", () => {
    if (!canHandleEvent(true))
      return;
    app.cancel();
  }, void 0, [app]);
  useHotkeys("backspace,del", () => {
    if (!canHandleEvent())
      return;
    app.delete();
  }, void 0, [app]);
  useHotkeys("\u2318+a,ctrl+a", () => {
    if (!canHandleEvent(true))
      return;
    app.selectAll();
  }, void 0, [app]);
  useHotkeys("up", () => {
    if (!canHandleEvent())
      return;
    app.nudge([0, -1], false);
  }, void 0, [app]);
  useHotkeys("right", () => {
    if (!canHandleEvent())
      return;
    app.nudge([1, 0], false);
  }, void 0, [app]);
  useHotkeys("down", () => {
    if (!canHandleEvent())
      return;
    app.nudge([0, 1], false);
  }, void 0, [app]);
  useHotkeys("left", () => {
    if (!canHandleEvent())
      return;
    app.nudge([-1, 0], false);
  }, void 0, [app]);
  useHotkeys("shift+up", () => {
    if (!canHandleEvent())
      return;
    app.nudge([0, -1], true);
  }, void 0, [app]);
  useHotkeys("shift+right", () => {
    if (!canHandleEvent())
      return;
    app.nudge([1, 0], true);
  }, void 0, [app]);
  useHotkeys("shift+down", () => {
    if (!canHandleEvent())
      return;
    app.nudge([0, 1], true);
  }, void 0, [app]);
  useHotkeys("shift+left", () => {
    if (!canHandleEvent())
      return;
    app.nudge([-1, 0], true);
  }, void 0, [app]);
  useHotkeys("\u2318+shift+l,ctrl+shift+l", () => {
    if (!canHandleEvent())
      return;
    app.toggleLocked();
  }, void 0, [app]);
  useHotkeys("\u2318+c,ctrl+c", () => {
    if (!canHandleEvent())
      return;
    app.copy();
  }, void 0, [app]);
  useHotkeys("\u2318+x,ctrl+x", () => {
    if (!canHandleEvent())
      return;
    app.cut();
  }, void 0, [app]);
  useHotkeys("\u2318+v,ctrl+v", () => {
    if (!canHandleEvent())
      return;
    app.paste();
  }, void 0, [app]);
  useHotkeys("\u2318+g,ctrl+g", (e12) => {
    if (!canHandleEvent())
      return;
    app.group();
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("\u2318+shift+g,ctrl+shift+g", (e12) => {
    if (!canHandleEvent())
      return;
    app.ungroup();
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("[", () => {
    if (!canHandleEvent(true))
      return;
    app.moveBackward();
  }, void 0, [app]);
  useHotkeys("]", () => {
    if (!canHandleEvent(true))
      return;
    app.moveForward();
  }, void 0, [app]);
  useHotkeys("shift+[", () => {
    if (!canHandleEvent(true))
      return;
    app.moveToBack();
  }, void 0, [app]);
  useHotkeys("shift+]", () => {
    if (!canHandleEvent(true))
      return;
    app.moveToFront();
  }, void 0, [app]);
  useHotkeys("ctrl+shift+backspace,\u2318+shift+backspace", (e12) => {
    if (!canHandleEvent())
      return;
    if (app.settings.isDebugMode) {
      app.resetDocument();
    }
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("alt+command+l,alt+ctrl+l", (e12) => {
    if (!canHandleEvent(true))
      return;
    app.style({ textAlign: AlignStyle.Start });
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("alt+command+t,alt+ctrl+t", (e12) => {
    if (!canHandleEvent(true))
      return;
    app.style({ textAlign: AlignStyle.Middle });
    e12.preventDefault();
  }, void 0, [app]);
  useHotkeys("alt+command+r,alt+ctrl+r", (e12) => {
    if (!canHandleEvent(true))
      return;
    app.style({ textAlign: AlignStyle.End });
    e12.preventDefault();
  }, void 0, [app]);
}
var TldrawContext = (0, import_react72.createContext)({});
function useTldrawApp() {
  const context2 = (0, import_react72.useContext)(TldrawContext);
  return context2;
}
var styles2 = new Map();
var UID = `Tldraw-fonts`;
var CSS = `
@import url('https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Source+Code+Pro&family=Source+Sans+Pro&family=Source+Serif+Pro&display=swap');
`;
function useStylesheet() {
  (0, import_react73.useLayoutEffect)(() => {
    if (styles2.get(UID))
      return;
    const style = document.createElement("style");
    style.innerHTML = CSS;
    style.setAttribute("id", UID);
    document.head.appendChild(style);
    styles2.set(UID, style);
    return () => {
      if (style && document.head.contains(style)) {
        document.head.removeChild(style);
        styles2.delete(UID);
      }
    };
  }, [UID, CSS]);
}
function useFileSystemHandlers() {
  const app = useTldrawApp();
  const onNewProject = (0, import_react74.useCallback)((e12) => __async(this, null, function* () {
    var _a2, _b;
    if (e12 && app.callbacks.onOpenProject)
      e12.preventDefault();
    (_b = (_a2 = app.callbacks).onNewProject) == null ? void 0 : _b.call(_a2, app);
  }), [app]);
  const onSaveProject = (0, import_react74.useCallback)((e12) => {
    var _a2, _b;
    if (e12 && app.callbacks.onOpenProject)
      e12.preventDefault();
    (_b = (_a2 = app.callbacks).onSaveProject) == null ? void 0 : _b.call(_a2, app);
  }, [app]);
  const onSaveProjectAs = (0, import_react74.useCallback)((e12) => {
    var _a2, _b;
    if (e12 && app.callbacks.onOpenProject)
      e12.preventDefault();
    (_b = (_a2 = app.callbacks).onSaveProjectAs) == null ? void 0 : _b.call(_a2, app);
  }, [app]);
  const onOpenProject = (0, import_react74.useCallback)((e12) => __async(this, null, function* () {
    var _a2, _b;
    if (e12 && app.callbacks.onOpenProject)
      e12.preventDefault();
    (_b = (_a2 = app.callbacks).onOpenProject) == null ? void 0 : _b.call(_a2, app);
  }), [app]);
  return {
    onNewProject,
    onSaveProject,
    onSaveProjectAs,
    onOpenProject
  };
}
function useFileSystem() {
  const promptSaveBeforeChange = (0, import_react75.useCallback)((app) => __async(this, null, function* () {
    if (app.isDirty) {
      if (app.fileSystemHandle) {
        if (window.confirm("\u60A8\u8981\u4FDD\u5B58\u5F53\u524D\u9879\u76EE\u5417?")) {
          yield app.saveProject();
        }
      } else {
        if (window.confirm("\u60A8\u8981\u4FDD\u5B58\u5F53\u524D\u9879\u76EE\u5417?")) {
          yield app.saveProject();
        }
      }
    }
  }), []);
  const onNewProject = (0, import_react75.useCallback)((app) => __async(this, null, function* () {
    if (window.confirm("\u786E\u5B9A\u8981\u521B\u5EFA\u65B0\u767D\u677F?")) {
      yield promptSaveBeforeChange(app);
      app.newProject();
    }
  }), [promptSaveBeforeChange]);
  const onSaveProject = (0, import_react75.useCallback)((app) => {
    app.saveProject();
  }, []);
  const onSaveProjectAs = (0, import_react75.useCallback)((app) => {
    app.saveProjectAs();
  }, []);
  const onOpenProject = (0, import_react75.useCallback)((app) => __async(this, null, function* () {
    yield promptSaveBeforeChange(app);
    app.openProject();
  }), [promptSaveBeforeChange]);
  return {
    onNewProject,
    onSaveProject,
    onSaveProjectAs,
    onOpenProject
  };
}
var breakpoints = {
  "@initial": "mobile",
  "@micro": "micro",
  "@sm": "small",
  "@md": "medium",
  "@lg": "large"
};
var statusSelector = (s8) => s8.appState.status;
var activeToolSelector = (s8) => s8.appState.activeTool;
function StatusBar() {
  const app = useTldrawApp();
  const status = app.useStore(statusSelector);
  const activeTool = app.useStore(activeToolSelector);
  return /* @__PURE__ */ (0, import_react77.createElement)(StyledStatusBar, {
    bp: breakpoints
  }, /* @__PURE__ */ (0, import_react77.createElement)(StyledSection, null, activeTool, " | ", status));
}
var StyledStatusBar = styled("div", {
  height: 40,
  userSelect: "none",
  borderTop: "1px solid $panelContrast",
  gridArea: "status",
  display: "flex",
  color: "$text",
  justifyContent: "space-between",
  alignItems: "center",
  backgroundColor: "$panel",
  gap: 8,
  fontFamily: "$ui",
  fontSize: "$0",
  padding: "0 16px",
  variants: {
    bp: {
      small: {
        fontSize: "$1"
      }
    }
  }
});
var StyledSection = styled("div", {
  whiteSpace: "nowrap",
  overflow: "hidden"
});
var commandKey = () => Utils.isDarwin() ? "\u2318" : "Ctrl";
function Kbd({
  variant,
  children
}) {
  return /* @__PURE__ */ (0, import_react80.createElement)(StyledKbd, {
    variant
  }, children.split("").map((k3, i8) => {
    return /* @__PURE__ */ (0, import_react80.createElement)("span", {
      key: i8
    }, k3.replace("#", commandKey()));
  }));
}
var StyledKbd = styled("kbd", {
  marginLeft: "$3",
  textShadow: "$2",
  textAlign: "center",
  fontSize: "$0",
  fontFamily: "$ui",
  color: "$text",
  background: "none",
  fontWeight: 400,
  gap: "$1",
  display: "flex",
  alignItems: "center",
  "& > span": {
    padding: "$0",
    borderRadius: "$0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    variant: {
      tooltip: {
        "& > span": {
          color: "$tooltipContrast",
          background: "$overlayContrast",
          boxShadow: "$key",
          width: "20px",
          height: "20px"
        }
      },
      menu: {}
    }
  }
});
var SmallIcon = styled("div", {
  height: "100%",
  borderRadius: "4px",
  marginRight: "1px",
  width: "fit-content",
  display: "grid",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  cursor: "pointer",
  color: "currentColor",
  "& svg": {
    height: 16,
    width: 16,
    strokeWidth: 1
  },
  "& > *": {
    gridRow: 1,
    gridColumn: 1
  }
});
var RowButton = (0, import_react79.forwardRef)((_a2, ref) => {
  var _b = _a2, {
    onClick,
    isActive = false,
    isWarning = false,
    hasIndicator = false,
    hasArrow = false,
    disabled = false,
    isSponsor = false,
    variant,
    kbd,
    children
  } = _b, rest = __objRest3(_b, [
    "onClick",
    "isActive",
    "isWarning",
    "hasIndicator",
    "hasArrow",
    "disabled",
    "isSponsor",
    "variant",
    "kbd",
    "children"
  ]);
  return /* @__PURE__ */ (0, import_react79.createElement)(StyledRowButton, __spreadValues4({
    ref,
    bp: breakpoints,
    isWarning,
    isActive,
    isSponsor,
    disabled,
    onClick,
    variant
  }, rest), /* @__PURE__ */ (0, import_react79.createElement)(StyledRowButtonInner, null, children, kbd ? /* @__PURE__ */ (0, import_react79.createElement)(Kbd, {
    variant: "menu"
  }, kbd) : void 0, hasIndicator && /* @__PURE__ */ (0, import_react79.createElement)(ItemIndicator2, {
    dir: "ltr"
  }, /* @__PURE__ */ (0, import_react79.createElement)(SmallIcon, null, /* @__PURE__ */ (0, import_react79.createElement)(CheckIcon, null))), hasArrow && /* @__PURE__ */ (0, import_react79.createElement)(SmallIcon, null, /* @__PURE__ */ (0, import_react79.createElement)(ChevronRightIcon, null))));
});
var StyledRowButtonInner = styled("div", {
  height: "100%",
  width: "100%",
  backgroundColor: "$panel",
  borderRadius: "$2",
  display: "flex",
  gap: "$1",
  flexDirection: "row",
  alignItems: "center",
  padding: "0 $3",
  justifyContent: "space-between",
  border: "1px solid transparent",
  "& svg": {
    position: "relative",
    stroke: "$overlay",
    strokeWidth: 1,
    zIndex: 1
  }
});
var StyledRowButton = styled("button", {
  position: "relative",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  height: "32px",
  outline: "none",
  color: "$text",
  fontFamily: "$ui",
  fontWeight: 400,
  fontSize: "$1",
  borderRadius: 4,
  userSelect: "none",
  margin: 0,
  padding: "0 0",
  "&[data-disabled]": {
    opacity: 0.3
  },
  "&:disabled": {
    opacity: 0.3
  },
  [`&:focus:not(:disabled) ${StyledRowButtonInner}`]: {
    backgroundColor: "$hover"
  },
  "& a": {
    textDecoration: "none",
    color: "$text"
  },
  variants: {
    bp: {
      mobile: {},
      small: {}
    },
    variant: {
      styleMenu: {
        margin: "$1 0 $1 0"
      },
      wide: {
        gridColumn: "1 / span 4"
      }
    },
    size: {
      icon: {
        padding: "4px ",
        width: "auto"
      }
    },
    isSponsor: {
      true: {
        color: "#eb30a2"
      },
      false: {}
    },
    isWarning: {
      true: {
        color: "$warn"
      }
    },
    isActive: {
      true: {
        backgroundColor: "$hover"
      },
      false: {}
    }
  },
  compoundVariants: [
    {
      isActive: false,
      isSponsor: true,
      bp: "small",
      css: {
        [`&:hover:not(:disabled) ${StyledRowButtonInner}`]: {
          backgroundColor: "$sponsorContrast",
          border: "1px solid $panel",
          '& *[data-shy="true"]': {
            opacity: 1
          }
        }
      }
    },
    {
      isActive: false,
      isSponsor: false,
      bp: "small",
      css: {
        [`&:hover:not(:disabled) ${StyledRowButtonInner}`]: {
          backgroundColor: "$hover",
          border: "1px solid $panel",
          '& *[data-shy="true"]': {
            opacity: 1
          }
        }
      }
    }
  ]
});
var MenuContent2 = styled("div", {
  position: "relative",
  overflow: "hidden",
  userSelect: "none",
  display: "flex",
  flexDirection: "column",
  zIndex: 180,
  minWidth: 180,
  pointerEvents: "all",
  backgroundColor: "$panel",
  boxShadow: "$panel",
  padding: "$2 $2",
  borderRadius: "$3",
  font: "$ui"
});
var isEmptyCanvasSelector = (s8) => Object.keys(s8.document.pages[s8.appState.currentPageId].shapes).length > 0 && s8.appState.isEmptyCanvas;
var BackToContent = (0, import_react78.memo)(function BackToContent2() {
  const app = useTldrawApp();
  const isEmptyCanvas = app.useStore(isEmptyCanvasSelector);
  if (!isEmptyCanvas)
    return null;
  return /* @__PURE__ */ (0, import_react78.createElement)(BackToContentContainer, null, /* @__PURE__ */ (0, import_react78.createElement)(RowButton, {
    onClick: app.zoomToContent
  }, "Back to content"));
});
var BackToContentContainer = styled(MenuContent2, {
  pointerEvents: "all",
  width: "fit-content",
  minWidth: 0,
  gridRow: 1,
  flexGrow: 2,
  display: "block"
});
function Tooltip2({
  children,
  label,
  kbd: kbdProp,
  side = "top"
}) {
  return /* @__PURE__ */ (0, import_react83.createElement)(Root7, null, /* @__PURE__ */ (0, import_react83.createElement)(Trigger2, {
    dir: "ltr",
    asChild: true
  }, /* @__PURE__ */ (0, import_react83.createElement)("span", null, children)), /* @__PURE__ */ (0, import_react83.createElement)(StyledContent, {
    dir: "ltr",
    side,
    sideOffset: 8
  }, label, kbdProp ? /* @__PURE__ */ (0, import_react83.createElement)(Kbd, {
    variant: "tooltip"
  }, kbdProp) : null, /* @__PURE__ */ (0, import_react83.createElement)(StyledArrow, null)));
}
var StyledContent = styled(Content4, {
  borderRadius: 3,
  padding: "$3 $3 $3 $3",
  fontSize: "$1",
  backgroundColor: "$tooltip",
  color: "$tooltipContrast",
  boxShadow: "$3",
  display: "flex",
  alignItems: "center",
  fontFamily: "$ui",
  userSelect: "none"
});
var StyledArrow = styled(Arrow5, {
  fill: "$tooltip",
  margin: "0 8px"
});
var ToolButton = (0, import_react82.forwardRef)((_a2, ref) => {
  var _b = _a2, {
    onSelect,
    onClick,
    onDoubleClick,
    variant,
    children,
    isToolLocked = false,
    disabled = false,
    isActive = false,
    isSponsor = false
  } = _b, rest = __objRest3(_b, [
    "onSelect",
    "onClick",
    "onDoubleClick",
    "variant",
    "children",
    "isToolLocked",
    "disabled",
    "isActive",
    "isSponsor"
  ]);
  return /* @__PURE__ */ (0, import_react82.createElement)(StyledToolButton, __spreadValues4({
    ref,
    isActive,
    isSponsor,
    variant,
    onClick,
    disabled,
    onPointerDown: onSelect,
    onDoubleClick,
    bp: breakpoints
  }, rest), /* @__PURE__ */ (0, import_react82.createElement)(StyledToolButtonInner, null, children), isToolLocked && /* @__PURE__ */ (0, import_react82.createElement)(ToolLockIndicator, null));
});
function ToolButtonWithTooltip(_a2) {
  var _b = _a2, {
    label,
    kbd,
    isLocked
  } = _b, rest = __objRest3(_b, [
    "label",
    "kbd",
    "isLocked"
  ]);
  const app = useTldrawApp();
  const handleDoubleClick = (0, import_react82.useCallback)(() => {
    app.toggleToolLock();
  }, []);
  return /* @__PURE__ */ (0, import_react82.createElement)(Tooltip2, {
    label: label[0].toUpperCase() + label.slice(1),
    kbd
  }, /* @__PURE__ */ (0, import_react82.createElement)(ToolButton, __spreadProps4(__spreadValues4({}, rest), {
    variant: "primary",
    isToolLocked: isLocked && rest.isActive,
    onDoubleClick: handleDoubleClick
  })));
}
var StyledToolButtonInner = styled("div", {
  position: "relative",
  height: "100%",
  width: "100%",
  backgroundColor: "$panel",
  borderRadius: "$2",
  margin: "0",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  fontFamily: "$ui",
  color: "inherit",
  userSelect: "none",
  boxSizing: "border-box",
  border: "1px solid transparent"
});
var StyledToolButton = styled("button", {
  position: "relative",
  color: "$text",
  fontSize: "$0",
  background: "none",
  margin: "0",
  padding: "$2",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  cursor: "pointer",
  pointerEvents: "all",
  border: "none",
  height: "40px",
  width: "40px",
  [`&:disabled ${StyledToolButtonInner}`]: {
    opacity: 0.618
  },
  variants: {
    variant: {
      primary: {
        marginTop: "0"
      },
      icon: {
        [`& ${StyledToolButtonInner}`]: {
          display: "grid",
          "& > *": {
            gridRow: 1,
            gridColumn: 1
          }
        }
      },
      text: {
        width: "auto",
        [`& ${StyledToolButtonInner}`]: {
          fontSize: "$1",
          padding: "0 $3",
          gap: "$3"
        }
      },
      circle: {
        padding: "$2",
        [`& ${StyledToolButtonInner}`]: {
          border: "1px solid $panelContrast",
          borderRadius: "100%",
          boxShadow: "$panel"
        },
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 14,
          height: 14
        }
      }
    },
    isSponsor: {
      true: {
        [`${StyledToolButtonInner}`]: {
          backgroundColor: "$sponsorContrast"
        }
      }
    },
    isActive: {
      true: {},
      false: {}
    },
    bp: {
      mobile: {},
      small: {}
    }
  },
  compoundVariants: [
    {
      variant: "primary",
      bp: "mobile",
      css: {
        height: "40px",
        width: "40px",
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 16,
          height: 16
        }
      }
    },
    {
      variant: "primary",
      bp: "small",
      css: {
        height: "44px",
        width: "44px",
        [`& ${StyledToolButtonInner} > svg`]: {
          width: 20,
          height: 20
        }
      }
    },
    {
      isActive: true,
      isSponsor: false,
      css: {
        [`${StyledToolButtonInner}`]: {
          backgroundColor: "$selected",
          color: "$selectedContrast"
        }
      }
    },
    {
      isActive: false,
      isSponsor: false,
      bp: "small",
      css: {
        [`&:hover:not(:disabled) ${StyledToolButtonInner}`]: {
          backgroundColor: "$hover",
          border: "1px solid $panel"
        },
        [`&:focus:not(:disabled) ${StyledToolButtonInner}`]: {
          backgroundColor: "$hover"
        }
      }
    }
  ]
});
var ToolLockIndicator = styled("div", {
  position: "absolute",
  width: 10,
  height: 10,
  backgroundColor: "$selected",
  borderRadius: "100%",
  bottom: -2,
  border: "2px solid $panel",
  zIndex: 100
});
var Panel = styled("div", {
  backgroundColor: "$panel",
  display: "flex",
  flexDirection: "row",
  boxShadow: "$panel",
  padding: "$2",
  border: "1px solid $panelContrast",
  gap: 0,
  variants: {
    side: {
      center: {
        borderRadius: "$4"
      },
      left: {
        padding: 0,
        borderTop: 0,
        borderLeft: 0,
        borderTopRightRadius: "$1",
        borderBottomRightRadius: "$3",
        borderBottomLeftRadius: "$1"
      },
      right: {
        padding: 0,
        borderTop: 0,
        borderRight: 0,
        borderTopLeftRadius: "$1",
        borderBottomLeftRadius: "$3",
        borderBottomRightRadius: "$1"
      }
    }
  }
});
function CircleIcon2(props) {
  const _a2 = props, { size = 16 } = _a2, rest = __objRest3(_a2, ["size"]);
  return /* @__PURE__ */ (0, import_react86.createElement)("svg", __spreadValues4({
    width: 24,
    height: 24
  }, rest), /* @__PURE__ */ (0, import_react86.createElement)("circle", {
    cx: 12,
    cy: 12,
    r: size / 2
  }));
}
function DashDashedIcon() {
  return /* @__PURE__ */ (0, import_react87.createElement)("svg", {
    width: "24",
    height: "24",
    stroke: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ (0, import_react87.createElement)("circle", {
    cx: 12,
    cy: 12,
    r: 8,
    fill: "none",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeDasharray: 50.26548 * 0.1
  }));
}
var dottedDasharray = `${50.26548 * 0.025} ${50.26548 * 0.1}`;
function DashDottedIcon() {
  return /* @__PURE__ */ (0, import_react88.createElement)("svg", {
    width: "24",
    height: "24",
    stroke: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ (0, import_react88.createElement)("circle", {
    cx: 12,
    cy: 12,
    r: 8,
    fill: "none",
    strokeWidth: 2.5,
    strokeLinecap: "round",
    strokeDasharray: dottedDasharray
  }));
}
function DashDrawIcon() {
  return /* @__PURE__ */ (0, import_react89.createElement)("svg", {
    width: "24",
    height: "24",
    viewBox: "1 1.5 21 22",
    fill: "currentColor",
    stroke: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ (0, import_react89.createElement)("path", {
    d: "M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z",
    strokeWidth: "2"
  }));
}
function DashSolidIcon() {
  return /* @__PURE__ */ (0, import_react90.createElement)("svg", {
    width: "24",
    height: "24",
    stroke: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ (0, import_react90.createElement)("circle", {
    cx: 12,
    cy: 12,
    r: 8,
    fill: "none",
    strokeWidth: 2,
    strokeLinecap: "round"
  }));
}
function RedoIcon(props) {
  return /* @__PURE__ */ (0, import_react92.createElement)("svg", __spreadValues4({
    width: 32,
    height: 32,
    viewBox: "0 0 15 15",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ (0, import_react92.createElement)("path", {
    d: "M4.32978 8.5081C4.32978 10.1923 5.70009 11.5625 7.38418 11.5625H8.46539C8.64456 11.5625 8.78975 11.4173 8.78975 11.2382V11.13C8.78975 10.9508 8.64457 10.8057 8.46539 10.8057H7.38418C6.11736 10.8057 5.08662 9.77492 5.08662 8.5081C5.08662 7.24128 6.11736 6.21054 7.38418 6.21054H9.37894L8.00515 7.58433C7.8576 7.73183 7.8576 7.97195 8.00515 8.11944C8.14833 8.26251 8.39751 8.2623 8.54036 8.11944L10.56 6.09971C10.6315 6.02824 10.6709 5.93321 10.6709 5.8321C10.6709 5.73106 10.6315 5.63598 10.56 5.56454L8.54025 3.54472C8.3974 3.40176 8.14801 3.40176 8.00513 3.54472C7.85758 3.69218 7.85758 3.93234 8.00513 4.07979L9.37892 5.45368H7.38418C5.70009 5.45368 4.32978 6.82393 4.32978 8.5081Z"
  }));
}
function TrashIcon(props) {
  return /* @__PURE__ */ (0, import_react93.createElement)("svg", __spreadValues4({
    width: 18,
    height: 18,
    viewBox: "0 0 15 15",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ (0, import_react93.createElement)("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z"
  }), /* @__PURE__ */ (0, import_react93.createElement)("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z"
  }), /* @__PURE__ */ (0, import_react93.createElement)("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z"
  }));
}
function UndoIcon(props) {
  return /* @__PURE__ */ (0, import_react94.createElement)("svg", __spreadValues4({
    width: 32,
    height: 32,
    viewBox: "0 0 15 15",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ (0, import_react94.createElement)("path", {
    d: "M10.6707 8.5081C10.6707 10.1923 9.3004 11.5625 7.61631 11.5625H6.5351C6.35593 11.5625 6.21074 11.4173 6.21074 11.2382V11.13C6.21074 10.9508 6.35591 10.8057 6.5351 10.8057H7.61631C8.88313 10.8057 9.91387 9.77492 9.91387 8.5081C9.91387 7.24128 8.88313 6.21054 7.61631 6.21054H5.62155L6.99534 7.58433C7.14289 7.73183 7.14289 7.97195 6.99534 8.11944C6.85216 8.26251 6.60298 8.2623 6.46013 8.11944L4.44045 6.09971C4.36898 6.02824 4.32959 5.93321 4.32959 5.8321C4.32959 5.73106 4.36898 5.63598 4.44045 5.56454L6.46024 3.54472C6.60309 3.40176 6.85248 3.40176 6.99535 3.54472C7.14291 3.69218 7.14291 3.93234 6.99535 4.07979L5.62156 5.45368H7.61631C9.3004 5.45368 10.6707 6.82393 10.6707 8.5081Z"
  }));
}
function SizeSmallIcon(props) {
  return /* @__PURE__ */ (0, import_react95.createElement)("svg", __spreadValues4({
    width: 24,
    height: 24,
    viewBox: "-2 -2 28 28",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ (0, import_react95.createElement)("path", {
    d: "M12.4239 4.62C13.3572 4.62 14.1572 4.73333 14.8239 4.96C15.4906 5.17333 15.9772 5.43333 16.2839 5.74C16.3639 5.82 16.4039 5.94 16.4039 6.1V8.86H14.0639C13.9172 8.86 13.8439 8.78666 13.8439 8.64V7.26C13.4306 7.12666 12.9572 7.06 12.4239 7.06C11.6506 7.06 11.0639 7.18 10.6639 7.42C10.2639 7.66 10.0639 8.04666 10.0639 8.58V9C10.0639 9.38666 10.1639 9.69333 10.3639 9.92C10.5772 10.1333 11.0306 10.3467 11.7239 10.56L13.6439 11.14C14.4706 11.38 15.1172 11.66 15.5839 11.98C16.0506 12.3 16.3772 12.68 16.5639 13.12C16.7639 13.5467 16.8639 14.0733 16.8639 14.7V15.62C16.8639 16.7933 16.4039 17.7133 15.4839 18.38C14.5639 19.0467 13.2839 19.38 11.6439 19.38C10.6706 19.38 9.79723 19.2867 9.0239 19.1C8.2639 18.9133 7.71056 18.6533 7.3639 18.32C7.3239 18.28 7.29056 18.24 7.2639 18.2C7.25056 18.1467 7.2439 18.06 7.2439 17.94V15.74H7.6239C8.2239 16.1533 8.85056 16.4533 9.5039 16.64C10.1572 16.8267 10.9306 16.92 11.8239 16.92C12.6506 16.92 13.2506 16.7867 13.6239 16.52C14.0106 16.2533 14.2039 15.9333 14.2039 15.56V14.88C14.2039 14.6667 14.1639 14.48 14.0839 14.32C14.0172 14.16 13.8706 14.0133 13.6439 13.88C13.4172 13.7467 13.0572 13.6067 12.5639 13.46L10.6639 12.88C9.7839 12.6133 9.11056 12.3 8.6439 11.94C8.17723 11.58 7.85056 11.18 7.6639 10.74C7.49056 10.3 7.4039 9.83333 7.4039 9.34V8.38C7.4039 7.64666 7.61056 7 8.0239 6.44C8.43723 5.88 9.01723 5.44 9.7639 5.12C10.5239 4.78666 11.4106 4.62 12.4239 4.62Z"
  }));
}
function SizeMediumIcon(props) {
  return /* @__PURE__ */ (0, import_react96.createElement)("svg", __spreadValues4({
    width: 24,
    height: 24,
    viewBox: "-2 -2 28 28",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ (0, import_react96.createElement)("path", {
    d: "M8.16191 19H5.68191C5.53525 19 5.46191 18.9267 5.46191 18.78V5H8.76191C8.88191 5 8.97525 5.03333 9.04191 5.1C9.10858 5.15333 9.17525 5.27333 9.24191 5.46C9.72191 6.59333 10.1686 7.7 10.5819 8.78C11.0086 9.84667 11.4352 10.98 11.8619 12.18H12.1619C12.6019 10.9667 13.0352 9.79333 13.4619 8.66C13.8886 7.52667 14.3552 6.30667 14.8619 5H18.3219C18.4686 5 18.5419 5.07333 18.5419 5.22V19H16.0619C15.9152 19 15.8419 18.9267 15.8419 18.78V16.26C15.8419 15.5267 15.8486 14.8133 15.8619 14.12C15.8886 13.4267 15.9286 12.6867 15.9819 11.9C16.0486 11.1 16.1419 10.1933 16.2619 9.18H15.9019C15.4352 10.3533 14.9486 11.5667 14.4419 12.82C13.9486 14.06 13.4819 15.2333 13.0419 16.34H11.1019C11.0619 16.34 11.0152 16.3333 10.9619 16.32C10.9219 16.2933 10.8886 16.2467 10.8619 16.18C10.4619 15.18 10.0086 14.06 9.50191 12.82C9.00858 11.58 8.53525 10.3667 8.08191 9.18H7.70191C7.83525 10.18 7.93525 11.0733 8.00191 11.86C8.06858 12.6467 8.10858 13.3933 8.12191 14.1C8.14858 14.8067 8.16191 15.5267 8.16191 16.26V19Z"
  }));
}
function SizeLargeIcon(props) {
  return /* @__PURE__ */ (0, import_react97.createElement)("svg", __spreadValues4({
    width: 24,
    height: 24,
    viewBox: "-2 -2 28 28",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /* @__PURE__ */ (0, import_react97.createElement)("path", {
    d: "M7.68191 19C7.53525 19 7.46191 18.9267 7.46191 18.78V5H10.1219C10.2686 5 10.3419 5.07333 10.3419 5.22V16.56H13.4419V15.02H15.7619C15.9086 15.02 15.9819 15.0933 15.9819 15.24V19H7.68191Z"
  }));
}
function EraserIcon() {
  return /* @__PURE__ */ (0, import_react98.createElement)("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ (0, import_react98.createElement)("path", {
    d: "M1.72838 9.33987L8.84935 2.34732C9.23874 1.96494 9.86279 1.96539 10.2516 2.34831L13.5636 5.60975C13.9655 6.00555 13.9607 6.65526 13.553 7.04507L8.13212 12.2278C7.94604 12.4057 7.69851 12.505 7.44107 12.505L6.06722 12.505L3.83772 12.505C3.5673 12.505 3.30842 12.3954 3.12009 12.2014L1.7114 10.7498C1.32837 10.3551 1.33596 9.72521 1.72838 9.33987Z",
    stroke: "currentColor"
  }), /* @__PURE__ */ (0, import_react98.createElement)("line", {
    x1: "6.01807",
    y1: "12.5",
    x2: "10.7959",
    y2: "12.5",
    stroke: "currentColor",
    strokeLinecap: "round"
  }), /* @__PURE__ */ (0, import_react98.createElement)("line", {
    x1: "5.50834",
    y1: "5.74606",
    x2: "10.1984",
    y2: "10.4361",
    stroke: "currentColor"
  }));
}
function LineIcon() {
  return /* @__PURE__ */ (0, import_react101.createElement)("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ (0, import_react101.createElement)("path", {
    d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L11.1464 3.14645C11.3417 2.95118 11.6583 2.95118 11.8536 3.14645C12.0488 3.34171 12.0488 3.65829 11.8536 3.85355L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z"
  }));
}
var shapeShapes = [TDShapeType.Rectangle, TDShapeType.Ellipse, TDShapeType.Triangle, TDShapeType.Line];
var shapeShapeIcons = {
  [TDShapeType.Rectangle]: /* @__PURE__ */ (0, import_react84.createElement)(SquareIcon, null),
  [TDShapeType.Ellipse]: /* @__PURE__ */ (0, import_react84.createElement)(CircleIcon, null),
  [TDShapeType.Triangle]: /* @__PURE__ */ (0, import_react84.createElement)(VercelLogoIcon, null),
  [TDShapeType.Line]: /* @__PURE__ */ (0, import_react84.createElement)(LineIcon, null)
};
var ShapesMenu = (0, import_react84.memo)(function ShapesMenu2({
  activeTool,
  isToolLocked
}) {
  const app = useTldrawApp();
  const [lastActiveTool, setLastActiveTool] = (0, import_react84.useState)(TDShapeType.Rectangle);
  (0, import_react84.useEffect)(() => {
    if (shapeShapes.includes(activeTool) && lastActiveTool !== activeTool) {
      setLastActiveTool(activeTool);
    }
  }, [activeTool]);
  const selectShapeTool = (0, import_react84.useCallback)(() => {
    app.selectTool(lastActiveTool);
  }, [activeTool, app]);
  const handleDoubleClick = (0, import_react84.useCallback)(() => {
    app.toggleToolLock();
  }, [app]);
  const isActive = shapeShapes.includes(activeTool);
  return /* @__PURE__ */ (0, import_react84.createElement)(Root5, {
    dir: "ltr",
    onOpenChange: selectShapeTool
  }, /* @__PURE__ */ (0, import_react84.createElement)(Trigger, {
    dir: "ltr",
    asChild: true
  }, /* @__PURE__ */ (0, import_react84.createElement)(ToolButton, {
    variant: "primary",
    onDoubleClick: handleDoubleClick,
    isToolLocked: isActive && isToolLocked,
    isActive
  }, shapeShapeIcons[lastActiveTool])), /* @__PURE__ */ (0, import_react84.createElement)(Content3, {
    asChild: true,
    dir: "ltr",
    side: "top",
    sideOffset: 12
  }, /* @__PURE__ */ (0, import_react84.createElement)(Panel, {
    side: "center"
  }, shapeShapes.map((shape, i8) => /* @__PURE__ */ (0, import_react84.createElement)(Tooltip2, {
    key: shape,
    label: shape[0].toUpperCase() + shape.slice(1),
    kbd: (4 + i8).toString()
  }, /* @__PURE__ */ (0, import_react84.createElement)(Item3, {
    asChild: true
  }, /* @__PURE__ */ (0, import_react84.createElement)(ToolButton, {
    variant: "primary",
    onClick: () => {
      app.selectTool(shape);
      setLastActiveTool(shape);
    }
  }, shapeShapeIcons[shape])))))));
});
var activeToolSelector2 = (s8) => s8.appState.activeTool;
var toolLockedSelector = (s8) => s8.appState.isToolLocked;
var PrimaryTools = (0, import_react81.memo)(function PrimaryTools2() {
  const app = useTldrawApp();
  const activeTool = app.useStore(activeToolSelector2);
  const isToolLocked = app.useStore(toolLockedSelector);
  const selectSelectTool = (0, import_react81.useCallback)(() => {
    app.selectTool("select");
  }, [app]);
  const selectEraseTool = (0, import_react81.useCallback)(() => {
    app.selectTool("erase");
  }, [app]);
  const selectDrawTool = (0, import_react81.useCallback)(() => {
    app.selectTool(TDShapeType.Draw);
  }, [app]);
  const selectArrowTool = (0, import_react81.useCallback)(() => {
    app.selectTool(TDShapeType.Arrow);
  }, [app]);
  const selectTextTool = (0, import_react81.useCallback)(() => {
    app.selectTool(TDShapeType.Text);
  }, [app]);
  const selectStickyTool = (0, import_react81.useCallback)(() => {
    app.selectTool(TDShapeType.Sticky);
  }, [app]);
  return /* @__PURE__ */ (0, import_react81.createElement)(Panel, {
    side: "center"
  }, /* @__PURE__ */ (0, import_react81.createElement)(ToolButtonWithTooltip, {
    kbd: "1",
    label: "select",
    onClick: selectSelectTool,
    isActive: activeTool === "select"
  }, /* @__PURE__ */ (0, import_react81.createElement)(CursorArrowIcon, null)), /* @__PURE__ */ (0, import_react81.createElement)(ToolButtonWithTooltip, {
    kbd: "2",
    label: TDShapeType.Draw,
    onClick: selectDrawTool,
    isActive: activeTool === TDShapeType.Draw
  }, /* @__PURE__ */ (0, import_react81.createElement)(Pencil1Icon, null)), /* @__PURE__ */ (0, import_react81.createElement)(ToolButtonWithTooltip, {
    kbd: "3",
    label: "eraser",
    onClick: selectEraseTool,
    isActive: activeTool === "erase"
  }, /* @__PURE__ */ (0, import_react81.createElement)(EraserIcon, null)), /* @__PURE__ */ (0, import_react81.createElement)(ShapesMenu, {
    activeTool,
    isToolLocked
  }), /* @__PURE__ */ (0, import_react81.createElement)(ToolButtonWithTooltip, {
    kbd: "8",
    label: TDShapeType.Arrow,
    onClick: selectArrowTool,
    isLocked: isToolLocked,
    isActive: activeTool === TDShapeType.Arrow
  }, /* @__PURE__ */ (0, import_react81.createElement)(ArrowTopRightIcon, null)), /* @__PURE__ */ (0, import_react81.createElement)(ToolButtonWithTooltip, {
    kbd: "9",
    label: TDShapeType.Text,
    onClick: selectTextTool,
    isLocked: isToolLocked,
    isActive: activeTool === TDShapeType.Text
  }, /* @__PURE__ */ (0, import_react81.createElement)(TextIcon, null)), /* @__PURE__ */ (0, import_react81.createElement)(ToolButtonWithTooltip, {
    kbd: "0",
    label: TDShapeType.Sticky,
    onClick: selectStickyTool,
    isActive: activeTool === TDShapeType.Sticky
  }, /* @__PURE__ */ (0, import_react81.createElement)(Pencil2Icon, null)));
});
var DMArrow = styled(Arrow4, { fill: "$panel", bp: breakpoints });
function DMItem(_a2) {
  var _b = _a2, {
    onSelect
  } = _b, rest = __objRest3(_b, [
    "onSelect"
  ]);
  return /* @__PURE__ */ (0, import_react103.createElement)(Item3, {
    dir: "ltr",
    asChild: true,
    onSelect
  }, /* @__PURE__ */ (0, import_react103.createElement)(RowButton, __spreadValues4({}, rest)));
}
var preventEvent = (e12) => e12.preventDefault();
function DMCheckboxItem({
  checked,
  disabled = false,
  variant,
  onCheckedChange,
  kbd,
  children
}) {
  return /* @__PURE__ */ (0, import_react104.createElement)(CheckboxItem2, {
    dir: "ltr",
    onSelect: preventEvent,
    onCheckedChange,
    checked,
    disabled,
    asChild: true
  }, /* @__PURE__ */ (0, import_react104.createElement)(RowButton, {
    kbd,
    variant,
    hasIndicator: true
  }, children));
}
function DMContent({
  sideOffset = 8,
  children,
  align,
  variant
}) {
  return /* @__PURE__ */ (0, import_react105.createElement)(Content3, {
    dir: "ltr",
    align,
    sideOffset,
    onEscapeKeyDown: stopPropagation,
    asChild: true
  }, /* @__PURE__ */ (0, import_react105.createElement)(StyledContent2, {
    variant
  }, children));
}
var StyledContent2 = styled(MenuContent2, {
  width: "fit-content",
  height: "fit-content",
  minWidth: 0,
  variants: {
    variant: {
      horizontal: {
        flexDirection: "row"
      },
      menu: {
        minWidth: 128
      }
    }
  }
});
var DMDivider = styled(Separator2, {
  backgroundColor: "$hover",
  height: 1,
  marginTop: "$2",
  marginRight: "-$2",
  marginBottom: "$2",
  marginLeft: "-$2"
});
var DMRadioItem = styled(RadioItem2, {
  height: "32px",
  width: "32px",
  backgroundColor: "$panel",
  borderRadius: "4px",
  padding: "0",
  margin: "0",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  cursor: "pointer",
  variants: {
    isActive: {
      true: {
        backgroundColor: "$selected",
        color: "$panel"
      },
      false: {}
    },
    bp: {
      mobile: {},
      small: {}
    }
  },
  compoundVariants: [
    {
      isActive: false,
      bp: "small",
      css: {
        "&:focus": {
          backgroundColor: "$hover"
        },
        "&:hover:not(:disabled)": {
          backgroundColor: "$hover"
        }
      }
    }
  ]
});
function DMSubMenu({ children, disabled = false, label }) {
  return /* @__PURE__ */ (0, import_react106.createElement)(Root5, {
    dir: "ltr"
  }, /* @__PURE__ */ (0, import_react106.createElement)(TriggerItem, {
    dir: "ltr",
    asChild: true
  }, /* @__PURE__ */ (0, import_react106.createElement)(RowButton, {
    disabled,
    hasArrow: true
  }, label)), /* @__PURE__ */ (0, import_react106.createElement)(Content3, {
    dir: "ltr",
    asChild: true,
    sideOffset: 2,
    alignOffset: -2
  }, /* @__PURE__ */ (0, import_react106.createElement)(MenuContent2, null, children, /* @__PURE__ */ (0, import_react106.createElement)(Arrow4, {
    offset: 13
  }))));
}
function DMTriggerIcon(_a2) {
  var _b = _a2, { children } = _b, rest = __objRest3(_b, ["children"]);
  return /* @__PURE__ */ (0, import_react107.createElement)(Trigger, {
    asChild: true
  }, /* @__PURE__ */ (0, import_react107.createElement)(ToolButton, __spreadValues4({}, rest), children));
}
var Divider = styled("hr", {
  height: 1,
  marginTop: "$1",
  marginRight: "-$2",
  marginBottom: "$1",
  marginLeft: "-$2",
  border: "none",
  borderBottom: "1px solid $hover"
});
var selectedShapesCountSelector = (s8) => s8.document.pageStates[s8.appState.currentPageId].selectedIds.length;
var isAllLockedSelector = (s8) => {
  const page = s8.document.pages[s8.appState.currentPageId];
  const { selectedIds } = s8.document.pageStates[s8.appState.currentPageId];
  return selectedIds.every((id) => page.shapes[id].isLocked);
};
var isAllAspectLockedSelector = (s8) => {
  const page = s8.document.pages[s8.appState.currentPageId];
  const { selectedIds } = s8.document.pageStates[s8.appState.currentPageId];
  return selectedIds.every((id) => page.shapes[id].isAspectRatioLocked);
};
var isAllGroupedSelector = (s8) => {
  const page = s8.document.pages[s8.appState.currentPageId];
  const selectedShapes = s8.document.pageStates[s8.appState.currentPageId].selectedIds.map((id) => page.shapes[id]);
  return selectedShapes.every((shape) => shape.children !== void 0 || shape.parentId === selectedShapes[0].parentId && selectedShapes[0].parentId !== s8.appState.currentPageId);
};
var hasSelectionSelector = (s8) => {
  const { selectedIds } = s8.document.pageStates[s8.appState.currentPageId];
  return selectedIds.length > 0;
};
var hasMultipleSelectionSelector = (s8) => {
  const { selectedIds } = s8.document.pageStates[s8.appState.currentPageId];
  return selectedIds.length > 1;
};
function ActionButton() {
  const app = useTldrawApp();
  const isAllLocked = app.useStore(isAllLockedSelector);
  const isAllAspectLocked = app.useStore(isAllAspectLockedSelector);
  const isAllGrouped = app.useStore(isAllGroupedSelector);
  const hasSelection = app.useStore(hasSelectionSelector);
  const hasMultipleSelection = app.useStore(hasMultipleSelectionSelector);
  const selectedShapesCount = app.useStore(selectedShapesCountSelector);
  const hasTwoOrMore = selectedShapesCount > 1;
  const hasThreeOrMore = selectedShapesCount > 2;
  const handleRotate = (0, import_react102.useCallback)(() => {
    app.rotate();
  }, [app]);
  const handleDuplicate = (0, import_react102.useCallback)(() => {
    app.duplicate();
  }, [app]);
  const handleToggleLocked = (0, import_react102.useCallback)(() => {
    app.toggleLocked();
  }, [app]);
  const handleToggleAspectRatio = (0, import_react102.useCallback)(() => {
    app.toggleAspectRatioLocked();
  }, [app]);
  const handleGroup = (0, import_react102.useCallback)(() => {
    app.group();
  }, [app]);
  const handleMoveToBack = (0, import_react102.useCallback)(() => {
    app.moveToBack();
  }, [app]);
  const handleMoveBackward = (0, import_react102.useCallback)(() => {
    app.moveBackward();
  }, [app]);
  const handleMoveForward = (0, import_react102.useCallback)(() => {
    app.moveForward();
  }, [app]);
  const handleMoveToFront = (0, import_react102.useCallback)(() => {
    app.moveToFront();
  }, [app]);
  const handleResetAngle = (0, import_react102.useCallback)(() => {
    app.setShapeProps({ rotation: 0 });
  }, [app]);
  const alignTop = (0, import_react102.useCallback)(() => {
    app.align(AlignType.Top);
  }, [app]);
  const alignCenterVertical = (0, import_react102.useCallback)(() => {
    app.align(AlignType.CenterVertical);
  }, [app]);
  const alignBottom = (0, import_react102.useCallback)(() => {
    app.align(AlignType.Bottom);
  }, [app]);
  const stretchVertically = (0, import_react102.useCallback)(() => {
    app.stretch(StretchType.Vertical);
  }, [app]);
  const distributeVertically = (0, import_react102.useCallback)(() => {
    app.distribute(DistributeType.Vertical);
  }, [app]);
  const alignLeft = (0, import_react102.useCallback)(() => {
    app.align(AlignType.Left);
  }, [app]);
  const alignCenterHorizontal = (0, import_react102.useCallback)(() => {
    app.align(AlignType.CenterHorizontal);
  }, [app]);
  const alignRight = (0, import_react102.useCallback)(() => {
    app.align(AlignType.Right);
  }, [app]);
  const stretchHorizontally = (0, import_react102.useCallback)(() => {
    app.stretch(StretchType.Horizontal);
  }, [app]);
  const distributeHorizontally = (0, import_react102.useCallback)(() => {
    app.distribute(DistributeType.Horizontal);
  }, [app]);
  const handleMenuOpenChange = (0, import_react102.useCallback)((open) => {
    app.setMenuOpen(open);
  }, [app]);
  return /* @__PURE__ */ (0, import_react102.createElement)(Root5, {
    dir: "ltr",
    onOpenChange: handleMenuOpenChange
  }, /* @__PURE__ */ (0, import_react102.createElement)(Trigger, {
    dir: "ltr",
    asChild: true
  }, /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    variant: "circle"
  }, /* @__PURE__ */ (0, import_react102.createElement)(DotsHorizontalIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(DMContent, {
    sideOffset: 16
  }, /* @__PURE__ */ (0, import_react102.createElement)(import_react102.Fragment, null, /* @__PURE__ */ (0, import_react102.createElement)(ButtonsRow, null, /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    variant: "icon",
    disabled: !hasSelection,
    onClick: handleDuplicate
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Duplicate",
    kbd: `#D`
  }, /* @__PURE__ */ (0, import_react102.createElement)(CopyIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection,
    onClick: handleRotate
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Rotate"
  }, /* @__PURE__ */ (0, import_react102.createElement)(RotateCounterClockwiseIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection,
    onClick: handleToggleLocked
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Toggle Locked",
    kbd: `#L`
  }, isAllLocked ? /* @__PURE__ */ (0, import_react102.createElement)(LockClosedIcon, null) : /* @__PURE__ */ (0, import_react102.createElement)(LockOpen1Icon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection,
    onClick: handleToggleAspectRatio
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Toggle Aspect Ratio Lock"
  }, isAllAspectLocked ? /* @__PURE__ */ (0, import_react102.createElement)(AspectRatioIcon, null) : /* @__PURE__ */ (0, import_react102.createElement)(BoxIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection || !isAllGrouped && !hasMultipleSelection,
    onClick: handleGroup
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Group",
    kbd: `#G`
  }, /* @__PURE__ */ (0, import_react102.createElement)(GroupIcon, null)))), /* @__PURE__ */ (0, import_react102.createElement)(ButtonsRow, null, /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection,
    onClick: handleMoveToBack
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Move to Back",
    kbd: `#\u21E7[`
  }, /* @__PURE__ */ (0, import_react102.createElement)(PinBottomIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection,
    onClick: handleMoveBackward
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Move Backward",
    kbd: `#[`
  }, /* @__PURE__ */ (0, import_react102.createElement)(ArrowDownIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection,
    onClick: handleMoveForward
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Move Forward",
    kbd: `#]`
  }, /* @__PURE__ */ (0, import_react102.createElement)(ArrowUpIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection,
    onClick: handleMoveToFront
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Move to Front",
    kbd: `#\u21E7]`
  }, /* @__PURE__ */ (0, import_react102.createElement)(PinTopIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasSelection,
    onClick: handleResetAngle
  }, /* @__PURE__ */ (0, import_react102.createElement)(Tooltip2, {
    label: "Reset Angle"
  }, /* @__PURE__ */ (0, import_react102.createElement)(AngleIcon, null)))), /* @__PURE__ */ (0, import_react102.createElement)(Divider, null), /* @__PURE__ */ (0, import_react102.createElement)(ButtonsRow, null, /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignLeft
  }, /* @__PURE__ */ (0, import_react102.createElement)(AlignLeftIcon, null)), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignCenterHorizontal
  }, /* @__PURE__ */ (0, import_react102.createElement)(AlignCenterHorizontallyIcon, null)), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignRight
  }, /* @__PURE__ */ (0, import_react102.createElement)(AlignRightIcon, null)), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: stretchHorizontally
  }, /* @__PURE__ */ (0, import_react102.createElement)(StretchHorizontallyIcon, null)), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasThreeOrMore,
    onClick: distributeHorizontally
  }, /* @__PURE__ */ (0, import_react102.createElement)(SpaceEvenlyHorizontallyIcon, null))), /* @__PURE__ */ (0, import_react102.createElement)(ButtonsRow, null, /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignTop
  }, /* @__PURE__ */ (0, import_react102.createElement)(AlignTopIcon, null)), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignCenterVertical
  }, /* @__PURE__ */ (0, import_react102.createElement)(AlignCenterVerticallyIcon, null)), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: alignBottom
  }, /* @__PURE__ */ (0, import_react102.createElement)(AlignBottomIcon, null)), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasTwoOrMore,
    onClick: stretchVertically
  }, /* @__PURE__ */ (0, import_react102.createElement)(StretchVerticallyIcon, null)), /* @__PURE__ */ (0, import_react102.createElement)(ToolButton, {
    disabled: !hasThreeOrMore,
    onClick: distributeVertically
  }, /* @__PURE__ */ (0, import_react102.createElement)(SpaceEvenlyVerticallyIcon, null))))));
}
var ButtonsRow = styled("div", {
  position: "relative",
  display: "flex",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  outline: "none",
  alignItems: "center",
  justifyContent: "flex-start",
  padding: 0
});
function DeleteButton() {
  const app = useTldrawApp();
  const handleDelete = (0, import_react109.useCallback)(() => {
    app.delete();
  }, [app]);
  const hasSelection = app.useStore((s8) => s8.appState.status === "idle" && s8.document.pageStates[s8.appState.currentPageId].selectedIds.length > 0);
  return /* @__PURE__ */ (0, import_react109.createElement)(Tooltip2, {
    label: "Delete",
    kbd: "\u232B"
  }, /* @__PURE__ */ (0, import_react109.createElement)(ToolButton, {
    variant: "circle",
    disabled: !hasSelection,
    onSelect: handleDelete
  }, /* @__PURE__ */ (0, import_react109.createElement)(TrashIcon, null)));
}
var isDebugModeSelector = (s8) => s8.settings.isDebugMode;
var ToolsPanel = (0, import_react76.memo)(function ToolsPanel2({ onBlur }) {
  const app = useTldrawApp();
  const isDebugMode = app.useStore(isDebugModeSelector);
  return /* @__PURE__ */ (0, import_react76.createElement)(StyledToolsPanelContainer, {
    onBlur
  }, /* @__PURE__ */ (0, import_react76.createElement)(StyledCenterWrap, null, /* @__PURE__ */ (0, import_react76.createElement)(BackToContent, null), /* @__PURE__ */ (0, import_react76.createElement)(StyledPrimaryTools, null, /* @__PURE__ */ (0, import_react76.createElement)(ActionButton, null), /* @__PURE__ */ (0, import_react76.createElement)(PrimaryTools, null), /* @__PURE__ */ (0, import_react76.createElement)(DeleteButton, null))), isDebugMode && /* @__PURE__ */ (0, import_react76.createElement)(StyledStatusWrap, null, /* @__PURE__ */ (0, import_react76.createElement)(StatusBar, null)));
});
var StyledToolsPanelContainer = styled("div", {
  position: "absolute",
  bottom: 0,
  left: 0,
  right: 0,
  width: "100%",
  minWidth: 0,
  maxWidth: "100%",
  display: "grid",
  gridTemplateColumns: "auto auto auto",
  gridTemplateRows: "auto auto",
  justifyContent: "space-between",
  padding: "0",
  gap: "$4",
  zIndex: 200,
  pointerEvents: "none",
  "& > div > *": {
    pointerEvents: "all"
  }
});
var StyledCenterWrap = styled("div", {
  gridRow: 1,
  gridColumn: 2,
  display: "flex",
  width: "fit-content",
  alignItems: "center",
  justifyContent: "center",
  flexDirection: "column",
  gap: "$4"
});
var StyledStatusWrap = styled("div", {
  gridRow: 2,
  gridColumn: "1 / span 3"
});
var StyledPrimaryTools = styled("div", {
  position: "relative",
  display: "flex",
  alignItems: "center",
  gap: "$2"
});
var settingsSelector = (s8) => s8.settings;
function PreferencesMenu() {
  const app = useTldrawApp();
  const settings = app.useStore(settingsSelector);
  const toggleDebugMode = (0, import_react112.useCallback)(() => {
    app.setSetting("isDebugMode", (v6) => !v6);
  }, [app]);
  const toggleDarkMode = (0, import_react112.useCallback)(() => {
    app.setSetting("isDarkMode", (v6) => !v6);
  }, [app]);
  const toggleFocusMode = (0, import_react112.useCallback)(() => {
    app.setSetting("isFocusMode", (v6) => !v6);
  }, [app]);
  const toggleRotateHandle = (0, import_react112.useCallback)(() => {
    app.setSetting("showRotateHandles", (v6) => !v6);
  }, [app]);
  const toggleGrid = (0, import_react112.useCallback)(() => {
    app.setSetting("showGrid", (v6) => !v6);
  }, [app]);
  const toggleBoundShapesHandle = (0, import_react112.useCallback)(() => {
    app.setSetting("showBindingHandles", (v6) => !v6);
  }, [app]);
  const toggleisSnapping = (0, import_react112.useCallback)(() => {
    app.setSetting("isSnapping", (v6) => !v6);
  }, [app]);
  const toggleCloneControls = (0, import_react112.useCallback)(() => {
    app.setSetting("showCloneHandles", (v6) => !v6);
  }, [app]);
  return /* @__PURE__ */ (0, import_react112.createElement)(DMSubMenu, {
    label: "\u7CFB\u7EDF\u8BBE\u7F6E"
  }, /* @__PURE__ */ (0, import_react112.createElement)(DMCheckboxItem, {
    checked: settings.isDarkMode,
    onCheckedChange: toggleDarkMode,
    kbd: "#\u21E7D"
  }, "\u6697\u9ED1\u98CE\u683C"), /* @__PURE__ */ (0, import_react112.createElement)(DMCheckboxItem, {
    checked: settings.isFocusMode,
    onCheckedChange: toggleFocusMode,
    kbd: "#."
  }, "\u4E13\u6CE8\u6A21\u5F0F"), /* @__PURE__ */ (0, import_react112.createElement)(DMCheckboxItem, {
    checked: settings.isDebugMode,
    onCheckedChange: toggleDebugMode
  }, "\u8C03\u8BD5\u6A21\u5F0F"), /* @__PURE__ */ (0, import_react112.createElement)(DMDivider, null), /* @__PURE__ */ (0, import_react112.createElement)(DMCheckboxItem, {
    checked: settings.showRotateHandles,
    onCheckedChange: toggleRotateHandle
  }, "\u663E\u793A\u65CB\u8F6C"), /* @__PURE__ */ (0, import_react112.createElement)(DMCheckboxItem, {
    checked: settings.showBindingHandles,
    onCheckedChange: toggleBoundShapesHandle
  }, "\u663E\u793A\u7ED1\u5B9A"), /* @__PURE__ */ (0, import_react112.createElement)(DMCheckboxItem, {
    checked: settings.showCloneHandles,
    onCheckedChange: toggleCloneControls
  }, "\u663E\u793A\u514B\u9686"), /* @__PURE__ */ (0, import_react112.createElement)(DMCheckboxItem, {
    checked: settings.showGrid,
    onCheckedChange: toggleGrid,
    kbd: "#\u21E7G"
  }, "\u663E\u793A\u7F51\u683C"), /* @__PURE__ */ (0, import_react112.createElement)(DMCheckboxItem, {
    checked: settings.isSnapping,
    onCheckedChange: toggleisSnapping
  }, "\u663E\u793A\u5FEB\u7167"));
}
var numberOfSelectedIdsSelector = (s8) => {
  return s8.document.pageStates[s8.appState.currentPageId].selectedIds.length;
};
var Menu2 = (0, import_react111.memo)(function Menu22({ showSponsorLink, readOnly }) {
  const app = useTldrawApp();
  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector);
  const { onNewProject, onOpenProject, onSaveProject, onSaveProjectAs } = useFileSystemHandlers();
  const handleSignIn = (0, import_react111.useCallback)(() => {
    var _a2, _b;
    (_b = (_a2 = app.callbacks).onSignIn) == null ? void 0 : _b.call(_a2, app);
  }, [app]);
  const handleSignOut = (0, import_react111.useCallback)(() => {
    var _a2, _b;
    (_b = (_a2 = app.callbacks).onSignOut) == null ? void 0 : _b.call(_a2, app);
  }, [app]);
  const handleCut = (0, import_react111.useCallback)(() => {
    app.cut();
  }, [app]);
  const handleCopy = (0, import_react111.useCallback)(() => {
    app.copy();
  }, [app]);
  const handlePaste = (0, import_react111.useCallback)(() => {
    app.paste();
  }, [app]);
  const handleCopySvg = (0, import_react111.useCallback)(() => {
    app.copySvg();
  }, [app]);
  const handleCopyJson = (0, import_react111.useCallback)(() => {
    app.copyJson();
  }, [app]);
  const handleSelectAll = (0, import_react111.useCallback)(() => {
    app.selectAll();
  }, [app]);
  const handleselectNone = (0, import_react111.useCallback)(() => {
    app.selectNone();
  }, [app]);
  const showFileMenu = true;
  const showSignInOutMenu = app.callbacks.onSignIn || app.callbacks.onSignOut || showSponsorLink;
  const hasSelection = numberOfSelectedIds > 0;
  return /* @__PURE__ */ (0, import_react111.createElement)(Root5, {
    dir: "ltr"
  }, /* @__PURE__ */ (0, import_react111.createElement)(DMTriggerIcon, {
    isSponsor: showSponsorLink
  }, /* @__PURE__ */ (0, import_react111.createElement)(HamburgerMenuIcon, null)), /* @__PURE__ */ (0, import_react111.createElement)(DMContent, {
    variant: "menu"
  }, showFileMenu && /* @__PURE__ */ (0, import_react111.createElement)(DMSubMenu, {
    label: "\u6587\u4EF6"
  }, app.callbacks.onNewProject && /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onClick: onNewProject,
    kbd: "#N"
  }, "\u65B0\u5EFA"), app.callbacks.onOpenProject && /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onClick: onOpenProject,
    kbd: "#O"
  }, "\u6253\u5F00"), app.callbacks.onSaveProject && /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onClick: onSaveProject,
    kbd: "#S"
  }, "\u4FDD\u5B58")), !readOnly && /* @__PURE__ */ (0, import_react111.createElement)(import_react111.Fragment, null, /* @__PURE__ */ (0, import_react111.createElement)(DMSubMenu, {
    label: "\u7F16\u8F91"
  }, /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: app.undo,
    kbd: "#Z"
  }, "\u53D6\u6D88"), /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: app.redo,
    kbd: "#\u21E7Z"
  }, "\u91CD\u505A"), /* @__PURE__ */ (0, import_react111.createElement)(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    disabled: !hasSelection,
    onClick: handleCut,
    kbd: "#X"
  }, "\u526A\u5207"), /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    disabled: !hasSelection,
    onClick: handleCopy,
    kbd: "#C"
  }, "\u590D\u5236"), /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: handlePaste,
    kbd: "#V"
  }, "\u9ECF\u8D34"), /* @__PURE__ */ (0, import_react111.createElement)(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    disabled: !hasSelection,
    onClick: handleCopySvg,
    kbd: "#\u21E7C"
  }, "\u590D\u5236\u4E3ASVG"), /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    disabled: !hasSelection,
    onClick: handleCopyJson
  }, "\u590D\u5236\u4E3AJSON"), /* @__PURE__ */ (0, import_react111.createElement)(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: handleSelectAll,
    kbd: "#A"
  }, "\u5168\u9009"), /* @__PURE__ */ (0, import_react111.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: handleselectNone
  }, "\u5168\u4E0D\u9009"))), /* @__PURE__ */ (0, import_react111.createElement)(DMDivider, {
    dir: "ltr"
  }), /* @__PURE__ */ (0, import_react111.createElement)(PreferencesMenu, null), /* @__PURE__ */ (0, import_react111.createElement)(DMDivider, {
    dir: "ltr"
  })));
});
var IconButton = styled("button", {
  position: "relative",
  height: "32px",
  width: "32px",
  backgroundColor: "$panel",
  borderRadius: "4px",
  padding: "0",
  margin: "0",
  outline: "none",
  border: "none",
  pointerEvents: "all",
  fontSize: "$0",
  color: "$text",
  cursor: "pointer",
  display: "grid",
  alignItems: "center",
  justifyContent: "center",
  "& > *": {
    gridRow: 1,
    gridColumn: 1
  },
  "&:disabled": {
    opacity: "0.5"
  },
  "& > span": {
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center"
  },
  variants: {
    bp: {
      mobile: {
        backgroundColor: "transparent"
      },
      small: {
        "&:hover:not(:disabled)": {
          backgroundColor: "$hover"
        }
      }
    },
    size: {
      small: {
        height: 32,
        width: 32,
        "& svg:nth-of-type(1)": {
          height: "16px",
          width: "16px"
        }
      },
      medium: {
        height: 44,
        width: 44,
        "& svg:nth-of-type(1)": {
          height: "18px",
          width: "18px"
        }
      },
      large: {
        height: 44,
        width: 44,
        "& svg:nth-of-type(1)": {
          height: "20px",
          width: "20px"
        }
      }
    },
    isActive: {
      true: {
        color: "$selected"
      }
    }
  }
});
var canDeleteSelector = (s8) => {
  return Object.keys(s8.document.pages).length > 1;
};
function PageOptionsDialog({ page, onOpen, onClose }) {
  const app = useTldrawApp();
  const [isOpen, setIsOpen] = (0, import_react115.useState)(false);
  const canDelete = app.useStore(canDeleteSelector);
  const rInput = (0, import_react115.useRef)(null);
  const handleDuplicate = (0, import_react115.useCallback)(() => {
    app.duplicatePage(page.id);
    onClose == null ? void 0 : onClose();
  }, [app]);
  const handleDelete = (0, import_react115.useCallback)(() => {
    if (window.confirm(`\u786E\u5B9A\u5220\u9664\u8BE5\u9875?`)) {
      app.deletePage(page.id);
      onClose == null ? void 0 : onClose();
    }
  }, [app]);
  const handleOpenChange = (0, import_react115.useCallback)((isOpen2) => {
    setIsOpen(isOpen2);
    if (isOpen2) {
      onOpen == null ? void 0 : onOpen();
      return;
    }
  }, [app]);
  function stopPropagation2(e12) {
    e12.stopPropagation();
  }
  function handleRename() {
    const nextName = window.prompt("\u9875\u9762\u540D\u79F0:", page.name);
    app.renamePage(page.id, nextName || page.name || "Page");
  }
  (0, import_react115.useEffect)(() => {
    if (isOpen) {
      requestAnimationFrame(() => {
        const elm = rInput.current;
        if (elm) {
          elm.focus();
          elm.select();
        }
      });
    }
  }, [isOpen]);
  return /* @__PURE__ */ (0, import_react115.createElement)(Root9, {
    open: isOpen,
    onOpenChange: handleOpenChange
  }, /* @__PURE__ */ (0, import_react115.createElement)(Trigger4, {
    asChild: true,
    "data-shy": "true"
  }, /* @__PURE__ */ (0, import_react115.createElement)(IconButton, {
    bp: breakpoints
  }, /* @__PURE__ */ (0, import_react115.createElement)(SmallIcon, null, /* @__PURE__ */ (0, import_react115.createElement)(MixerVerticalIcon, null)))), /* @__PURE__ */ (0, import_react115.createElement)(StyledDialogOverlay, null), /* @__PURE__ */ (0, import_react115.createElement)(StyledDialogContent, {
    dir: "ltr",
    onKeyDown: stopPropagation2,
    onKeyUp: stopPropagation2
  }, /* @__PURE__ */ (0, import_react115.createElement)(DialogAction, {
    onSelect: handleRename
  }, "\u91CD\u547D\u540D"), /* @__PURE__ */ (0, import_react115.createElement)(DialogAction, {
    onSelect: handleDuplicate
  }, "\u590D\u5236"), /* @__PURE__ */ (0, import_react115.createElement)(DialogAction, {
    disabled: !canDelete,
    onSelect: handleDelete
  }, "\u5220\u9664"), /* @__PURE__ */ (0, import_react115.createElement)(Divider, null), /* @__PURE__ */ (0, import_react115.createElement)(Cancel, {
    asChild: true
  }, /* @__PURE__ */ (0, import_react115.createElement)(RowButton, null, "\u53D6\u6D88"))));
}
var StyledDialogContent = styled(Content6, {
  position: "fixed",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  minWidth: 240,
  maxWidth: "fit-content",
  maxHeight: "85vh",
  marginTop: "-5vh",
  pointerEvents: "all",
  backgroundColor: "$panel",
  padding: "$0",
  borderRadius: "$2",
  font: "$ui",
  "&:focus": {
    outline: "none"
  }
});
var StyledDialogOverlay = styled(Overlay4, {
  backgroundColor: "rgba(0, 0, 0, .15)",
  position: "fixed",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: "100%",
  height: "100%"
});
function DialogAction(_a2) {
  var _b = _a2, {
    onSelect
  } = _b, rest = __objRest3(_b, [
    "onSelect"
  ]);
  return /* @__PURE__ */ (0, import_react115.createElement)(Action, {
    asChild: true,
    onClick: onSelect,
    onSelect
  }, /* @__PURE__ */ (0, import_react115.createElement)(RowButton, __spreadValues4({}, rest)));
}
var sortedSelector = (s8) => Object.values(s8.document.pages).sort((a9, b7) => (a9.childIndex || 0) - (b7.childIndex || 0));
var currentPageNameSelector = (s8) => s8.document.pages[s8.appState.currentPageId].name;
var currentPageIdSelector = (s8) => s8.document.pages[s8.appState.currentPageId].id;
function PageMenu() {
  const app = useTldrawApp();
  const rIsOpen = (0, import_react114.useRef)(false);
  const [isOpen, setIsOpen] = (0, import_react114.useState)(false);
  (0, import_react114.useEffect)(() => {
    if (rIsOpen.current !== isOpen) {
      rIsOpen.current = isOpen;
    }
  }, [isOpen]);
  const handleClose = (0, import_react114.useCallback)(() => {
    setIsOpen(false);
  }, [setIsOpen]);
  const handleOpenChange = (0, import_react114.useCallback)((isOpen2) => {
    if (rIsOpen.current !== isOpen2) {
      setIsOpen(isOpen2);
    }
  }, [setIsOpen]);
  const currentPageName = app.useStore(currentPageNameSelector);
  return /* @__PURE__ */ (0, import_react114.createElement)(Root5, {
    dir: "ltr",
    open: isOpen,
    onOpenChange: handleOpenChange
  }, /* @__PURE__ */ (0, import_react114.createElement)(Trigger, {
    dir: "ltr",
    asChild: true
  }, /* @__PURE__ */ (0, import_react114.createElement)(ToolButton, {
    variant: "text"
  }, currentPageName || "Page")), /* @__PURE__ */ (0, import_react114.createElement)(DMContent, {
    variant: "menu",
    align: "start"
  }, isOpen && /* @__PURE__ */ (0, import_react114.createElement)(PageMenuContent, {
    onClose: handleClose
  })));
}
function PageMenuContent({ onClose }) {
  const app = useTldrawApp();
  const sortedPages = app.useStore(sortedSelector);
  const currentPageId = app.useStore(currentPageIdSelector);
  const handleCreatePage = (0, import_react114.useCallback)(() => {
    app.createPage();
  }, [app]);
  const handleChangePage = (0, import_react114.useCallback)((id) => {
    onClose();
    app.changePage(id);
  }, [app]);
  return /* @__PURE__ */ (0, import_react114.createElement)(import_react114.Fragment, null, /* @__PURE__ */ (0, import_react114.createElement)(RadioGroup2, {
    dir: "ltr",
    value: currentPageId,
    onValueChange: handleChangePage
  }, sortedPages.map((page) => /* @__PURE__ */ (0, import_react114.createElement)(ButtonWithOptions, {
    key: page.id
  }, /* @__PURE__ */ (0, import_react114.createElement)(RadioItem2, {
    title: page.name || "\u9875",
    value: page.id,
    key: page.id,
    asChild: true
  }, /* @__PURE__ */ (0, import_react114.createElement)(PageButton, null, /* @__PURE__ */ (0, import_react114.createElement)("span", null, page.name || "\u9875"), /* @__PURE__ */ (0, import_react114.createElement)(ItemIndicator2, null, /* @__PURE__ */ (0, import_react114.createElement)(SmallIcon, null, /* @__PURE__ */ (0, import_react114.createElement)(CheckIcon, null))))), /* @__PURE__ */ (0, import_react114.createElement)(PageOptionsDialog, {
    page,
    onClose
  })))), /* @__PURE__ */ (0, import_react114.createElement)(DMDivider, null), /* @__PURE__ */ (0, import_react114.createElement)(Item3, {
    onSelect: handleCreatePage,
    asChild: true
  }, /* @__PURE__ */ (0, import_react114.createElement)(RowButton, null, /* @__PURE__ */ (0, import_react114.createElement)("span", null, "\u65B0\u5EFA\u9875\u9762"), /* @__PURE__ */ (0, import_react114.createElement)(SmallIcon, null, /* @__PURE__ */ (0, import_react114.createElement)(PlusIcon, null)))));
}
var ButtonWithOptions = styled("div", {
  display: "grid",
  gridTemplateColumns: "1fr auto",
  gridAutoFlow: "column",
  '& > *[data-shy="true"]': {
    opacity: 0
  },
  '&:hover > *[data-shy="true"]': {
    opacity: 1
  }
});
var PageButton = styled(RowButton, {
  minWidth: 128
});
var zoomSelector = (s8) => s8.document.pageStates[s8.appState.currentPageId].camera.zoom;
var ZoomMenu = (0, import_react116.memo)(function ZoomMenu2() {
  const app = useTldrawApp();
  const zoom = app.useStore(zoomSelector);
  return /* @__PURE__ */ (0, import_react116.createElement)(Root5, {
    dir: "ltr"
  }, /* @__PURE__ */ (0, import_react116.createElement)(Trigger, {
    dir: "ltr",
    asChild: true
  }, /* @__PURE__ */ (0, import_react116.createElement)(FixedWidthToolButton, {
    onDoubleClick: app.resetZoom,
    variant: "text"
  }, Math.round(zoom * 100), "%")), /* @__PURE__ */ (0, import_react116.createElement)(DMContent, {
    align: "end"
  }, /* @__PURE__ */ (0, import_react116.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomIn,
    kbd: "#+"
  }, "\u7F29\u5C0F"), /* @__PURE__ */ (0, import_react116.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomOut,
    kbd: "#\u2212"
  }, "\u653E\u5927"), /* @__PURE__ */ (0, import_react116.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: app.resetZoom,
    kbd: "\u21E70"
  }, "To 100%"), /* @__PURE__ */ (0, import_react116.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomToFit,
    kbd: "\u21E71"
  }, "\u9002\u5408"), /* @__PURE__ */ (0, import_react116.createElement)(DMItem, {
    onSelect: preventEvent,
    onClick: app.zoomToSelection,
    kbd: "\u21E72"
  }, "\u5230\u9009\u62E9")));
});
var FixedWidthToolButton = styled(ToolButton, {
  minWidth: 56
});
var currentStyleSelector = (s8) => s8.appState.currentStyle;
var selectedIdsSelector = (s8) => s8.document.pageStates[s8.appState.currentPageId].selectedIds;
var STYLE_KEYS = Object.keys(defaultTextStyle);
var DASH_ICONS = {
  [DashStyle.Draw]: /* @__PURE__ */ (0, import_react117.createElement)(DashDrawIcon, null),
  [DashStyle.Solid]: /* @__PURE__ */ (0, import_react117.createElement)(DashSolidIcon, null),
  [DashStyle.Dashed]: /* @__PURE__ */ (0, import_react117.createElement)(DashDashedIcon, null),
  [DashStyle.Dotted]: /* @__PURE__ */ (0, import_react117.createElement)(DashDottedIcon, null)
};
var SIZE_ICONS = {
  [SizeStyle.Small]: /* @__PURE__ */ (0, import_react117.createElement)(SizeSmallIcon, null),
  [SizeStyle.Medium]: /* @__PURE__ */ (0, import_react117.createElement)(SizeMediumIcon, null),
  [SizeStyle.Large]: /* @__PURE__ */ (0, import_react117.createElement)(SizeLargeIcon, null)
};
var ALIGN_ICONS = {
  [AlignStyle.Start]: /* @__PURE__ */ (0, import_react117.createElement)(TextAlignLeftIcon, null),
  [AlignStyle.Middle]: /* @__PURE__ */ (0, import_react117.createElement)(TextAlignCenterIcon, null),
  [AlignStyle.End]: /* @__PURE__ */ (0, import_react117.createElement)(TextAlignRightIcon, null),
  [AlignStyle.Justify]: /* @__PURE__ */ (0, import_react117.createElement)(TextAlignJustifyIcon, null)
};
var themeSelector = (s8) => s8.settings.isDarkMode ? "dark" : "light";
var showTextStylesSelector = (s8) => {
  const { activeTool, currentPageId: pageId } = s8.appState;
  const page = s8.document.pages[pageId];
  return activeTool === "text" || s8.document.pageStates[pageId].selectedIds.some((id) => "text" in page.shapes[id]);
};
var StyleMenu = (0, import_react117.memo)(function ColorMenu() {
  const app = useTldrawApp();
  const theme = app.useStore(themeSelector);
  const showTextStyles = app.useStore(showTextStylesSelector);
  const currentStyle = app.useStore(currentStyleSelector);
  const selectedIds = app.useStore(selectedIdsSelector);
  const [displayedStyle, setDisplayedStyle] = (0, import_react117.useState)(currentStyle);
  const rDisplayedStyle = (0, import_react117.useRef)(currentStyle);
  (0, import_react117.useEffect)(() => {
    const {
      appState: { currentStyle: currentStyle2 },
      page,
      selectedIds: selectedIds2
    } = app;
    let commonStyle = {};
    if (selectedIds2.length <= 0) {
      commonStyle = currentStyle2;
    } else {
      const overrides = new Set([]);
      app.selectedIds.map((id) => page.shapes[id]).forEach((shape) => {
        STYLE_KEYS.forEach((key) => {
          if (overrides.has(key))
            return;
          if (commonStyle[key] === void 0) {
            commonStyle[key] = shape.style[key];
          } else {
            if (commonStyle[key] === shape.style[key])
              return;
            commonStyle[key] = shape.style[key];
            overrides.add(key);
          }
        });
      });
    }
    if (JSON.stringify(commonStyle) !== JSON.stringify(rDisplayedStyle.current)) {
      rDisplayedStyle.current = commonStyle;
      setDisplayedStyle(commonStyle);
    }
  }, [currentStyle, selectedIds]);
  const handleToggleFilled = (0, import_react117.useCallback)((checked) => {
    app.style({ isFilled: checked });
  }, []);
  const handleDashChange = (0, import_react117.useCallback)((value) => {
    app.style({ dash: value });
  }, []);
  const handleSizeChange = (0, import_react117.useCallback)((value) => {
    app.style({ size: value });
  }, []);
  const handleFontChange = (0, import_react117.useCallback)((value) => {
    app.style({ font: value });
  }, []);
  const handleTextAlignChange = (0, import_react117.useCallback)((value) => {
    app.style({ textAlign: value });
  }, []);
  const handleMenuOpenChange = (0, import_react117.useCallback)((open) => {
    app.setMenuOpen(open);
  }, [app]);
  return /* @__PURE__ */ (0, import_react117.createElement)(Root5, {
    dir: "ltr",
    onOpenChange: handleMenuOpenChange
  }, /* @__PURE__ */ (0, import_react117.createElement)(Trigger, {
    asChild: true
  }, /* @__PURE__ */ (0, import_react117.createElement)(ToolButton, {
    variant: "text"
  }, "\u6837\u5F0F", /* @__PURE__ */ (0, import_react117.createElement)(OverlapIcons, {
    style: {
      color: strokes[theme][displayedStyle.color]
    }
  }, displayedStyle.isFilled && /* @__PURE__ */ (0, import_react117.createElement)(CircleIcon2, {
    size: 16,
    stroke: "none",
    fill: fills[theme][displayedStyle.color]
  }), DASH_ICONS[displayedStyle.dash]))), /* @__PURE__ */ (0, import_react117.createElement)(DMContent, null, /* @__PURE__ */ (0, import_react117.createElement)(StyledRow, {
    variant: "tall"
  }, /* @__PURE__ */ (0, import_react117.createElement)("span", null, "\u989C\u8272"), /* @__PURE__ */ (0, import_react117.createElement)(ColorGrid, null, Object.keys(strokes.light).map((style) => /* @__PURE__ */ (0, import_react117.createElement)(Item3, {
    key: style,
    onSelect: preventEvent,
    asChild: true
  }, /* @__PURE__ */ (0, import_react117.createElement)(ToolButton, {
    variant: "icon",
    isActive: displayedStyle.color === style,
    onClick: () => app.style({ color: style })
  }, /* @__PURE__ */ (0, import_react117.createElement)(CircleIcon2, {
    size: 18,
    strokeWidth: 2.5,
    fill: displayedStyle.isFilled ? fills.light[style] : "transparent",
    stroke: strokes.light[style]
  })))))), /* @__PURE__ */ (0, import_react117.createElement)(DMCheckboxItem, {
    variant: "styleMenu",
    checked: !!displayedStyle.isFilled,
    onCheckedChange: handleToggleFilled
  }, "\u586B\u5145"), /* @__PURE__ */ (0, import_react117.createElement)(StyledRow, null, "\u8FB9\u6846", /* @__PURE__ */ (0, import_react117.createElement)(StyledGroup, {
    dir: "ltr",
    value: displayedStyle.dash,
    onValueChange: handleDashChange
  }, Object.values(DashStyle).map((style) => /* @__PURE__ */ (0, import_react117.createElement)(DMRadioItem, {
    key: style,
    isActive: style === displayedStyle.dash,
    value: style,
    onSelect: preventEvent,
    bp: breakpoints
  }, DASH_ICONS[style])))), /* @__PURE__ */ (0, import_react117.createElement)(StyledRow, null, "\u5927\u5C0F", /* @__PURE__ */ (0, import_react117.createElement)(StyledGroup, {
    dir: "ltr",
    value: displayedStyle.size,
    onValueChange: handleSizeChange
  }, Object.values(SizeStyle).map((sizeStyle) => /* @__PURE__ */ (0, import_react117.createElement)(DMRadioItem, {
    key: sizeStyle,
    isActive: sizeStyle === displayedStyle.size,
    value: sizeStyle,
    onSelect: preventEvent,
    bp: breakpoints
  }, SIZE_ICONS[sizeStyle])))), showTextStyles && /* @__PURE__ */ (0, import_react117.createElement)(import_react117.Fragment, null, /* @__PURE__ */ (0, import_react117.createElement)(Divider, null), /* @__PURE__ */ (0, import_react117.createElement)(StyledRow, null, "\u5B57\u4F53", /* @__PURE__ */ (0, import_react117.createElement)(StyledGroup, {
    dir: "ltr",
    value: displayedStyle.font,
    onValueChange: handleFontChange
  }, Object.values(FontStyle).map((fontStyle) => /* @__PURE__ */ (0, import_react117.createElement)(DMRadioItem, {
    key: fontStyle,
    isActive: fontStyle === displayedStyle.font,
    value: fontStyle,
    onSelect: preventEvent,
    bp: breakpoints
  }, /* @__PURE__ */ (0, import_react117.createElement)(FontIcon, {
    fontStyle
  }, "Aa"))))), /* @__PURE__ */ (0, import_react117.createElement)(StyledRow, null, "\u4F4D\u7F6E", /* @__PURE__ */ (0, import_react117.createElement)(StyledGroup, {
    dir: "ltr",
    value: displayedStyle.textAlign,
    onValueChange: handleTextAlignChange
  }, Object.values(AlignStyle).map((style) => /* @__PURE__ */ (0, import_react117.createElement)(DMRadioItem, {
    key: style,
    isActive: style === displayedStyle.textAlign,
    value: style,
    onSelect: preventEvent,
    bp: breakpoints
  }, ALIGN_ICONS[style])))))));
});
var ColorGrid = styled("div", {
  display: "grid",
  gridTemplateColumns: "repeat(4, auto)",
  gap: 0
});
var StyledRow = styled("div", {
  position: "relative",
  width: "100%",
  background: "none",
  border: "none",
  cursor: "pointer",
  minHeight: "32px",
  outline: "none",
  color: "$text",
  fontFamily: "$ui",
  fontWeight: 400,
  fontSize: "$1",
  padding: "$2 0 $2 $3",
  borderRadius: 4,
  userSelect: "none",
  margin: 0,
  display: "flex",
  gap: "$3",
  flexDirection: "row",
  alignItems: "center",
  justifyContent: "space-between",
  variants: {
    variant: {
      tall: {
        alignItems: "flex-start",
        padding: "0 0 0 $3",
        "& > span": {
          paddingTop: "$4"
        }
      }
    }
  }
});
var StyledGroup = styled(DropdownMenuRadioGroup, {
  display: "flex",
  flexDirection: "row",
  gap: "$1"
});
var OverlapIcons = styled("div", {
  display: "grid",
  "& > *": {
    gridColumn: 1,
    gridRow: 1
  }
});
var FontIcon = styled("div", {
  width: 32,
  height: 32,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  fontSize: "$3",
  variants: {
    fontStyle: {
      [FontStyle.Script]: {
        fontFamily: "Caveat Brush"
      },
      [FontStyle.Sans]: {
        fontFamily: "Recursive"
      },
      [FontStyle.Serif]: {
        fontFamily: "Georgia"
      },
      [FontStyle.Mono]: {
        fontFamily: "Recursive Mono"
      }
    }
  }
});
function TopPanel({
  readOnly,
  showPages,
  showMenu,
  showStyles,
  showZoom,
  showSponsorLink
}) {
  const app = useTldrawApp();
  return /* @__PURE__ */ (0, import_react110.createElement)(StyledTopPanel, null, (showMenu || showPages) && /* @__PURE__ */ (0, import_react110.createElement)(Panel, {
    side: "left"
  }, showMenu && /* @__PURE__ */ (0, import_react110.createElement)(Menu2, {
    showSponsorLink,
    readOnly
  }), showPages && /* @__PURE__ */ (0, import_react110.createElement)(PageMenu, null)), /* @__PURE__ */ (0, import_react110.createElement)(StyledSpacer, null), (showStyles || showZoom) && /* @__PURE__ */ (0, import_react110.createElement)(Panel, {
    side: "right"
  }, showStyles && !readOnly && /* @__PURE__ */ (0, import_react110.createElement)(StyleMenu, null), /* @__PURE__ */ (0, import_react110.createElement)(MobileOnly, {
    bp: breakpoints
  }, /* @__PURE__ */ (0, import_react110.createElement)(ToolButton, null, /* @__PURE__ */ (0, import_react110.createElement)(UndoIcon, {
    onClick: app.undo
  })), /* @__PURE__ */ (0, import_react110.createElement)(ToolButton, null, /* @__PURE__ */ (0, import_react110.createElement)(RedoIcon, {
    onClick: app.redo
  }))), showZoom && /* @__PURE__ */ (0, import_react110.createElement)(ZoomMenu, null)));
}
var StyledTopPanel = styled("div", {
  width: "100%",
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  display: "flex",
  flexDirection: "row",
  pointerEvents: "none",
  "& > *": {
    pointerEvents: "all"
  }
});
var StyledSpacer = styled("div", {
  flexGrow: 2,
  pointerEvents: "none"
});
var MobileOnly = styled("div", {
  display: "flex",
  flexDirection: "row",
  variants: {
    bp: {
      small: {
        display: "inherit"
      },
      large: {
        display: "none"
      }
    }
  }
});
var numberOfSelectedIdsSelector2 = (s8) => {
  return s8.document.pageStates[s8.appState.currentPageId].selectedIds.length;
};
var isDebugModeSelector2 = (s8) => {
  return s8.settings.isDebugMode;
};
var hasGroupSelectedSelector = (s8) => {
  return s8.document.pageStates[s8.appState.currentPageId].selectedIds.some((id) => s8.document.pages[s8.appState.currentPageId].shapes[id].children !== void 0);
};
var preventDefault = (e12) => e12.stopPropagation();
var ContextMenu2 = ({ onBlur, children }) => {
  const app = useTldrawApp();
  const numberOfSelectedIds = app.useStore(numberOfSelectedIdsSelector2);
  const isDebugMode = app.useStore(isDebugModeSelector2);
  const hasGroupSelected = app.useStore(hasGroupSelectedSelector);
  const rContent = (0, import_react118.useRef)(null);
  const handleFlipHorizontal = (0, import_react118.useCallback)(() => {
    app.flipHorizontal();
  }, [app]);
  const handleFlipVertical = (0, import_react118.useCallback)(() => {
    app.flipVertical();
  }, [app]);
  const handleDuplicate = (0, import_react118.useCallback)(() => {
    app.duplicate();
  }, [app]);
  const handleLock = (0, import_react118.useCallback)(() => {
    app.toggleLocked();
  }, [app]);
  const handleGroup = (0, import_react118.useCallback)(() => {
    app.group();
  }, [app]);
  const handleMoveToBack = (0, import_react118.useCallback)(() => {
    app.moveToBack();
  }, [app]);
  const handleMoveBackward = (0, import_react118.useCallback)(() => {
    app.moveBackward();
  }, [app]);
  const handleMoveForward = (0, import_react118.useCallback)(() => {
    app.moveForward();
  }, [app]);
  const handleMoveToFront = (0, import_react118.useCallback)(() => {
    app.moveToFront();
  }, [app]);
  const handleDelete = (0, import_react118.useCallback)(() => {
    app.delete();
  }, [app]);
  const handleCopyJson = (0, import_react118.useCallback)(() => {
    app.copyJson();
  }, [app]);
  const handleCut = (0, import_react118.useCallback)(() => {
    app.cut();
  }, [app]);
  const handleCopy = (0, import_react118.useCallback)(() => {
    app.copy();
  }, [app]);
  const handlePaste = (0, import_react118.useCallback)(() => {
    app.paste();
  }, [app]);
  const handleCopySvg = (0, import_react118.useCallback)(() => {
    app.copySvg();
  }, [app]);
  const handleUndo = (0, import_react118.useCallback)(() => {
    app.undo();
  }, [app]);
  const handleRedo = (0, import_react118.useCallback)(() => {
    app.redo();
  }, [app]);
  const hasSelection = numberOfSelectedIds > 0;
  const hasTwoOrMore = numberOfSelectedIds > 1;
  const hasThreeOrMore = numberOfSelectedIds > 2;
  return /* @__PURE__ */ (0, import_react118.createElement)(Root10, {
    dir: "ltr"
  }, /* @__PURE__ */ (0, import_react118.createElement)(Trigger5, {
    dir: "ltr"
  }, children), /* @__PURE__ */ (0, import_react118.createElement)(Content7, {
    dir: "ltr",
    ref: rContent,
    onEscapeKeyDown: preventDefault,
    asChild: true,
    tabIndex: -1,
    onBlur
  }, /* @__PURE__ */ (0, import_react118.createElement)(MenuContent2, null, hasSelection ? /* @__PURE__ */ (0, import_react118.createElement)(import_react118.Fragment, null, /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleDuplicate,
    kbd: "#D"
  }, "\u590D\u5236"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleFlipHorizontal,
    kbd: "\u21E7H"
  }, "\u6C34\u5E73\u7FFB\u8F6C"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleFlipVertical,
    kbd: "\u21E7V"
  }, "\u5782\u76F4\u7FFB\u8F6C"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleLock,
    kbd: "#\u21E7L"
  }, "\u9501\u5B9A/\u89E3\u9501"), (hasTwoOrMore || hasGroupSelected) && /* @__PURE__ */ (0, import_react118.createElement)(Divider, null), hasTwoOrMore && /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleGroup,
    kbd: "#G"
  }, "\u5206\u7EC4"), hasGroupSelected && /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleGroup,
    kbd: "#G"
  }, "\u89E3\u9664\u5206\u7EC4"), /* @__PURE__ */ (0, import_react118.createElement)(Divider, null), /* @__PURE__ */ (0, import_react118.createElement)(ContextMenuSubMenu, {
    label: "\u79FB\u52A8"
  }, /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleMoveToFront,
    kbd: "\u21E7]"
  }, "\u6700\u524D"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleMoveForward,
    kbd: "]"
  }, "\u5411\u524D"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleMoveBackward,
    kbd: "["
  }, "\u5411\u540E"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleMoveToBack,
    kbd: "\u21E7["
  }, "\u6700\u540E")), /* @__PURE__ */ (0, import_react118.createElement)(MoveToPageMenu, null), hasTwoOrMore && /* @__PURE__ */ (0, import_react118.createElement)(AlignDistributeSubMenu, {
    hasTwoOrMore,
    hasThreeOrMore
  }), /* @__PURE__ */ (0, import_react118.createElement)(Divider, null), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleCut,
    kbd: "#X"
  }, "\u526A\u5207"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleCopy,
    kbd: "#C"
  }, "\u590D\u5236"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleCopySvg,
    kbd: "#\u21E7C"
  }, "\u590D\u5236\u4E3ASVG"), isDebugMode && /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleCopyJson
  }, "\u590D\u5236\u4E3AJSON"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handlePaste,
    kbd: "#V"
  }, "\u7C98\u8D34"), /* @__PURE__ */ (0, import_react118.createElement)(Divider, null), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleDelete,
    kbd: "\u232B"
  }, "\u5220\u9664")) : /* @__PURE__ */ (0, import_react118.createElement)(import_react118.Fragment, null, /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handlePaste,
    kbd: "#V"
  }, "\u7C98\u8D34"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleUndo,
    kbd: "#Z"
  }, "\u64A4\u9500"), /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    onClick: handleRedo,
    kbd: "#\u21E7Z"
  }, "\u91CD\u505A")))));
};
function AlignDistributeSubMenu({
  hasThreeOrMore
}) {
  const app = useTldrawApp();
  const alignTop = (0, import_react118.useCallback)(() => {
    app.align(AlignType.Top);
  }, [app]);
  const alignCenterVertical = (0, import_react118.useCallback)(() => {
    app.align(AlignType.CenterVertical);
  }, [app]);
  const alignBottom = (0, import_react118.useCallback)(() => {
    app.align(AlignType.Bottom);
  }, [app]);
  const stretchVertically = (0, import_react118.useCallback)(() => {
    app.stretch(StretchType.Vertical);
  }, [app]);
  const distributeVertically = (0, import_react118.useCallback)(() => {
    app.distribute(DistributeType.Vertical);
  }, [app]);
  const alignLeft = (0, import_react118.useCallback)(() => {
    app.align(AlignType.Left);
  }, [app]);
  const alignCenterHorizontal = (0, import_react118.useCallback)(() => {
    app.align(AlignType.CenterHorizontal);
  }, [app]);
  const alignRight = (0, import_react118.useCallback)(() => {
    app.align(AlignType.Right);
  }, [app]);
  const stretchHorizontally = (0, import_react118.useCallback)(() => {
    app.stretch(StretchType.Horizontal);
  }, [app]);
  const distributeHorizontally = (0, import_react118.useCallback)(() => {
    app.distribute(DistributeType.Horizontal);
  }, [app]);
  return /* @__PURE__ */ (0, import_react118.createElement)(Root10, {
    dir: "ltr"
  }, /* @__PURE__ */ (0, import_react118.createElement)(CMTriggerButton, {
    isSubmenu: true
  }, "Align / Distribute"), /* @__PURE__ */ (0, import_react118.createElement)(Content7, {
    asChild: true,
    sideOffset: 2,
    alignOffset: -2
  }, /* @__PURE__ */ (0, import_react118.createElement)(StyledGridContent, {
    numberOfSelected: hasThreeOrMore ? "threeOrMore" : "twoOrMore"
  }, /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: alignLeft
  }, /* @__PURE__ */ (0, import_react118.createElement)(AlignLeftIcon, null)), /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: alignCenterHorizontal
  }, /* @__PURE__ */ (0, import_react118.createElement)(AlignCenterHorizontallyIcon, null)), /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: alignRight
  }, /* @__PURE__ */ (0, import_react118.createElement)(AlignRightIcon, null)), /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: stretchHorizontally
  }, /* @__PURE__ */ (0, import_react118.createElement)(StretchHorizontallyIcon, null)), hasThreeOrMore && /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: distributeHorizontally
  }, /* @__PURE__ */ (0, import_react118.createElement)(SpaceEvenlyHorizontallyIcon, null)), /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: alignTop
  }, /* @__PURE__ */ (0, import_react118.createElement)(AlignTopIcon, null)), /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: alignCenterVertical
  }, /* @__PURE__ */ (0, import_react118.createElement)(AlignCenterVerticallyIcon, null)), /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: alignBottom
  }, /* @__PURE__ */ (0, import_react118.createElement)(AlignBottomIcon, null)), /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: stretchVertically
  }, /* @__PURE__ */ (0, import_react118.createElement)(StretchVerticallyIcon, null)), hasThreeOrMore && /* @__PURE__ */ (0, import_react118.createElement)(CMIconButton, {
    onClick: distributeVertically
  }, /* @__PURE__ */ (0, import_react118.createElement)(SpaceEvenlyVerticallyIcon, null)), /* @__PURE__ */ (0, import_react118.createElement)(CMArrow, {
    offset: 13
  }))));
}
var StyledGridContent = styled(MenuContent2, {
  display: "grid",
  variants: {
    numberOfSelected: {
      threeOrMore: {
        gridTemplateColumns: "repeat(5, auto)"
      },
      twoOrMore: {
        gridTemplateColumns: "repeat(4, auto)"
      }
    }
  }
});
var currentPageIdSelector2 = (s8) => s8.appState.currentPageId;
var documentPagesSelector = (s8) => s8.document.pages;
function MoveToPageMenu() {
  const app = useTldrawApp();
  const currentPageId = app.useStore(currentPageIdSelector2);
  const documentPages = app.useStore(documentPagesSelector);
  const sorted = Object.values(documentPages).sort((a9, b7) => (a9.childIndex || 0) - (b7.childIndex || 0)).filter((a9) => a9.id !== currentPageId);
  if (sorted.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_react118.createElement)(Root10, {
    dir: "ltr"
  }, /* @__PURE__ */ (0, import_react118.createElement)(CMTriggerButton, {
    isSubmenu: true
  }, "Move To Page"), /* @__PURE__ */ (0, import_react118.createElement)(Content7, {
    dir: "ltr",
    sideOffset: 2,
    alignOffset: -2,
    asChild: true
  }, /* @__PURE__ */ (0, import_react118.createElement)(MenuContent2, null, sorted.map(({ id, name }, i8) => /* @__PURE__ */ (0, import_react118.createElement)(CMRowButton, {
    key: id,
    disabled: id === currentPageId,
    onClick: () => app.moveToPage(id)
  }, name || `Page ${i8}`)), /* @__PURE__ */ (0, import_react118.createElement)(CMArrow, {
    offset: 13
  }))));
}
function ContextMenuSubMenu({ children, label }) {
  return /* @__PURE__ */ (0, import_react118.createElement)(Root10, {
    dir: "ltr"
  }, /* @__PURE__ */ (0, import_react118.createElement)(CMTriggerButton, {
    isSubmenu: true
  }, label), /* @__PURE__ */ (0, import_react118.createElement)(Content7, {
    dir: "ltr",
    sideOffset: 2,
    alignOffset: -2,
    asChild: true
  }, /* @__PURE__ */ (0, import_react118.createElement)(MenuContent2, null, children, /* @__PURE__ */ (0, import_react118.createElement)(CMArrow, {
    offset: 13
  }))));
}
var CMArrow = styled(ContextMenuArrow, {
  fill: "$panel"
});
function CMIconButton(_a2) {
  var _b = _a2, { onSelect } = _b, rest = __objRest3(_b, ["onSelect"]);
  return /* @__PURE__ */ (0, import_react118.createElement)(ContextMenuItem, {
    dir: "ltr",
    onSelect,
    asChild: true
  }, /* @__PURE__ */ (0, import_react118.createElement)(ToolButton, __spreadValues4({}, rest)));
}
var CMRowButton = (_a2) => {
  var rest = __objRest3(_a2, []);
  return /* @__PURE__ */ (0, import_react118.createElement)(ContextMenuItem, {
    asChild: true
  }, /* @__PURE__ */ (0, import_react118.createElement)(RowButton, __spreadValues4({}, rest)));
};
var CMTriggerButton = (_a2) => {
  var _b = _a2, { isSubmenu } = _b, rest = __objRest3(_b, ["isSubmenu"]);
  return /* @__PURE__ */ (0, import_react118.createElement)(ContextMenuTriggerItem, {
    asChild: true
  }, /* @__PURE__ */ (0, import_react118.createElement)(RowButton, __spreadValues4({
    hasArrow: isSubmenu
  }, rest)));
};
function FocusButton({ onSelect }) {
  return /* @__PURE__ */ (0, import_react119.createElement)(StyledButtonContainer, null, /* @__PURE__ */ (0, import_react119.createElement)(IconButton, {
    onClick: onSelect
  }, /* @__PURE__ */ (0, import_react119.createElement)(DotFilledIcon, null)));
}
var StyledButtonContainer = styled("div", {
  opacity: 1,
  zIndex: 100,
  backgroundColor: "transparent",
  "& svg": {
    color: "$text"
  },
  "&:hover svg": {
    color: "$text"
  }
});
function Tldraw({
  id,
  document: document2,
  currentPageId,
  darkMode = false,
  autofocus = true,
  showMenu = true,
  showPages = true,
  showTools = true,
  showZoom = true,
  showStyles = true,
  showUI = true,
  readOnly = false,
  showSponsorLink = false,
  onMount,
  onChange,
  onChangePresence,
  onNewProject,
  onSaveProject,
  onSaveProjectAs,
  onOpenProject,
  onSignOut,
  onSignIn,
  onUndo,
  onRedo,
  onPersist,
  onPatch,
  onCommand,
  onChangePage
}) {
  const [sId, setSId] = (0, import_react60.useState)(id);
  const [app, setApp] = (0, import_react60.useState)(() => new TldrawApp(id, {
    onMount,
    onChange,
    onChangePresence,
    onNewProject,
    onSaveProject,
    onSaveProjectAs,
    onOpenProject,
    onSignOut,
    onSignIn,
    onUndo,
    onRedo,
    onPersist,
    onPatch,
    onCommand,
    onChangePage
  }));
  (0, import_react60.useEffect)(() => {
    if (id === sId)
      return;
    const newApp = new TldrawApp(id, {
      onMount,
      onChange,
      onChangePresence,
      onNewProject,
      onSaveProject,
      onSaveProjectAs,
      onOpenProject,
      onSignOut,
      onSignIn,
      onUndo,
      onRedo,
      onPersist,
      onPatch,
      onCommand,
      onChangePage
    });
    setSId(id);
    setApp(newApp);
  }, [sId, id]);
  (0, import_react60.useEffect)(() => {
    if (!document2)
      return;
    if (document2.id === app.document.id) {
      app.updateDocument(document2);
    } else {
      app.loadDocument(document2);
    }
  }, [document2, app]);
  (0, import_react60.useEffect)(() => {
    if (!currentPageId)
      return;
    app.changePage(currentPageId);
  }, [currentPageId, app]);
  (0, import_react60.useEffect)(() => {
    app.readOnly = readOnly;
  }, [app, readOnly]);
  (0, import_react60.useEffect)(() => {
    if (darkMode && !app.settings.isDarkMode) {
    }
  }, [app, darkMode]);
  (0, import_react60.useEffect)(() => {
    app.callbacks = {
      onMount,
      onChange,
      onChangePresence,
      onNewProject,
      onSaveProject,
      onSaveProjectAs,
      onOpenProject,
      onSignOut,
      onSignIn,
      onUndo,
      onRedo,
      onPersist,
      onPatch,
      onCommand,
      onChangePage
    };
  }, [
    onMount,
    onChange,
    onChangePresence,
    onNewProject,
    onSaveProject,
    onSaveProjectAs,
    onOpenProject,
    onSignOut,
    onSignIn,
    onUndo,
    onRedo,
    onPersist,
    onPatch,
    onCommand,
    onChangePage
  ]);
  return /* @__PURE__ */ (0, import_react60.createElement)(TldrawContext.Provider, {
    value: app
  }, /* @__PURE__ */ (0, import_react60.createElement)(InnerTldraw, {
    key: sId || "Tldraw",
    id: sId,
    autofocus,
    showPages,
    showMenu,
    showStyles,
    showZoom,
    showTools,
    showUI,
    showSponsorLink,
    readOnly
  }));
}
var InnerTldraw = (0, import_react60.memo)(function InnerTldraw2({
  id,
  autofocus,
  showPages,
  showMenu,
  showZoom,
  showStyles,
  showTools,
  showSponsorLink,
  readOnly,
  showUI
}) {
  var _a2;
  const app = useTldrawApp();
  const rWrapper = (0, import_react60.useRef)(null);
  const state = app.useStore();
  const { document: document2, settings, appState, room } = state;
  const isSelecting = state.appState.activeTool === "select";
  const page = document2.pages[appState.currentPageId];
  const pageState = document2.pageStates[page.id];
  const { selectedIds } = pageState;
  const isHideBoundsShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideBounds;
  const isHideResizeHandlesShape = selectedIds.length === 1 && page.shapes[selectedIds[0]] && TLDR.getShapeUtil(page.shapes[selectedIds[0]].type).hideResizeHandles;
  const isInSession = app.session !== void 0;
  const hideBounds = isInSession && ((_a2 = app.session) == null ? void 0 : _a2.constructor.name) !== "BrushSession" || !isSelecting || isHideBoundsShape || !!pageState.editingId;
  const hideHandles = isInSession || !isSelecting;
  const hideIndicators = isInSession && state.appState.status !== TDStatus.Brushing || !isSelecting;
  const meta = (0, import_react60.useMemo)(() => {
    return { isDarkMode: settings.isDarkMode };
  }, [settings.isDarkMode]);
  const theme = (0, import_react60.useMemo)(() => {
    if (settings.isDarkMode) {
      return {
        brushFill: "rgba(180, 180, 180, .05)",
        brushStroke: "rgba(180, 180, 180, .25)",
        selected: "rgba(38, 150, 255, 1.000)",
        selectFill: "rgba(38, 150, 255, 0.05)",
        background: "#212529",
        foreground: "#49555f"
      };
    }
    return {};
  }, [settings.isDarkMode]);
  const handleMenuBlur = (0, import_react60.useCallback)((e12) => {
    const elm = rWrapper.current;
    if (!elm)
      return;
    if (!elm.contains(e12.relatedTarget))
      return;
    elm.dispatchEvent(new Event("pointerdown", { bubbles: true }));
    elm.dispatchEvent(new Event("pointerup", { bubbles: true }));
  }, []);
  return /* @__PURE__ */ (0, import_react60.createElement)(StyledLayout, {
    ref: rWrapper,
    tabIndex: -0,
    className: settings.isDarkMode ? dark : ""
  }, /* @__PURE__ */ (0, import_react60.createElement)(OneOff, {
    focusableRef: rWrapper,
    autofocus
  }), /* @__PURE__ */ (0, import_react60.createElement)(ContextMenu2, {
    onBlur: handleMenuBlur
  }, /* @__PURE__ */ (0, import_react60.createElement)(Renderer, {
    id,
    containerRef: rWrapper,
    shapeUtils,
    page,
    pageState,
    snapLines: appState.snapLines,
    grid: GRID_SIZE,
    users: room == null ? void 0 : room.users,
    userId: room == null ? void 0 : room.userId,
    theme,
    meta,
    hideBounds,
    hideHandles,
    hideResizeHandles: isHideResizeHandlesShape,
    hideIndicators,
    hideBindingHandles: !settings.showBindingHandles,
    hideCloneHandles: !settings.showCloneHandles,
    hideRotateHandles: !settings.showRotateHandles,
    hideGrid: !settings.showGrid,
    onPinchStart: app.onPinchStart,
    onPinchEnd: app.onPinchEnd,
    onPinch: app.onPinch,
    onPan: app.onPan,
    onZoom: app.onZoom,
    onPointerDown: app.onPointerDown,
    onPointerMove: app.onPointerMove,
    onPointerUp: app.onPointerUp,
    onPointCanvas: app.onPointCanvas,
    onDoubleClickCanvas: app.onDoubleClickCanvas,
    onRightPointCanvas: app.onRightPointCanvas,
    onDragCanvas: app.onDragCanvas,
    onReleaseCanvas: app.onReleaseCanvas,
    onPointShape: app.onPointShape,
    onDoubleClickShape: app.onDoubleClickShape,
    onRightPointShape: app.onRightPointShape,
    onDragShape: app.onDragShape,
    onHoverShape: app.onHoverShape,
    onUnhoverShape: app.onUnhoverShape,
    onReleaseShape: app.onReleaseShape,
    onPointBounds: app.onPointBounds,
    onDoubleClickBounds: app.onDoubleClickBounds,
    onRightPointBounds: app.onRightPointBounds,
    onDragBounds: app.onDragBounds,
    onHoverBounds: app.onHoverBounds,
    onUnhoverBounds: app.onUnhoverBounds,
    onReleaseBounds: app.onReleaseBounds,
    onPointBoundsHandle: app.onPointBoundsHandle,
    onDoubleClickBoundsHandle: app.onDoubleClickBoundsHandle,
    onRightPointBoundsHandle: app.onRightPointBoundsHandle,
    onDragBoundsHandle: app.onDragBoundsHandle,
    onHoverBoundsHandle: app.onHoverBoundsHandle,
    onUnhoverBoundsHandle: app.onUnhoverBoundsHandle,
    onReleaseBoundsHandle: app.onReleaseBoundsHandle,
    onPointHandle: app.onPointHandle,
    onDoubleClickHandle: app.onDoubleClickHandle,
    onRightPointHandle: app.onRightPointHandle,
    onDragHandle: app.onDragHandle,
    onHoverHandle: app.onHoverHandle,
    onUnhoverHandle: app.onUnhoverHandle,
    onReleaseHandle: app.onReleaseHandle,
    onError: app.onError,
    onRenderCountChange: app.onRenderCountChange,
    onShapeChange: app.onShapeChange,
    onShapeBlur: app.onShapeBlur,
    onShapeClone: app.onShapeClone,
    onBoundsChange: app.updateBounds,
    onKeyDown: app.onKeyDown,
    onKeyUp: app.onKeyUp
  })), showUI && /* @__PURE__ */ (0, import_react60.createElement)(StyledUI, null, settings.isFocusMode ? /* @__PURE__ */ (0, import_react60.createElement)(FocusButton, {
    onSelect: app.toggleFocusMode
  }) : /* @__PURE__ */ (0, import_react60.createElement)(import_react60.Fragment, null, /* @__PURE__ */ (0, import_react60.createElement)(TopPanel, {
    readOnly,
    showPages,
    showMenu,
    showStyles,
    showZoom,
    showSponsorLink
  }), /* @__PURE__ */ (0, import_react60.createElement)(StyledSpacer2, null), showTools && !readOnly && /* @__PURE__ */ (0, import_react60.createElement)(ToolsPanel, {
    onBlur: handleMenuBlur
  }))));
});
var OneOff = (0, import_react60.memo)(function OneOff2({
  focusableRef,
  autofocus
}) {
  useKeyboardShortcuts(focusableRef);
  useStylesheet();
  (0, import_react60.useEffect)(() => {
    var _a2;
    if (autofocus) {
      (_a2 = focusableRef.current) == null ? void 0 : _a2.focus();
    }
  }, [autofocus]);
  return null;
});
var StyledLayout = styled("div", {
  position: "absolute",
  height: "100%",
  width: "100%",
  minHeight: 0,
  minWidth: 0,
  maxHeight: "100%",
  maxWidth: "100%",
  overflow: "hidden",
  boxSizing: "border-box",
  outline: "none",
  "& .tl-container": {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%",
    zIndex: 1
  },
  "& input, textarea, button, select, label, button": {
    webkitTouchCallout: "none",
    webkitUserSelect: "none",
    "-webkit-tap-highlight-color": "transparent",
    "tap-highlight-color": "transparent"
  }
});
var StyledUI = styled("div", {
  position: "absolute",
  top: 0,
  left: 0,
  height: "100%",
  width: "100%",
  padding: "8px 8px 0 8px",
  display: "flex",
  alignItems: "flex-start",
  justifyContent: "flex-start",
  pointerEvents: "none",
  zIndex: 2,
  "& > *": {
    pointerEvents: "all"
  }
});
var StyledSpacer2 = styled("div", {
  flexGrow: 2
});

// src/app.tsx
function FileSystem() {
  const fileSystemEvents = useFileSystem();
  return /* @__PURE__ */ React9.createElement("div", {
    className: "tldraw"
  }, /* @__PURE__ */ React9.createElement(Tldraw, __spreadValues({}, fileSystemEvents)));
}

// ../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o13, p7) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o14, p8) {
    o14.__proto__ = p8;
    return o14;
  };
  return _setPrototypeOf(o13, p7);
}

// ../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// ../../node_modules/react-router/esm/react-router.js
var import_react121 = __toModule(require_react());
var import_prop_types2 = __toModule(require_prop_types());

// ../../node_modules/resolve-pathname/esm/resolve-pathname.js
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list, index2) {
  for (var i8 = index2, k3 = i8 + 1, n6 = list.length; k3 < n6; i8 += 1, k3 += 1) {
    list[i8] = list[k3];
  }
  list.pop();
}
function resolvePathname(to, from) {
  if (from === void 0)
    from = "";
  var toParts = to && to.split("/") || [];
  var fromParts = from && from.split("/") || [];
  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to && isAbsolute(to)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length)
    return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === "." || last === ".." || last === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i8 = fromParts.length; i8 >= 0; i8--) {
    var part = fromParts[i8];
    if (part === ".") {
      spliceOne(fromParts, i8);
    } else if (part === "..") {
      spliceOne(fromParts, i8);
      up++;
    } else if (up) {
      spliceOne(fromParts, i8);
      up--;
    }
  }
  if (!mustEndAbs)
    for (; up--; up)
      fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/")
    result += "/";
  return result;
}
var resolve_pathname_default = resolvePathname;

// ../../node_modules/tiny-invariant/dist/tiny-invariant.esm.js
var isProduction = true;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? prefix + ": " + provided : prefix;
  throw new Error(value);
}

// ../../node_modules/history/esm/history.js
function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === "/" ? path.substr(1) : path;
}
function hasBasename(path, prefix2) {
  return path.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path.charAt(prefix2.length)) !== -1;
}
function stripBasename(path, prefix2) {
  return hasBasename(path, prefix2) ? path.substr(prefix2.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || "/";
  var search = "";
  var hash = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search === "?" ? "" : search,
    hash: hash === "#" ? "" : hash
  };
}
function createPath(location2) {
  var pathname = location2.pathname, search = location2.search, hash = location2.hash;
  var path = pathname || "/";
  if (search && search !== "?")
    path += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    path += hash.charAt(0) === "#" ? hash : "#" + hash;
  return path;
}
function createLocation(path, state, key, currentLocation) {
  var location2;
  if (typeof path === "string") {
    location2 = parsePath(path);
    location2.state = state;
  } else {
    location2 = _extends3({}, path);
    if (location2.pathname === void 0)
      location2.pathname = "";
    if (location2.search) {
      if (location2.search.charAt(0) !== "?")
        location2.search = "?" + location2.search;
    } else {
      location2.search = "";
    }
    if (location2.hash) {
      if (location2.hash.charAt(0) !== "#")
        location2.hash = "#" + location2.hash;
    } else {
      location2.hash = "";
    }
    if (state !== void 0 && location2.state === void 0)
      location2.state = state;
  }
  try {
    location2.pathname = decodeURI(location2.pathname);
  } catch (e12) {
    if (e12 instanceof URIError) {
      throw new URIError('Pathname "' + location2.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e12;
    }
  }
  if (key)
    location2.key = key;
  if (currentLocation) {
    if (!location2.pathname) {
      location2.pathname = currentLocation.pathname;
    } else if (location2.pathname.charAt(0) !== "/") {
      location2.pathname = resolve_pathname_default(location2.pathname, currentLocation.pathname);
    }
  } else {
    if (!location2.pathname) {
      location2.pathname = "/";
    }
  }
  return location2;
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    false ? tiny_warning_esm_default(prompt == null, "A history supports only one prompt at a time") : void 0;
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt)
        prompt = null;
    };
  }
  function confirmTransitionTo(location2, action3, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location2, action3) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          false ? tiny_warning_esm_default(false, "A history needs a getUserConfirmation function in order to use a prompt message") : void 0;
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners = [];
  function appendListener(fn) {
    var isActive = true;
    function listener() {
      if (isActive)
        fn.apply(void 0, arguments);
    }
    listeners.push(listener);
    return function() {
      isActive = false;
      listeners = listeners.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners3() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners: notifyListeners3
  };
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message));
}
function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1)
    return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event) {
  return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e12) {
    return {};
  }
}
function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? false ? invariant(false, "Browser history needs a DOM") : invariant(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref = historyState || {}, key = _ref.key, state = _ref.state;
    var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
    var path = pathname + search + hash;
    false ? tiny_warning_esm_default(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : void 0;
    if (basename)
      path = stripBasename(path, basename);
    return createLocation(path, state, key);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends3(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event) {
    if (isExtraneousPopstateEvent(event))
      return;
    handlePop(getDOMLocation(event.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action3 = "POP";
      transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action: action3,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location2) {
    return basename + createPath(location2);
  }
  function push3(path, state) {
    false ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
    var action3 = "PUSH";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var href = createHref(location2);
      var key = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location2.key);
          allKeys = nextKeys;
          setState({
            action: action3,
            location: location2
          });
        }
      } else {
        false ? tiny_warning_esm_default(state2 === void 0, "Browser history cannot push state in browsers that do not support HTML5 history") : void 0;
        window.location.href = href;
      }
    });
  }
  function replace3(path, state) {
    false ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
    var action3 = "REPLACE";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var href = createHref(location2);
      var key = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1)
            allKeys[prevIndex] = location2.key;
          setState({
            action: action3,
            location: location2
          });
        }
      } else {
        false ? tiny_warning_esm_default(state2 === void 0, "Browser history cannot replace state in browsers that do not support HTML5 history") : void 0;
        window.location.replace(href);
      }
    });
  }
  function go(n6) {
    globalHistory.go(n6);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push: push3,
    replace: replace3,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === "!" ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};
function stripHash(url) {
  var hashIndex = url.indexOf("#");
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path) {
  window.location.hash = path;
}
function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + "#" + path);
}
function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? false ? invariant(false, "Hash history needs a DOM") : invariant(false) : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path2 = decodePath2(getHashPath());
    false ? tiny_warning_esm_default(!basename || hasBasename(path2, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path2 + '" to begin with "' + basename + '".') : void 0;
    if (basename)
      path2 = stripBasename(path2, basename);
    return createLocation(path2);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends3(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a9, b7) {
    return a9.pathname === b7.pathname && a9.search === b7.search && a9.hash === b7.hash;
  }
  function handleHashChange() {
    var path2 = getHashPath();
    var encodedPath2 = encodePath2(path2);
    if (path2 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location2 = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location2))
        return;
      if (ignorePath === createPath(location2))
        return;
      ignorePath = null;
      handlePop(location2);
    }
  }
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action3 = "POP";
      transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action: action3,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var path = getHashPath();
  var encodedPath = encodePath2(path);
  if (path !== encodedPath)
    replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location2) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename + createPath(location2));
  }
  function push3(path2, state) {
    false ? tiny_warning_esm_default(state === void 0, "Hash history cannot push state; it is ignored") : void 0;
    var action3 = "PUSH";
    var location2 = createLocation(path2, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path3);
        allPaths = nextPaths;
        setState({
          action: action3,
          location: location2
        });
      } else {
        false ? tiny_warning_esm_default(false, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack") : void 0;
        setState();
      }
    });
  }
  function replace3(path2, state) {
    false ? tiny_warning_esm_default(state === void 0, "Hash history cannot replace state; it is ignored") : void 0;
    var action3 = "REPLACE";
    var location2 = createLocation(path2, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1)
        allPaths[prevIndex] = path3;
      setState({
        action: action3,
        location: location2
      });
    });
  }
  function go(n6) {
    false ? tiny_warning_esm_default(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser") : void 0;
    globalHistory.go(n6);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push: push3,
    replace: replace3,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
function clamp2(n6, lowerBound, upperBound) {
  return Math.min(Math.max(n6, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends3(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index2 = clamp2(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push3(path, state) {
    false ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
    var action3 = "PUSH";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location2);
      } else {
        nextEntries.push(location2);
      }
      setState({
        action: action3,
        location: location2,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace3(path, state) {
    false ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
    var action3 = "REPLACE";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
      if (!ok)
        return;
      history.entries[history.index] = location2;
      setState({
        action: action3,
        location: location2
      });
    });
  }
  function go(n6) {
    var nextIndex = clamp2(history.index + n6, 0, history.entries.length - 1);
    var action3 = "POP";
    var location2 = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location2, action3, getUserConfirmation, function(ok) {
      if (ok) {
        setState({
          action: action3,
          location: location2,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  function canGo(n6) {
    var nextIndex = history.index + n6;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries.length,
    action: "POP",
    location: entries[index2],
    index: index2,
    entries,
    createHref,
    push: push3,
    replace: replace3,
    go,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };
  return history;
}

// ../../node_modules/mini-create-react-context/dist/esm/index.js
var import_react120 = __toModule(require_react());
var import_prop_types = __toModule(require_prop_types());
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}
function objectIs(x5, y4) {
  if (x5 === y4) {
    return x5 !== 0 || 1 / x5 === 1 / y4;
  } else {
    return x5 !== x5 && y4 !== y4;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h3) {
        return h3 !== handler;
      });
    },
    get: function get5() {
      return value;
    },
    set: function set6(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider = /* @__PURE__ */ function(_Component) {
    _inheritsLoose3(Provider2, _Component);
    function Provider2() {
      var _this;
      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider2.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          if (false) {
            tiny_warning_esm_default((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, "calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: " + changedBits);
          }
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render() {
      return this.props.children;
    };
    return Provider2;
  }(import_react120.Component);
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = import_prop_types.default.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_Component2) {
    _inheritsLoose3(Consumer2, _Component2);
    function Consumer2() {
      var _this2;
      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(import_react120.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = import_prop_types.default.object, _Consumer$contextType);
  return {
    Provider,
    Consumer
  };
}
var index = import_react120.default.createContext || createReactContext;
var esm_default = index;

// ../../node_modules/react-router/esm/react-router.js
var import_path_to_regexp = __toModule(require_path_to_regexp());
var import_react_is = __toModule(require_react_is());

// ../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i8;
  for (i8 = 0; i8 < sourceKeys.length; i8++) {
    key = sourceKeys[i8];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// ../../node_modules/react-router/esm/react-router.js
var import_hoist_non_react_statics = __toModule(require_hoist_non_react_statics_cjs());
var createNamedContext = function createNamedContext2(name) {
  var context2 = esm_default();
  context2.displayName = name;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
var context = /* @__PURE__ */ createNamedContext("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location2) {
        if (_this._isMounted) {
          _this.setState({
            location: location2
          });
        } else {
          _this._pendingLocation = location2;
        }
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };
  _proto.render = function render() {
    return /* @__PURE__ */ import_react121.default.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /* @__PURE__ */ import_react121.default.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(import_react121.default.Component);
if (false) {
  Router.propTypes = {
    children: import_prop_types2.default.node,
    history: import_prop_types2.default.object.isRequired,
    staticContext: import_prop_types2.default.object
  };
  Router.prototype.componentDidUpdate = function(prevProps) {
    false ? tiny_warning_esm_default(prevProps.history === this.props.history, "You cannot change <Router history>") : void 0;
  };
}
var MemoryRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ import_react121.default.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
}(import_react121.default.Component);
if (false) {
  MemoryRouter.propTypes = {
    initialEntries: import_prop_types2.default.array,
    initialIndex: import_prop_types2.default.number,
    getUserConfirmation: import_prop_types2.default.func,
    keyLength: import_prop_types2.default.number,
    children: import_prop_types2.default.node
  };
  MemoryRouter.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.") : void 0;
  };
}
var Lifecycle = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render() {
    return null;
  };
  return Lifecycle2;
}(import_react121.default.Component);
if (false) {
  messageType = import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.string]);
  Prompt.propTypes = {
    when: import_prop_types2.default.bool,
    message: messageType.isRequired
  };
}
var messageType;
if (false) {
  Redirect.propTypes = {
    push: import_prop_types2.default.bool,
    from: import_prop_types2.default.string,
    to: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.object]).isRequired
  };
}
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path, options2) {
  var cacheKey = "" + options2.end + options2.strict + options2.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path])
    return pathCache[path];
  var keys = [];
  var regexp = (0, import_path_to_regexp.default)(path, keys, options2);
  var result = {
    regexp,
    keys
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (typeof options2 === "string" || Array.isArray(options2)) {
    options2 = {
      path: options2
    };
  }
  var _options = options2, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function(matched, path2) {
    if (!path2 && path2 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1(path2, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys = _compilePath.keys;
    var match = regexp.exec(pathname);
    if (!match)
      return null;
    var url = match[0], values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact)
      return null;
    return {
      path: path2,
      url: path2 === "/" && url === "" ? "/" : url,
      isExact,
      params: keys.reduce(function(memo9, key, index2) {
        memo9[key.name] = values[index2];
        return memo9;
      }, {})
    };
  }, null);
}
function isEmptyChildren(children) {
  return import_react121.default.Children.count(children) === 0;
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ import_react121.default.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? false ? invariant(false, "You should not use <Route> outside a <Router>") : invariant(false) : void 0;
      var location2 = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location2.pathname, _this.props) : context$1.match;
      var props = _extends3({}, context$1, {
        location: location2,
        match
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render2 = _this$props.render;
      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }
      return /* @__PURE__ */ import_react121.default.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? false ? evalChildrenDev(children, props, _this.props.path) : children(props) : children : component ? /* @__PURE__ */ import_react121.default.createElement(component, props) : render2 ? render2(props) : null : typeof children === "function" ? false ? evalChildrenDev(children, props, _this.props.path) : children(props) : null);
    });
  };
  return Route2;
}(import_react121.default.Component);
if (false) {
  Route.propTypes = {
    children: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.node]),
    component: function component(props, propName) {
      if (props[propName] && !(0, import_react_is.isValidElementType)(props[propName])) {
        return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
      }
    },
    exact: import_prop_types2.default.bool,
    location: import_prop_types2.default.object,
    path: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.arrayOf(import_prop_types2.default.string)]),
    render: import_prop_types2.default.func,
    sensitive: import_prop_types2.default.bool,
    strict: import_prop_types2.default.bool
  };
  Route.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : void 0;
    false ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : void 0;
    false ? tiny_warning_esm_default(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : void 0;
  };
  Route.prototype.componentDidUpdate = function(prevProps) {
    false ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
    false ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}
function addLeadingSlash2(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function addBasename(basename, location2) {
  if (!basename)
    return location2;
  return _extends3({}, location2, {
    pathname: addLeadingSlash2(basename) + location2.pathname
  });
}
function stripBasename2(basename, location2) {
  if (!basename)
    return location2;
  var base = addLeadingSlash2(basename);
  if (location2.pathname.indexOf(base) !== 0)
    return location2;
  return _extends3({}, location2, {
    pathname: location2.pathname.substr(base.length)
  });
}
function createURL(location2) {
  return typeof location2 === "string" ? location2 : createPath(location2);
}
function staticHandler(methodName) {
  return function() {
    false ? invariant(false, "You cannot %s with <StaticRouter>", methodName) : invariant(false);
  };
}
function noop5() {
}
var StaticRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location2) {
      return _this.navigateTo(location2, "PUSH");
    };
    _this.handleReplace = function(location2) {
      return _this.navigateTo(location2, "REPLACE");
    };
    _this.handleListen = function() {
      return noop5;
    };
    _this.handleBlock = function() {
      return noop5;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location2, action3) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action3;
    context2.location = addBasename(basename, createLocation(location2));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location2 = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose3(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash2(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename2(basename, createLocation(location2)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /* @__PURE__ */ import_react121.default.createElement(Router, _extends3({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter2;
}(import_react121.default.Component);
if (false) {
  StaticRouter.propTypes = {
    basename: import_prop_types2.default.string,
    context: import_prop_types2.default.object,
    location: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.object])
  };
  StaticRouter.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.") : void 0;
  };
}
var Switch = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ import_react121.default.createElement(context.Consumer, null, function(context2) {
      !context2 ? false ? invariant(false, "You should not use <Switch> outside a <Router>") : invariant(false) : void 0;
      var location2 = _this.props.location || context2.location;
      var element, match;
      import_react121.default.Children.forEach(_this.props.children, function(child) {
        if (match == null && /* @__PURE__ */ import_react121.default.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location2.pathname, _extends3({}, child.props, {
            path
          })) : context2.match;
        }
      });
      return match ? /* @__PURE__ */ import_react121.default.cloneElement(element, {
        location: location2,
        computedMatch: match
      }) : null;
    });
  };
  return Switch2;
}(import_react121.default.Component);
if (false) {
  Switch.propTypes = {
    children: import_prop_types2.default.node,
    location: import_prop_types2.default.object
  };
  Switch.prototype.componentDidUpdate = function(prevProps) {
    false ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
    false ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}
var useContext5 = import_react121.default.useContext;
if (false) {
  if (typeof window !== "undefined") {
    global2 = window;
    key = "__react_router_build__";
    buildNames = {
      cjs: "CommonJS",
      esm: "ES modules",
      umd: "UMD"
    };
    if (global2[key] && global2[key] !== "esm") {
      initialBuildName = buildNames[global2[key]];
      secondaryBuildName = buildNames["esm"];
      throw new Error("You are loading the " + secondaryBuildName + " build of React Router " + ("on a page that is already running the " + initialBuildName + " ") + "build, so things won't work right.");
    }
    global2[key] = "esm";
  }
}
var global2;
var key;
var buildNames;
var initialBuildName;
var secondaryBuildName;

// ../../node_modules/react-router-dom/esm/react-router-dom.js
var import_react122 = __toModule(require_react());
var import_prop_types3 = __toModule(require_prop_types());
var BrowserRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(BrowserRouter2, _React$Component);
  function BrowserRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }
  var _proto = BrowserRouter2.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ import_react122.default.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return BrowserRouter2;
}(import_react122.default.Component);
if (false) {
  BrowserRouter.propTypes = {
    basename: import_prop_types3.default.string,
    children: import_prop_types3.default.node,
    forceRefresh: import_prop_types3.default.bool,
    getUserConfirmation: import_prop_types3.default.func,
    keyLength: import_prop_types3.default.number
  };
  BrowserRouter.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.") : void 0;
  };
}
var HashRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(HashRouter2, _React$Component);
  function HashRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }
  var _proto = HashRouter2.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ import_react122.default.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return HashRouter2;
}(import_react122.default.Component);
if (false) {
  HashRouter.propTypes = {
    basename: import_prop_types3.default.string,
    children: import_prop_types3.default.node,
    getUserConfirmation: import_prop_types3.default.func,
    hashType: import_prop_types3.default.oneOf(["hashbang", "noslash", "slash"])
  };
  HashRouter.prototype.componentDidMount = function() {
    false ? tiny_warning_esm_default(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.") : void 0;
  };
}
var resolveToLocation = function resolveToLocation2(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation2(to, currentLocation) {
  return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
};
var forwardRefShim = function forwardRefShim2(C6) {
  return C6;
};
var forwardRef25 = import_react122.default.forwardRef;
if (typeof forwardRef25 === "undefined") {
  forwardRef25 = forwardRefShim;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var LinkAnchor = forwardRef25(function(_ref, forwardedRef) {
  var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose3(_ref, ["innerRef", "navigate", "onClick"]);
  var target = rest.target;
  var props = _extends3({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick)
          _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }
      if (!event.defaultPrevented && event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
        event.preventDefault();
        navigate();
      }
    }
  });
  if (forwardRefShim !== forwardRef25) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  return /* @__PURE__ */ import_react122.default.createElement("a", props);
});
if (false) {
  LinkAnchor.displayName = "LinkAnchor";
}
var Link = forwardRef25(function(_ref2, forwardedRef) {
  var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace3 = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose3(_ref2, ["component", "replace", "to", "innerRef"]);
  return /* @__PURE__ */ import_react122.default.createElement(context.Consumer, null, function(context2) {
    !context2 ? false ? invariant(false, "You should not use <Link> outside a <Router>") : invariant(false) : void 0;
    var history = context2.history;
    var location2 = normalizeToLocation(resolveToLocation(to, context2.location), context2.location);
    var href = location2 ? history.createHref(location2) : "";
    var props = _extends3({}, rest, {
      href,
      navigate: function navigate() {
        var location3 = resolveToLocation(to, context2.location);
        var isDuplicateNavigation = createPath(context2.location) === createPath(normalizeToLocation(location3));
        var method = replace3 || isDuplicateNavigation ? history.replace : history.push;
        method(location3);
      }
    });
    if (forwardRefShim !== forwardRef25) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return /* @__PURE__ */ import_react122.default.createElement(component, props);
  });
});
if (false) {
  toType = import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.object, import_prop_types3.default.func]);
  refType = import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.func, import_prop_types3.default.shape({
    current: import_prop_types3.default.any
  })]);
  Link.displayName = "Link";
  Link.propTypes = {
    innerRef: refType,
    onClick: import_prop_types3.default.func,
    replace: import_prop_types3.default.bool,
    target: import_prop_types3.default.string,
    to: toType.isRequired
  };
}
var toType;
var refType;
var forwardRefShim$1 = function forwardRefShim3(C6) {
  return C6;
};
var forwardRef$1 = import_react122.default.forwardRef;
if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}
function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }
  return classnames.filter(function(i8) {
    return i8;
  }).join(" ");
}
var NavLink = forwardRef$1(function(_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to = _ref.to, innerRef = _ref.innerRef, rest = _objectWithoutPropertiesLoose3(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
  return /* @__PURE__ */ import_react122.default.createElement(context.Consumer, null, function(context2) {
    !context2 ? false ? invariant(false, "You should not use <NavLink> outside a <Router>") : invariant(false) : void 0;
    var currentLocation = locationProp || context2.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname;
    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? matchPath(currentLocation.pathname, {
      path: escapedPath,
      exact,
      sensitive,
      strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;
    var style = typeof styleProp === "function" ? styleProp(isActive) : styleProp;
    if (isActive) {
      className = joinClassnames(className, activeClassName);
      style = _extends3({}, style, activeStyle);
    }
    var props = _extends3({
      "aria-current": isActive && ariaCurrent || null,
      className,
      style,
      to: toLocation
    }, rest);
    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return /* @__PURE__ */ import_react122.default.createElement(Link, props);
  });
});
if (false) {
  NavLink.displayName = "NavLink";
  ariaCurrentType = import_prop_types3.default.oneOf(["page", "step", "location", "date", "time", "true", "false"]);
  NavLink.propTypes = _extends3({}, Link.propTypes, {
    "aria-current": ariaCurrentType,
    activeClassName: import_prop_types3.default.string,
    activeStyle: import_prop_types3.default.object,
    className: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.func]),
    exact: import_prop_types3.default.bool,
    isActive: import_prop_types3.default.func,
    location: import_prop_types3.default.object,
    sensitive: import_prop_types3.default.bool,
    strict: import_prop_types3.default.bool,
    style: import_prop_types3.default.oneOfType([import_prop_types3.default.object, import_prop_types3.default.func])
  });
}
var ariaCurrentType;

// src/index.tsx
import_react_dom3.default.render(/* @__PURE__ */ import_react123.default.createElement(import_react123.default.StrictMode, null, /* @__PURE__ */ import_react123.default.createElement(HashRouter, null, /* @__PURE__ */ import_react123.default.createElement(FileSystem, null))), document.getElementById("root"));
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * hotkeys-js v3.8.7
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
 * 
 * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
 * http://jaywcjlove.github.io/hotkeys
 * 
 * Licensed under the MIT license.
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * String.prototype.replaceAll() polyfill
 * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/
 * @author Chris Ferdinandi
 * @license MIT
 */
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// @license  2020 Google LLC. Licensed under the Apache License, Version 2.0.
